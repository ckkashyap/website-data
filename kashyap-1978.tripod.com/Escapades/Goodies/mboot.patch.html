<HTML>
<HEAD>
<TITLE></TITLE>
<LINK rel="stylesheet" type="text/css" href="/modern.css">
</HEAD>
	<body><!--'"</title></head>-->

<script type="text/javascript">
//OwnerIQ
var __oiq_pct = 50;
if( __oiq_pct>=100 || Math.floor(Math.random()*100/(100-__oiq_pct)) > 0 ) {
var _oiqq = _oiqq || [];
_oiqq.push(['oiq_addPageBrand','Lycos']);
_oiqq.push(['oiq_addPageCat','Internet > Websites']);
_oiqq.push(['oiq_addPageLifecycle','Intend']);
_oiqq.push(['oiq_doTag']);
(function() {
var oiq = document.createElement('script'); oiq.type = 'text/javascript'; oiq.async = true;
oiq.src = document.location.protocol + '//px.owneriq.net/stas/s/lycosn.js';
var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(oiq, s);
})();
}
//Google Analytics
var _gaq = _gaq || [];
_gaq.push(['_setAccount','UA-21402695-19']);
_gaq.push(['_setDomainName','tripod.com']);
_gaq.push(['_setCustomVar',1,'member_name','kashyap-1978',3]);
_gaq.push(['_trackPageview']);
(function() {
var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
})();
//Lycos Init
function getReferrer() {
var all= this.document.cookie;
if (all== '') return false;
var cookie_name = 'REFERRER=';
var start = all.lastIndexOf(cookie_name);
if (start == -1) return false;
start += cookie_name.length;
var end = all.indexOf(';', start);
if (end == -1) end = all.length;
return all.substring(start, end);
}
function getQuery() {
var rfr = getReferrer();
if (rfr == '') return false;
var q = extractQuery(rfr, 'yahoo.com', 'p=');
if (q) return q;
q = extractQuery(rfr, '', 'q=');
return q ? q : "";
}
function extractQuery(full, site, q_param) {
var start = full.lastIndexOf(site);
if (start == -1) return false;
start = full.lastIndexOf(q_param);
if (start == -1) return false;
start += q_param.length;
var end = full.indexOf('&', start);
if (end == -1) end = full.length;
return unescape(full.substring(start, end)).split(" ").join("+");
}
function generateHref(atag, template){
atag.href=template.replace('_MYURL_', window.location.href.replace('http://', '')).replace('_MYTITLE_','Check%20out%20this%20Tripod%20Member%20site!'); 
}
var lycos_ad = Array();
var lycos_onload_timer;
var cm_role = "live";
var cm_host = "tripod.lycos.com";
var cm_taxid = "/memberembedded";
var tripod_member_name = "kashyap-1978";
var tripod_member_page = "kashyap-1978/Escapades/Goodies/mboot.patch.html";
var tripod_ratings_hash = "1698513544:35e872b220c773e91ca908018c45248a";

var lycos_ad_category = null;

var lycos_ad_remote_addr = "209.202.244.9";
var lycos_ad_www_server = "www.tripod.lycos.com";
var lycos_ad_track_small = "";
var lycos_ad_track_served = "";
var lycos_search_query = getQuery();
</script>

<script type="text/javascript" src="https://scripts.lycos.com/catman/init.js"></script>

<script type='text/javascript'>
 var googletag = googletag || {};
 googletag.cmd = googletag.cmd || [];
 (function() {
   var gads = document.createElement('script');
   gads.async = true;
   gads.type = 'text/javascript';
   var useSSL = 'https:' == document.location.protocol;
   gads.src = (useSSL ? 'https:' : 'http:') +
     '//www.googletagservices.com/tag/js/gpt.js';
   var node = document.getElementsByTagName('script')[0];
   node.parentNode.insertBefore(gads, node);
 })();
</script>

<script type='text/javascript'>
 googletag.cmd.push(function() {
   googletag.defineSlot('/95963596/TRI_300X250_dfp', [300, 250], 'div-gpt-ad-1450204159126-0').addService(googletag.pubads());
   googletag.defineSlot('/95963596/TRI_above_728x90_dfp', [728, 90], 'div-gpt-ad-1450204159126-1').addService(googletag.pubads());
   googletag.defineSlot('/95963596/TRI_below_728x90_dfp', [728, 90], 'div-gpt-ad-1450204159126-2').addService(googletag.pubads());
   googletag.pubads().enableSingleRequest();
   googletag.enableServices();
 });
</script>


<script type="text/javascript"> 
(function(isV)
{
    if( !isV )
    {
        return;
    }
    var adMgr = new AdManager();
    var lycos_prod_set = adMgr.chooseProductSet();
    var slots = ["leaderboard", "leaderboard2", "toolbar_image", "toolbar_text", "smallbox", "top_promo", "footer2", "slider"];
    var adCat = this.lycos_ad_category;
    adMgr.setForcedParam('page', (adCat && adCat.dmoz) ? adCat.dmoz : 'member');
    if (this.lycos_search_query)
    {
        adMgr.setForcedParam("keyword", this.lycos_search_query);
    } 
    else if(adCat && adCat.find_what)
    {
        adMgr.setForcedParam('keyword', adCat.find_what);
    }
    
    for (var s in slots)
    {
        var slot = slots[s];
        if (adMgr.isSlotAvailable(slot))
        {
            this.lycos_ad[slot] = adMgr.getSlot(slot);
        }
    }

    adMgr.renderHeader();
    adMgr.renderFooter();
}((function() {

var w = 0, h = 0, minimumThreshold = 300;

if (top == self)
{
    return true;
}
if (typeof(window.innerWidth) == 'number' )
{
    w = window.innerWidth;
    h = window.innerHeight;
}
else if (document.documentElement && (document.documentElement.clientWidth || document.documentElement.clientHeight))
{
    w = document.documentElement.clientWidth;
    h = document.documentElement.clientHeight;
}
else if (document.body && (document.body.clientWidth || document.body.clientHeight))
{
    w = document.body.clientWidth;
    h = document.body.clientHeight;
}
return ((w > minimumThreshold) && (h > minimumThreshold));
}())));




window.onload = function()
{
    var f = document.getElementById("FooterAd");
    var b = document.getElementsByTagName("body")[0];
    b.appendChild(f);
    f.style.display = "block";
    document.getElementById('lycosFooterAdiFrame').src = '/adm/ad/footerAd.iframe.html';
    


    
    // DOM Inj Ad
    (function(isTrellix)
    {
        var e = document.createElement('iframe');
        e.style.border = '0';
        e.style.margin = 0;
        e.style.display = 'block';
        e.style.cssFloat = 'right';
        e.style.height = '254px';
        e.style.overflow = 'hidden';
        e.style.padding = 0;
        e.style.width = '300px';


        var isBlokedByDomain = function( href )
        {
            var blockedDomains = [
                "ananyaporn13000.tripod.com",
                "xxxpornxxx.tripod.com"
            ];
            var flag = false;
            
            for( var i=0; i<blockedDomains.length; i++ )
            {
                if( href.search( blockedDomains[ i ] ) >= 0 )
                {
                    flag = true;
                }
            }
            return flag;
        }

        var getMetaContent = function( metaName )
        {
            var metas = document.getElementsByTagName('meta');
            for (i=0; i<metas.length; i++)
            { 
                if( metas[i].getAttribute("name") == metaName )
                { 
                    return metas[i].getAttribute("content"); 
                } 
            }
            return false;
        }
        
        var getCommentNodes = function(regexPattern)
        {
            var nodes = {};
            var nodesA = [];
            var preferredNodesList = ['a', 'c', 'b'];
        
            (function getNodesThatHaveComments(n, pattern)
            {
                if (n.hasChildNodes())
                {
                    if (n.tagName === 'IFRAME')
                    {
                        return false;
                    }
                    for (var i = 0; i < n.childNodes.length; i++)
                    {
                        if ((n.childNodes[i].nodeType === 8) && (pattern.test(n.childNodes[i].nodeValue)))
                        {
                            var areaName = pattern.exec(n.childNodes[i].nodeValue)[1];
                            nodes[areaName] = n;
                        }
                        else if (n.childNodes[i].nodeType === 1)
                        {
                            getNodesThatHaveComments(n.childNodes[i], pattern);
                        }
                    }
                }
            }(document.body, regexPattern));

            for (var i in preferredNodesList)
            {
                if (nodes[preferredNodesList[i]])
                {
                    if( isTrellix && nodes[preferredNodesList[i]].parentNode.parentNode.parentNode.parentNode )
                    {
                        nodesA.push(nodes[preferredNodesList[i]].parentNode.parentNode.parentNode.parentNode);
                    }
                    else
                    {
                        nodesA.push( nodes[preferredNodesList[i]] );
                    }
                }
            }
            return nodesA;
        }
        
        
        var properNode = null;
        var areaNodes = getCommentNodes( new RegExp( '^area Type="area_(\\w+)"' ) );

        for (var i = 0; i < areaNodes.length; i++)
        {
            var a = parseInt(getComputedStyle(areaNodes[i]).width);
            if ((a >= 300) && (a <= 400))
            {
                properNode = areaNodes[i];
                break;
            }
        }


        var propertyName = getMetaContent("property") || false;
        if( isTrellix && (properNode) )
        {
            e.src = '/adm/ad/injectAd.iframe.html';
            properNode.insertBefore(e, properNode.firstChild);
        }
        else if( isTrellix && !( properNode ) ) // Slap the ad eventhought there is no alocated slot
        {
            e.src = '/adm/ad/injectAd.iframe.html';
            e.style.cssFloat = 'none';
            var cdiv = document.createElement('div');
            cdiv.style = "width:300px;margin:10px auto;";
            cdiv.appendChild( e );
            b.insertBefore(cdiv, b.lastChild);
        }
        else if( !isBlokedByDomain( location.href ) )
        {
            var injF = document.createElement('iframe');
            injF.style.border = '0';
            injF.style.margin = 0;
            injF.style.display = 'block';
            injF.style.cssFloat = 'none';
            injF.style.height = '254px';
            injF.style.overflow = 'hidden';
            injF.style.padding = 0;
            injF.style.width = '300px';
            injF.src = '/adm/ad/injectAd.iframe.html';

            if( b && ( !isTrellix || ( typeof isTrellix == "undefined" ) ) ) // All other tripod props
            {
                var cdiv = document.createElement('div');
                cdiv.style = "width:300px;margin:10px auto;";
                cdiv.appendChild( injF );
                b.insertBefore(cdiv, b.lastChild);
            } 
        }
  }( document.isTrellix ));
}

</script>

<div id="tb_container" style="background:#DFDCCF; border-bottom:1px solid #393939; position:relative; z-index:999999999!important">
<!--form name="search" onSubmit="return searchit()" id='header_search' >
<input type="text" placeholder="Search" size=30 name="search2" value="">
<input type="button" value="Go!" onClick="searchit()">
</form>
<style>
form#header_search {
    width: 916px;
    margin: 0 auto 8px;
    position: relative;
}


form#header_search input {
    height: 40px;
    font-size: 14px;
    line-height: 40px;
    padding: 0 8px;
    box-sizing: border-box;
    background: #F4F2E9;
    border: 1px solid #BBB8B8;
    transition: background-color 300ms ease-out,
                color 300ms ease;
}

form#header_search input[type="text"] {
    width: 100%;
}
form#header_search input[type="text"]:focus {
    border-color: #A2D054;
    background-color: #fff;
    box-shadow: 0 0px 12px -4px #A2D054;
}



form#header_search input[type="button"] {
    position: absolute;
    top: 1px;
    right: 1px;
    opacity: 1;
    background: #DFDCCF;
    color: #463734;
    width: 125px;
    cursor: pointer;
    height: 38px;
    border: none;
}
form#header_search input[type="text"]:focus ~ input[type='button']:hover,
form#header_search input[type='button']:hover {
    background-color: #A5CE56;
    color: #fff;
}
form#header_search input[type="text"]:focus ~ input[type='button'] {
    background-color: #52AEDF;
    color: #fff;
}

</style>

<script>
function searchit(){
    
    // determine environment 
    var search_env 
    if (lycos_ad_www_server.indexOf(".pd.") > -1) {
       search_env = 'http://search51.pd.lycos.com/a/';
    } else if (lycos_ad_www_server.indexOf(".qa.") > -1) {
       search_env = 'http://search51.qa.lycos.com/a/';
    } else {
       search_env = 'http://search51.lycos.com/a/';
    }

var search_term = encodeURIComponent(document.search.search2.value)
var search_url = search_env+search_term;
window.open(search_url);

return false
}
</script-->
<style>
    .adCenterClass{margin:0 auto}
</style>
<div id="tb_ad" class="adCenterClass" style="display:block!important; overflow:hidden; width:916px;">

<div id="ad_container" style="display:block!important; float:left; width:728px ">
<script type="text/javascript">
if (typeof lycos_ad !== "undefined" && "leaderboard" in lycos_ad) {
  document.write(lycos_ad['leaderboard']);
}
</script>
</div>
</div>
</div>
<script type="text/javascript">
if (typeof lycos_ad !== "undefined" && "slider" in lycos_ad) {
  document.write(lycos_ad['slider']);
}
</script> <!-- added 7/22 -->
<div id="FooterAd" style="background:#DFDCCF; border-top:1px solid #393939; clear:both; display:none; width:100%!important; position:relative; z-index:999999!important; height:90px!important"> 
<div class="adCenterClass" style="display:block!important; overflow:hidden; width:916px;">
<div id="footerAd_container" style="display:block!important; float:left; width:728px">
<iframe id="lycosFooterAdiFrame" style="border:0; display:block; float:left; height:96px; overflow:hidden; padding:0; width:750px"></iframe>
</div>
</div>
</div>


		<div class=Header>mboot.patch</div>
		<BR>
		<table class=mainTable>
			<tr>
				<td class="leftColumn">
					<div class=mbutton ><A href='Construct_WAV.html'>Construct_WAV</A><A href='Raw_Ethernet.html'>Raw_Ethernet</A><A href='Read_File_From_Kernel_Module.html'>Read_File_From_Kernel_Module</A><A href='accelerate.pl.html'>accelerate.pl</A><A href='header_file_dependencies.html'>header_file_dependencies</A><A href='mboot.patch.html'>mboot.patch</A><A href='vi_tips.html'>vi_tips</A></div>
				</td>
				<td class=verticalBar>
					 
				</td>
				<td class=contentArea>
					<table class=subTable>
						<tr>
							<td class=dirMenu>
								<div class=dirMenu><DIV class=topNav><a href='/About_me.html'>Home</a></DIV></div>
							</td>
						</tr>
						<tr>
							<td class=fileArea>
								<PRE><font color="#a52a2a">   1</font>  <font color="#2e8b57"><b>diff -urbN linux/arch/i386/Makefile linux.new/arch/i386/Makefile</b></font>
<font color="#a52a2a">   2</font>  <font color="#2e8b57"><b>--- linux/arch/i386/Makefile    Thu Apr 12 21:20:31 2001</b></font>
<font color="#a52a2a">   3</font>  <font color="#2e8b57"><b>+++ linux.new/arch/i386/Makefile        Wed Nov 28 00:26:22 2001</b></font>
<font color="#a52a2a">   4</font>  <font color="#a52a2a"><b>@@ -18,7 +18,7 @@</b></font>
<font color="#a52a2a">   5</font>
<font color="#a52a2a">   6</font>   LD=$(CROSS_COMPILE)ld -m elf_i386
<font color="#a52a2a">   7</font>   OBJCOPY=$(CROSS_COMPILE)objcopy -O binary -R .note -R .comment -S
<font color="#a52a2a">   8</font>  <font color="#6a5acd">-LDFLAGS=-e stext</font>
<font color="#a52a2a">   9</font>  <font color="#008b8b">+LDFLAGS=</font>
<font color="#a52a2a">  10</font>   LINKFLAGS =-T $(TOPDIR)/arch/i386/vmlinux.lds $(LDFLAGS)
<font color="#a52a2a">  11</font>
<font color="#a52a2a">  12</font>   CFLAGS += -pipe
<font color="#a52a2a">  13</font>  <font color="#2e8b57"><b>diff -urbN linux/arch/i386/kernel/Makefile linux.new/arch/i386/kernel/Makefile</b></font>
<font color="#a52a2a">  14</font>  <font color="#2e8b57"><b>--- linux/arch/i386/kernel/Makefile     Tue Sep 18 08:03:09 2001</b></font>
<font color="#a52a2a">  15</font>  <font color="#2e8b57"><b>+++ linux.new/arch/i386/kernel/Makefile Wed Dec  5 22:12:44 2001</b></font>
<font color="#a52a2a">  16</font>  <font color="#a52a2a"><b>@@ -18,7 +18,8 @@</b></font>
<font color="#a52a2a">  17</font>
<font color="#a52a2a">  18</font>   obj-y  := process.o semaphore.o signal.o entry.o traps.o irq.o vm86.o \
<font color="#a52a2a">  19</font>                  ptrace.o i8259.o ioport.o ldt.o setup.o time.o sys_i386.o \
<font color="#a52a2a">  20</font>  <font color="#6a5acd">-               pci-dma.o i386_ksyms.o i387.o bluesmoke.o dmi_scan.o</font>
<font color="#a52a2a">  21</font>  <font color="#008b8b">+               pci-dma.o i386_ksyms.o i387.o bluesmoke.o dmi_scan.o \</font>
<font color="#a52a2a">  22</font>  <font color="#008b8b">+               obj_i386.o</font>
<font color="#a52a2a">  23</font>
<font color="#a52a2a">  24</font>
<font color="#a52a2a">  25</font>   ifdef CONFIG_PCI
<font color="#a52a2a">  26</font>  <font color="#2e8b57"><b>diff -urbN linux/arch/i386/kernel/head.S linux.new/arch/i386/kernel/head.S</b></font>
<font color="#a52a2a">  27</font>  <font color="#2e8b57"><b>--- linux/arch/i386/kernel/head.S       Wed Jun 20 20:00:53 2001</b></font>
<font color="#a52a2a">  28</font>  <font color="#2e8b57"><b>+++ linux.new/arch/i386/kernel/head.S   Fri Nov 30 21:40:30 2001</b></font>
<font color="#a52a2a">  29</font>  <font color="#a52a2a"><b>@@ -7,6 +7,9 @@</b></font>
<font color="#a52a2a">  30</font>    *  and Martin Mares, November 1997.
<font color="#a52a2a">  31</font>    */
<font color="#a52a2a">  32</font>
<font color="#a52a2a">  33</font>  <font color="#008b8b">+#define ASM    1</font>
<font color="#a52a2a">  34</font>  <font color="#008b8b">+#include &lt;asm/multiboot.h&gt;</font>
<font color="#a52a2a">  35</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">  36</font>   .text
<font color="#a52a2a">  37</font>   #include &lt;linux/config.h&gt;
<font color="#a52a2a">  38</font>   #include &lt;linux/threads.h&gt;
<font color="#a52a2a">  39</font>  <font color="#a52a2a"><b>@@ -45,12 +48,36 @@</b></font>
<font color="#a52a2a">  40</font>   /*
<font color="#a52a2a">  41</font>    * Set segments to known values
<font color="#a52a2a">  42</font>    */
<font color="#a52a2a">  43</font>  <font color="#6a5acd">-       cld</font>
<font color="#a52a2a">  44</font>          movl $(__KERNEL_DS),%eax
<font color="#a52a2a">  45</font>          movl %eax,%ds
<font color="#a52a2a">  46</font>          movl %eax,%es
<font color="#a52a2a">  47</font>          movl %eax,%fs
<font color="#a52a2a">  48</font>          movl %eax,%gs
<font color="#a52a2a">  49</font>  <font color="#008b8b">+       movl %eax,%ss</font>
<font color="#a52a2a">  50</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">  51</font>  <font color="#008b8b">+       jmp     real_startup_32</font>
<font color="#a52a2a">  52</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">  53</font>  <font color="#008b8b">+       /* Align 32 bits boundary.  */</font>
<font color="#a52a2a">  54</font>  <font color="#008b8b">+       .align  4</font>
<font color="#a52a2a">  55</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">  56</font>  <font color="#008b8b">+       /* Multiboot header.  */</font>
<font color="#a52a2a">  57</font>  <font color="#008b8b">+multiboot_header:</font>
<font color="#a52a2a">  58</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">  59</font>  <font color="#008b8b">+       /* magic */</font>
<font color="#a52a2a">  60</font>  <font color="#008b8b">+       .long   MULTIBOOT_HEADER_MAGIC</font>
<font color="#a52a2a">  61</font>  <font color="#008b8b">+       /* flags */</font>
<font color="#a52a2a">  62</font>  <font color="#008b8b">+       .long   MULTIBOOT_HEADER_FLAGS</font>
<font color="#a52a2a">  63</font>  <font color="#008b8b">+       /* checksum */</font>
<font color="#a52a2a">  64</font>  <font color="#008b8b">+       .long   -(MULTIBOOT_HEADER_MAGIC + MULTIBOOT_HEADER_FLAGS)</font>
<font color="#a52a2a">  65</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">  66</font>  <font color="#008b8b">+.globl SYMBOL_NAME(multiboot_entry)</font>
<font color="#a52a2a">  67</font>  <font color="#008b8b">+multiboot_entry:</font>
<font color="#a52a2a">  68</font>  <font color="#008b8b">+       movl %ebx,SYMBOL_NAME(mbootinfo) - __PAGE_OFFSET</font>
<font color="#a52a2a">  69</font>  <font color="#008b8b">+       xorl %ebx,%ebx</font>
<font color="#a52a2a">  70</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">  71</font>  <font color="#008b8b">+real_startup_32:</font>
<font color="#a52a2a">  72</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">  73</font>  <font color="#008b8b">+       cld</font>
<font color="#a52a2a">  74</font>   #ifdef CONFIG_SMP
<font color="#a52a2a">  75</font>          orw %bx,%bx
<font color="#a52a2a">  76</font>          jz 1f
<font color="#a52a2a">  77</font>  <font color="#a52a2a"><b>@@ -104,7 +131,7 @@</b></font>
<font color="#a52a2a">  78</font>          jmp *%eax               /* make sure eip is relocated */
<font color="#a52a2a">  79</font>   1:
<font color="#a52a2a">  80</font>          /* Set up the stack pointer */
<font color="#a52a2a">  81</font>  <font color="#6a5acd">-       lss stack_start,%esp</font>
<font color="#a52a2a">  82</font>  <font color="#008b8b">+       movl stack_start,%esp</font>
<font color="#a52a2a">  83</font>
<font color="#a52a2a">  84</font>   #ifdef CONFIG_SMP
<font color="#a52a2a">  85</font>          orw  %bx,%bx
<font color="#a52a2a">  86</font>  <font color="#a52a2a"><b>@@ -119,6 +146,10 @@</b></font>
<font color="#a52a2a">  87</font>    * Clear BSS first so that there are no surprises...
<font color="#a52a2a">  88</font>    * No need to cld as DF is already clear from cld above...
<font color="#a52a2a">  89</font>    */
<font color="#a52a2a">  90</font>  <font color="#008b8b">+       movl SYMBOL_NAME(mbootinfo),%eax</font>
<font color="#a52a2a">  91</font>  <font color="#008b8b">+       andl %eax,%eax</font>
<font color="#a52a2a">  92</font>  <font color="#008b8b">+       jnz 1f                  # We have a multiboot boot loader</font>
<font color="#a52a2a">  93</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">  94</font>          xorl %eax,%eax
<font color="#a52a2a">  95</font>          movl $ SYMBOL_NAME(__bss_start),%edi
<font color="#a52a2a">  96</font>          movl $ SYMBOL_NAME(_end),%ecx
<font color="#a52a2a">  97</font>  <font color="#a52a2a"><b>@@ -126,6 +157,8 @@</b></font>
<font color="#a52a2a">  98</font>          rep
<font color="#a52a2a">  99</font>          stosb
<font color="#a52a2a"> 100</font>
<font color="#a52a2a"> 101</font>  <font color="#008b8b">+1:</font>
<font color="#a52a2a"> 102</font>  <font color="#008b8b">+</font>
<font color="#a52a2a"> 103</font>   /*
<font color="#a52a2a"> 104</font>    * start system 32-bit setup. We need to re-do some of the things done
<font color="#a52a2a"> 105</font>    * in 16-bit mode for the &quot;real&quot; operations.
<font color="#a52a2a"> 106</font>  <font color="#a52a2a"><b>@@ -145,6 +178,10 @@</b></font>
<font color="#a52a2a"> 107</font>    *
<font color="#a52a2a"> 108</font>    * Note: %esi still has the pointer to the real-mode data.
<font color="#a52a2a"> 109</font>    */
<font color="#a52a2a"> 110</font>  <font color="#008b8b">+       movl SYMBOL_NAME(mbootinfo),%eax</font>
<font color="#a52a2a"> 111</font>  <font color="#008b8b">+       andl %eax,%eax</font>
<font color="#a52a2a"> 112</font>  <font color="#008b8b">+       jnz 1f                  # We have a multiboot boot loader</font>
<font color="#a52a2a"> 113</font>  <font color="#008b8b">+</font>
<font color="#a52a2a"> 114</font>          movl $ SYMBOL_NAME(empty_zero_page),%edi
<font color="#a52a2a"> 115</font>          movl $512,%ecx
<font color="#a52a2a"> 116</font>          cld
<font color="#a52a2a"> 117</font>  <font color="#a52a2a"><b>@@ -358,6 +395,7 @@</b></font>
<font color="#a52a2a"> 118</font>
<font color="#a52a2a"> 119</font>   .globl SYMBOL_NAME(idt)
<font color="#a52a2a"> 120</font>   .globl SYMBOL_NAME(gdt)
<font color="#a52a2a"> 121</font>  <font color="#008b8b">+.globl SYMBOL_NAME(mbootinfo)</font>
<font color="#a52a2a"> 122</font>
<font color="#a52a2a"> 123</font>          ALIGN
<font color="#a52a2a"> 124</font>          .word 0
<font color="#a52a2a"> 125</font>  <font color="#a52a2a"><b>@@ -371,6 +409,11 @@</b></font>
<font color="#a52a2a"> 126</font>          .word GDT_ENTRIES*8-1
<font color="#a52a2a"> 127</font>   SYMBOL_NAME(gdt):
<font color="#a52a2a"> 128</font>          .long SYMBOL_NAME(gdt_table)
<font color="#a52a2a"> 129</font>  <font color="#008b8b">+</font>
<font color="#a52a2a"> 130</font>  <font color="#008b8b">+       .word 0</font>
<font color="#a52a2a"> 131</font>  <font color="#008b8b">+</font>
<font color="#a52a2a"> 132</font>  <font color="#008b8b">+SYMBOL_NAME(mbootinfo):</font>
<font color="#a52a2a"> 133</font>  <font color="#008b8b">+       .long 0</font>
<font color="#a52a2a"> 134</font>
<font color="#a52a2a"> 135</font>   /*
<font color="#a52a2a"> 136</font>    * This is initialized to create an identity-mapping at 0-8M (for bootup
<font color="#a52a2a"> 137</font>  <font color="#2e8b57"><b>diff -urbN linux/arch/i386/kernel/obj_i386.c linux.new/arch/i386/kernel/obj_i386.c</b></font>
<font color="#a52a2a"> 138</font>  <font color="#2e8b57"><b>--- linux/arch/i386/kernel/obj_i386.c   Thu Jan  1 01:00:00 1970</b></font>
<font color="#a52a2a"> 139</font>  <font color="#2e8b57"><b>+++ linux.new/arch/i386/kernel/obj_i386.c       Wed Dec  5 23:24:04 2001</b></font>
<font color="#a52a2a"> 140</font>  <font color="#a52a2a"><b>@@ -0,0 +1,235 @@</b></font>
<font color="#a52a2a"> 141</font>  <font color="#008b8b">+/* i386 specific support for Elf loading and relocation.</font>
<font color="#a52a2a"> 142</font>  <font color="#008b8b">+   Copyright 1996, 1997 Linux International.</font>
<font color="#a52a2a"> 143</font>  <font color="#008b8b">+</font>
<font color="#a52a2a"> 144</font>  <font color="#008b8b">+   Contributed by Richard Henderson &lt;rth@tamu.edu&gt;</font>
<font color="#a52a2a"> 145</font>  <font color="#008b8b">+</font>
<font color="#a52a2a"> 146</font>  <font color="#008b8b">+   This file is part of the Linux modutils.</font>
<font color="#a52a2a"> 147</font>  <font color="#008b8b">+</font>
<font color="#a52a2a"> 148</font>  <font color="#008b8b">+   This program is free software; you can redistribute it and/or modify it</font>
<font color="#a52a2a"> 149</font>  <font color="#008b8b">+   under the terms of the GNU General Public License as published by the</font>
<font color="#a52a2a"> 150</font>  <font color="#008b8b">+   Free Software Foundation; either version 2 of the License, or (at your</font>
<font color="#a52a2a"> 151</font>  <font color="#008b8b">+   option) any later version.</font>
<font color="#a52a2a"> 152</font>  <font color="#008b8b">+</font>
<font color="#a52a2a"> 153</font>  <font color="#008b8b">+   This program is distributed in the hope that it will be useful, but</font>
<font color="#a52a2a"> 154</font>  <font color="#008b8b">+   WITHOUT ANY WARRANTY; without even the implied warranty of</font>
<font color="#a52a2a"> 155</font>  <font color="#008b8b">+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</font>
<font color="#a52a2a"> 156</font>  <font color="#008b8b">+   General Public License for more details.</font>
<font color="#a52a2a"> 157</font>  <font color="#008b8b">+</font>
<font color="#a52a2a"> 158</font>  <font color="#008b8b">+   You should have received a copy of the GNU General Public License</font>
<font color="#a52a2a"> 159</font>  <font color="#008b8b">+   along with this program; if not, write to the Free Software Foundation,</font>
<font color="#a52a2a"> 160</font>  <font color="#008b8b">+   Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */</font>
<font color="#a52a2a"> 161</font>  <font color="#008b8b">+</font>
<font color="#a52a2a"> 162</font>  <font color="#008b8b">+#ident &quot;$Id: obj_i386.c 1.3 Wed, 26 Sep 2001 14:50:45 +1000 kaos $&quot;</font>
<font color="#a52a2a"> 163</font>  <font color="#008b8b">+</font>
<font color="#a52a2a"> 164</font>  <font color="#008b8b">+#include &lt;linux/slab.h&gt;</font>
<font color="#a52a2a"> 165</font>  <font color="#008b8b">+#include &lt;linux/obj_load.h&gt;</font>
<font color="#a52a2a"> 166</font>  <font color="#008b8b">+</font>
<font color="#a52a2a"> 167</font>  <font color="#008b8b">+</font>
<font color="#a52a2a"> 168</font>  <font color="#008b8b">+/*======================================================================*/</font>
<font color="#a52a2a"> 169</font>  <font color="#008b8b">+</font>
<font color="#a52a2a"> 170</font>  <font color="#008b8b">+struct i386_got_entry</font>
<font color="#a52a2a"> 171</font>  <font color="#008b8b">+{</font>
<font color="#a52a2a"> 172</font>  <font color="#008b8b">+  int offset;</font>
<font color="#a52a2a"> 173</font>  <font color="#008b8b">+  unsigned offset_done : 1;</font>
<font color="#a52a2a"> 174</font>  <font color="#008b8b">+  unsigned reloc_done : 1;</font>
<font color="#a52a2a"> 175</font>  <font color="#008b8b">+};</font>
<font color="#a52a2a"> 176</font>  <font color="#008b8b">+</font>
<font color="#a52a2a"> 177</font>  <font color="#008b8b">+struct i386_file</font>
<font color="#a52a2a"> 178</font>  <font color="#008b8b">+{</font>
<font color="#a52a2a"> 179</font>  <font color="#008b8b">+  struct obj_file root;</font>
<font color="#a52a2a"> 180</font>  <font color="#008b8b">+  struct obj_section *got;</font>
<font color="#a52a2a"> 181</font>  <font color="#008b8b">+};</font>
<font color="#a52a2a"> 182</font>  <font color="#008b8b">+</font>
<font color="#a52a2a"> 183</font>  <font color="#008b8b">+struct i386_symbol</font>
<font color="#a52a2a"> 184</font>  <font color="#008b8b">+{</font>
<font color="#a52a2a"> 185</font>  <font color="#008b8b">+  struct obj_symbol root;</font>
<font color="#a52a2a"> 186</font>  <font color="#008b8b">+  struct i386_got_entry gotent;</font>
<font color="#a52a2a"> 187</font>  <font color="#008b8b">+};</font>
<font color="#a52a2a"> 188</font>  <font color="#008b8b">+</font>
<font color="#a52a2a"> 189</font>  <font color="#008b8b">+</font>
<font color="#a52a2a"> 190</font>  <font color="#008b8b">+/*======================================================================*/</font>
<font color="#a52a2a"> 191</font>  <font color="#008b8b">+</font>
<font color="#a52a2a"> 192</font>  <font color="#008b8b">+struct obj_file *</font>
<font color="#a52a2a"> 193</font>  <font color="#008b8b">+arch_new_file (void)</font>
<font color="#a52a2a"> 194</font>  <font color="#008b8b">+{</font>
<font color="#a52a2a"> 195</font>  <font color="#008b8b">+  struct i386_file *f;</font>
<font color="#a52a2a"> 196</font>  <font color="#008b8b">+  f = kmalloc(sizeof(*f), GFP_KERNEL);</font>
<font color="#a52a2a"> 197</font>  <font color="#008b8b">+  f-&gt;got = NULL;</font>
<font color="#a52a2a"> 198</font>  <font color="#008b8b">+  return &amp;f-&gt;root;</font>
<font color="#a52a2a"> 199</font>  <font color="#008b8b">+}</font>
<font color="#a52a2a"> 200</font>  <font color="#008b8b">+</font>
<font color="#a52a2a"> 201</font>  <font color="#008b8b">+struct obj_section *</font>
<font color="#a52a2a"> 202</font>  <font color="#008b8b">+arch_new_section (void)</font>
<font color="#a52a2a"> 203</font>  <font color="#008b8b">+{</font>
<font color="#a52a2a"> 204</font>  <font color="#008b8b">+  return kmalloc(sizeof(struct obj_section), GFP_KERNEL);</font>
<font color="#a52a2a"> 205</font>  <font color="#008b8b">+}</font>
<font color="#a52a2a"> 206</font>  <font color="#008b8b">+</font>
<font color="#a52a2a"> 207</font>  <font color="#008b8b">+struct obj_symbol *</font>
<font color="#a52a2a"> 208</font>  <font color="#008b8b">+arch_new_symbol (void)</font>
<font color="#a52a2a"> 209</font>  <font color="#008b8b">+{</font>
<font color="#a52a2a"> 210</font>  <font color="#008b8b">+  struct i386_symbol *sym;</font>
<font color="#a52a2a"> 211</font>  <font color="#008b8b">+  sym = kmalloc(sizeof(*sym), GFP_KERNEL);</font>
<font color="#a52a2a"> 212</font>  <font color="#008b8b">+  memset(&amp;sym-&gt;gotent, 0, sizeof(sym-&gt;gotent));</font>
<font color="#a52a2a"> 213</font>  <font color="#008b8b">+  return &amp;sym-&gt;root;</font>
<font color="#a52a2a"> 214</font>  <font color="#008b8b">+}</font>
<font color="#a52a2a"> 215</font>  <font color="#008b8b">+</font>
<font color="#a52a2a"> 216</font>  <font color="#008b8b">+int</font>
<font color="#a52a2a"> 217</font>  <font color="#008b8b">+arch_load_proc_section(struct obj_section *sec, int fp)</font>
<font color="#a52a2a"> 218</font>  <font color="#008b8b">+{</font>
<font color="#a52a2a"> 219</font>  <font color="#008b8b">+    /* Assume it's just a debugging section that we can safely</font>
<font color="#a52a2a"> 220</font>  <font color="#008b8b">+       ignore ...  */</font>
<font color="#a52a2a"> 221</font>  <font color="#008b8b">+    sec-&gt;contents = NULL;</font>
<font color="#a52a2a"> 222</font>  <font color="#008b8b">+</font>
<font color="#a52a2a"> 223</font>  <font color="#008b8b">+    return 0;</font>
<font color="#a52a2a"> 224</font>  <font color="#008b8b">+}</font>
<font color="#a52a2a"> 225</font>  <font color="#008b8b">+</font>
<font color="#a52a2a"> 226</font>  <font color="#008b8b">+enum obj_reloc</font>
<font color="#a52a2a"> 227</font>  <font color="#008b8b">+arch_apply_relocation (struct obj_file *f,</font>
<font color="#a52a2a"> 228</font>  <font color="#008b8b">+                      struct obj_section *targsec,</font>
<font color="#a52a2a"> 229</font>  <font color="#008b8b">+                      struct obj_section *symsec,</font>
<font color="#a52a2a"> 230</font>  <font color="#008b8b">+                      struct obj_symbol *sym,</font>
<font color="#a52a2a"> 231</font>  <font color="#008b8b">+                      Elf32_Rel *rel,</font>
<font color="#a52a2a"> 232</font>  <font color="#008b8b">+                      Elf32_Addr v)</font>
<font color="#a52a2a"> 233</font>  <font color="#008b8b">+{</font>
<font color="#a52a2a"> 234</font>  <font color="#008b8b">+  struct i386_file *ifile = (struct i386_file *)f;</font>
<font color="#a52a2a"> 235</font>  <font color="#008b8b">+  struct i386_symbol *isym  = (struct i386_symbol *)sym;</font>
<font color="#a52a2a"> 236</font>  <font color="#008b8b">+</font>
<font color="#a52a2a"> 237</font>  <font color="#008b8b">+  Elf32_Addr *loc = (Elf32_Addr *)(targsec-&gt;contents + rel-&gt;r_offset);</font>
<font color="#a52a2a"> 238</font>  <font color="#008b8b">+  Elf32_Addr dot = targsec-&gt;header.sh_addr + rel-&gt;r_offset;</font>
<font color="#a52a2a"> 239</font>  <font color="#008b8b">+  Elf32_Addr got = ifile-&gt;got ? ifile-&gt;got-&gt;header.sh_addr : 0;</font>
<font color="#a52a2a"> 240</font>  <font color="#008b8b">+</font>
<font color="#a52a2a"> 241</font>  <font color="#008b8b">+  enum obj_reloc ret = obj_reloc_ok;</font>
<font color="#a52a2a"> 242</font>  <font color="#008b8b">+</font>
<font color="#a52a2a"> 243</font>  <font color="#008b8b">+  switch (ELF32_R_TYPE(rel-&gt;r_info))</font>
<font color="#a52a2a"> 244</font>  <font color="#008b8b">+    {</font>
<font color="#a52a2a"> 245</font>  <font color="#008b8b">+    case R_386_NONE:</font>
<font color="#a52a2a"> 246</font>  <font color="#008b8b">+      break;</font>
<font color="#a52a2a"> 247</font>  <font color="#008b8b">+</font>
<font color="#a52a2a"> 248</font>  <font color="#008b8b">+    case R_386_32:</font>
<font color="#a52a2a"> 249</font>  <font color="#008b8b">+      *loc += v;</font>
<font color="#a52a2a"> 250</font>  <font color="#008b8b">+      break;</font>
<font color="#a52a2a"> 251</font>  <font color="#008b8b">+</font>
<font color="#a52a2a"> 252</font>  <font color="#008b8b">+    case R_386_PLT32:</font>
<font color="#a52a2a"> 253</font>  <font color="#008b8b">+    case R_386_PC32:</font>
<font color="#a52a2a"> 254</font>  <font color="#008b8b">+      *loc += v - dot;</font>
<font color="#a52a2a"> 255</font>  <font color="#008b8b">+      break;</font>
<font color="#a52a2a"> 256</font>  <font color="#008b8b">+</font>
<font color="#a52a2a"> 257</font>  <font color="#008b8b">+    case R_386_GLOB_DAT:</font>
<font color="#a52a2a"> 258</font>  <font color="#008b8b">+    case R_386_JMP_SLOT:</font>
<font color="#a52a2a"> 259</font>  <font color="#008b8b">+      *loc = v;</font>
<font color="#a52a2a"> 260</font>  <font color="#008b8b">+      break;</font>
<font color="#a52a2a"> 261</font>  <font color="#008b8b">+</font>
<font color="#a52a2a"> 262</font>  <font color="#008b8b">+    case R_386_RELATIVE:</font>
<font color="#a52a2a"> 263</font>  <font color="#008b8b">+      *loc += f-&gt;baseaddr;</font>
<font color="#a52a2a"> 264</font>  <font color="#008b8b">+      break;</font>
<font color="#a52a2a"> 265</font>  <font color="#008b8b">+</font>
<font color="#a52a2a"> 266</font>  <font color="#008b8b">+    case R_386_GOTPC:</font>
<font color="#a52a2a"> 267</font>  <font color="#008b8b">+//      assert(got != 0);</font>
<font color="#a52a2a"> 268</font>  <font color="#008b8b">+      *loc += got - dot;</font>
<font color="#a52a2a"> 269</font>  <font color="#008b8b">+      break;</font>
<font color="#a52a2a"> 270</font>  <font color="#008b8b">+</font>
<font color="#a52a2a"> 271</font>  <font color="#008b8b">+    case R_386_GOT32:</font>
<font color="#a52a2a"> 272</font>  <font color="#008b8b">+//      assert(isym != NULL);</font>
<font color="#a52a2a"> 273</font>  <font color="#008b8b">+      if (!isym-&gt;gotent.reloc_done)</font>
<font color="#a52a2a"> 274</font>  <font color="#008b8b">+       {</font>
<font color="#a52a2a"> 275</font>  <font color="#008b8b">+         isym-&gt;gotent.reloc_done = 1;</font>
<font color="#a52a2a"> 276</font>  <font color="#008b8b">+         *(Elf32_Addr *)(ifile-&gt;got-&gt;contents + isym-&gt;gotent.offset) = v;</font>
<font color="#a52a2a"> 277</font>  <font color="#008b8b">+       }</font>
<font color="#a52a2a"> 278</font>  <font color="#008b8b">+      *loc += isym-&gt;gotent.offset;</font>
<font color="#a52a2a"> 279</font>  <font color="#008b8b">+      break;</font>
<font color="#a52a2a"> 280</font>  <font color="#008b8b">+</font>
<font color="#a52a2a"> 281</font>  <font color="#008b8b">+    case R_386_GOTOFF:</font>
<font color="#a52a2a"> 282</font>  <font color="#008b8b">+//      assert(got != 0);</font>
<font color="#a52a2a"> 283</font>  <font color="#008b8b">+      *loc += v - got;</font>
<font color="#a52a2a"> 284</font>  <font color="#008b8b">+      break;</font>
<font color="#a52a2a"> 285</font>  <font color="#008b8b">+</font>
<font color="#a52a2a"> 286</font>  <font color="#008b8b">+    default:</font>
<font color="#a52a2a"> 287</font>  <font color="#008b8b">+      ret = obj_reloc_unhandled;</font>
<font color="#a52a2a"> 288</font>  <font color="#008b8b">+      break;</font>
<font color="#a52a2a"> 289</font>  <font color="#008b8b">+    }</font>
<font color="#a52a2a"> 290</font>  <font color="#008b8b">+</font>
<font color="#a52a2a"> 291</font>  <font color="#008b8b">+  return ret;</font>
<font color="#a52a2a"> 292</font>  <font color="#008b8b">+}</font>
<font color="#a52a2a"> 293</font>  <font color="#008b8b">+</font>
<font color="#a52a2a"> 294</font>  <font color="#008b8b">+int</font>
<font color="#a52a2a"> 295</font>  <font color="#008b8b">+arch_create_got (struct obj_file *f)</font>
<font color="#a52a2a"> 296</font>  <font color="#008b8b">+{</font>
<font color="#a52a2a"> 297</font>  <font color="#008b8b">+  struct i386_file *ifile = (struct i386_file *)f;</font>
<font color="#a52a2a"> 298</font>  <font color="#008b8b">+  int i, n, offset = 0, gotneeded = 0;</font>
<font color="#a52a2a"> 299</font>  <font color="#008b8b">+</font>
<font color="#a52a2a"> 300</font>  <font color="#008b8b">+  n = ifile-&gt;root.header.e_shnum;</font>
<font color="#a52a2a"> 301</font>  <font color="#008b8b">+  for (i = 0; i &lt; n; ++i)</font>
<font color="#a52a2a"> 302</font>  <font color="#008b8b">+    {</font>
<font color="#a52a2a"> 303</font>  <font color="#008b8b">+      struct obj_section *relsec, *symsec, *strsec;</font>
<font color="#a52a2a"> 304</font>  <font color="#008b8b">+      Elf32_Rel *rel, *relend;</font>
<font color="#a52a2a"> 305</font>  <font color="#008b8b">+      Elf32_Sym *symtab;</font>
<font color="#a52a2a"> 306</font>  <font color="#008b8b">+      const char *strtab;</font>
<font color="#a52a2a"> 307</font>  <font color="#008b8b">+</font>
<font color="#a52a2a"> 308</font>  <font color="#008b8b">+      relsec = ifile-&gt;root.sections[i];</font>
<font color="#a52a2a"> 309</font>  <font color="#008b8b">+      if (relsec-&gt;header.sh_type != SHT_REL)</font>
<font color="#a52a2a"> 310</font>  <font color="#008b8b">+       continue;</font>
<font color="#a52a2a"> 311</font>  <font color="#008b8b">+</font>
<font color="#a52a2a"> 312</font>  <font color="#008b8b">+      symsec = ifile-&gt;root.sections[relsec-&gt;header.sh_link];</font>
<font color="#a52a2a"> 313</font>  <font color="#008b8b">+      strsec = ifile-&gt;root.sections[symsec-&gt;header.sh_link];</font>
<font color="#a52a2a"> 314</font>  <font color="#008b8b">+</font>
<font color="#a52a2a"> 315</font>  <font color="#008b8b">+      rel = (Elf32_Rel *)relsec-&gt;contents;</font>
<font color="#a52a2a"> 316</font>  <font color="#008b8b">+      relend = rel + (relsec-&gt;header.sh_size / sizeof(Elf32_Rel));</font>
<font color="#a52a2a"> 317</font>  <font color="#008b8b">+      symtab = (Elf32_Sym *)symsec-&gt;contents;</font>
<font color="#a52a2a"> 318</font>  <font color="#008b8b">+      strtab = (const char *)strsec-&gt;contents;</font>
<font color="#a52a2a"> 319</font>  <font color="#008b8b">+</font>
<font color="#a52a2a"> 320</font>  <font color="#008b8b">+      for (; rel &lt; relend; ++rel)</font>
<font color="#a52a2a"> 321</font>  <font color="#008b8b">+       {</font>
<font color="#a52a2a"> 322</font>  <font color="#008b8b">+         struct i386_symbol *intsym;</font>
<font color="#a52a2a"> 323</font>  <font color="#008b8b">+</font>
<font color="#a52a2a"> 324</font>  <font color="#008b8b">+         switch (ELF32_R_TYPE(rel-&gt;r_info))</font>
<font color="#a52a2a"> 325</font>  <font color="#008b8b">+           {</font>
<font color="#a52a2a"> 326</font>  <font color="#008b8b">+           case R_386_GOTPC:</font>
<font color="#a52a2a"> 327</font>  <font color="#008b8b">+           case R_386_GOTOFF:</font>
<font color="#a52a2a"> 328</font>  <font color="#008b8b">+             gotneeded = 1;</font>
<font color="#a52a2a"> 329</font>  <font color="#008b8b">+           default:</font>
<font color="#a52a2a"> 330</font>  <font color="#008b8b">+             continue;</font>
<font color="#a52a2a"> 331</font>  <font color="#008b8b">+</font>
<font color="#a52a2a"> 332</font>  <font color="#008b8b">+           case R_386_GOT32:</font>
<font color="#a52a2a"> 333</font>  <font color="#008b8b">+             break;</font>
<font color="#a52a2a"> 334</font>  <font color="#008b8b">+           }</font>
<font color="#a52a2a"> 335</font>  <font color="#008b8b">+</font>
<font color="#a52a2a"> 336</font>  <font color="#008b8b">+         obj_find_relsym(intsym, f, &amp;ifile-&gt;root, rel, symtab, strtab);</font>
<font color="#a52a2a"> 337</font>  <font color="#008b8b">+</font>
<font color="#a52a2a"> 338</font>  <font color="#008b8b">+         if (!intsym-&gt;gotent.offset_done)</font>
<font color="#a52a2a"> 339</font>  <font color="#008b8b">+           {</font>
<font color="#a52a2a"> 340</font>  <font color="#008b8b">+             intsym-&gt;gotent.offset_done = 1;</font>
<font color="#a52a2a"> 341</font>  <font color="#008b8b">+             intsym-&gt;gotent.offset = offset;</font>
<font color="#a52a2a"> 342</font>  <font color="#008b8b">+             offset += 4;</font>
<font color="#a52a2a"> 343</font>  <font color="#008b8b">+           }</font>
<font color="#a52a2a"> 344</font>  <font color="#008b8b">+       }</font>
<font color="#a52a2a"> 345</font>  <font color="#008b8b">+    }</font>
<font color="#a52a2a"> 346</font>  <font color="#008b8b">+</font>
<font color="#a52a2a"> 347</font>  <font color="#008b8b">+  if (offset &gt; 0 || gotneeded)</font>
<font color="#a52a2a"> 348</font>  <font color="#008b8b">+    ifile-&gt;got = obj_create_alloced_section(&amp;ifile-&gt;root, &quot;.got&quot;, 4, offset,</font>
<font color="#a52a2a"> 349</font>  <font color="#008b8b">+                                           SHF_WRITE);</font>
<font color="#a52a2a"> 350</font>  <font color="#008b8b">+</font>
<font color="#a52a2a"> 351</font>  <font color="#008b8b">+  return 1;</font>
<font color="#a52a2a"> 352</font>  <font color="#008b8b">+}</font>
<font color="#a52a2a"> 353</font>  <font color="#008b8b">+</font>
<font color="#a52a2a"> 354</font>  <font color="#008b8b">+int</font>
<font color="#a52a2a"> 355</font>  <font color="#008b8b">+arch_init_module (struct obj_file *f, struct module *mod)</font>
<font color="#a52a2a"> 356</font>  <font color="#008b8b">+{</font>
<font color="#a52a2a"> 357</font>  <font color="#008b8b">+  return 1;</font>
<font color="#a52a2a"> 358</font>  <font color="#008b8b">+}</font>
<font color="#a52a2a"> 359</font>  <font color="#008b8b">+</font>
<font color="#a52a2a"> 360</font>  <font color="#008b8b">+int</font>
<font color="#a52a2a"> 361</font>  <font color="#008b8b">+arch_finalize_section_address(struct obj_file *f, Elf32_Addr base)</font>
<font color="#a52a2a"> 362</font>  <font color="#008b8b">+{</font>
<font color="#a52a2a"> 363</font>  <font color="#008b8b">+  int  i, n = f-&gt;header.e_shnum;</font>
<font color="#a52a2a"> 364</font>  <font color="#008b8b">+</font>
<font color="#a52a2a"> 365</font>  <font color="#008b8b">+  f-&gt;baseaddr = base;</font>
<font color="#a52a2a"> 366</font>  <font color="#008b8b">+  for (i = 0; i &lt; n; ++i)</font>
<font color="#a52a2a"> 367</font>  <font color="#008b8b">+    f-&gt;sections[i]-&gt;header.sh_addr += base;</font>
<font color="#a52a2a"> 368</font>  <font color="#008b8b">+  return 1;</font>
<font color="#a52a2a"> 369</font>  <font color="#008b8b">+}</font>
<font color="#a52a2a"> 370</font>  <font color="#008b8b">+</font>
<font color="#a52a2a"> 371</font>  <font color="#008b8b">+int</font>
<font color="#a52a2a"> 372</font>  <font color="#008b8b">+arch_archdata (struct obj_file *fin, struct obj_section *sec)</font>
<font color="#a52a2a"> 373</font>  <font color="#008b8b">+{</font>
<font color="#a52a2a"> 374</font>  <font color="#008b8b">+  return 0;</font>
<font color="#a52a2a"> 375</font>  <font color="#008b8b">+}</font>
<font color="#a52a2a"> 376</font>  <font color="#2e8b57"><b>diff -urbN linux/arch/i386/kernel/setup.c linux.new/arch/i386/kernel/setup.c</b></font>
<font color="#a52a2a"> 377</font>  <font color="#2e8b57"><b>--- linux/arch/i386/kernel/setup.c      Thu Oct 25 22:53:46 2001</b></font>
<font color="#a52a2a"> 378</font>  <font color="#2e8b57"><b>+++ linux.new/arch/i386/kernel/setup.c  Thu Dec  6 17:54:03 2001</b></font>
<font color="#a52a2a"> 379</font>  <font color="#a52a2a"><b>@@ -108,6 +108,8 @@</b></font>
<font color="#a52a2a"> 380</font>   #include &lt;asm/dma.h&gt;
<font color="#a52a2a"> 381</font>   #include &lt;asm/mpspec.h&gt;
<font color="#a52a2a"> 382</font>   #include &lt;asm/mmu_context.h&gt;
<font color="#a52a2a"> 383</font>  <font color="#008b8b">+#include &lt;asm/multiboot.h&gt;</font>
<font color="#a52a2a"> 384</font>  <font color="#008b8b">+</font>
<font color="#a52a2a"> 385</font>   /*
<font color="#a52a2a"> 386</font>    * Machine setup..
<font color="#a52a2a"> 387</font>    */
<font color="#a52a2a"> 388</font>  <font color="#a52a2a"><b>@@ -156,6 +158,11 @@</b></font>
<font color="#a52a2a"> 389</font>   static int disable_x86_serial_nr __initdata = 1;
<font color="#a52a2a"> 390</font>   static int disable_x86_fxsr __initdata = 0;
<font color="#a52a2a"> 391</font>
<font color="#a52a2a"> 392</font>  <font color="#008b8b">+unsigned long mboot_mem_start;</font>
<font color="#a52a2a"> 393</font>  <font color="#008b8b">+unsigned long mboot_mem_end;</font>
<font color="#a52a2a"> 394</font>  <font color="#008b8b">+unsigned long mboot_module_start;</font>
<font color="#a52a2a"> 395</font>  <font color="#008b8b">+unsigned long mboot_module_end;</font>
<font color="#a52a2a"> 396</font>  <font color="#008b8b">+</font>
<font color="#a52a2a"> 397</font>   /*
<font color="#a52a2a"> 398</font>    * This is set up by the setup-routine at boot-time
<font color="#a52a2a"> 399</font>    */
<font color="#a52a2a"> 400</font>  <font color="#a52a2a"><b>@@ -661,6 +668,28 @@</b></font>
<font color="#a52a2a"> 401</font>   }
<font color="#a52a2a"> 402</font>
<font color="#a52a2a"> 403</font>   /*
<font color="#a52a2a"> 404</font>  <font color="#008b8b">+ * Converts the Multiboot Mem-Map into a e820 one.</font>
<font color="#a52a2a"> 405</font>  <font color="#008b8b">+ */</font>
<font color="#a52a2a"> 406</font>  <font color="#008b8b">+static int __init mboot_2_e820_map(struct e820entry * biosmap, int nr_map)</font>
<font color="#a52a2a"> 407</font>  <font color="#008b8b">+{</font>
<font color="#a52a2a"> 408</font>  <font color="#008b8b">+       struct multiboot_memory_map *addr;</font>
<font color="#a52a2a"> 409</font>  <font color="#008b8b">+       addr = (struct multiboot_memory_map *)mbootinfo-&gt;mmap_addr;</font>
<font color="#a52a2a"> 410</font>  <font color="#008b8b">+</font>
<font color="#a52a2a"> 411</font>  <font color="#008b8b">+       while((char *)addr &lt; (mbootinfo-&gt;mmap_addr + mbootinfo-&gt;mmap_length)) {</font>
<font color="#a52a2a"> 412</font>  <font color="#008b8b">+</font>
<font color="#a52a2a"> 413</font>  <font color="#008b8b">+               biosmap[nr_map].addr = addr-&gt;base_addr_low + ((unsigned long long)addr-&gt;base_addr_high &lt;&lt; 32);</font>
<font color="#a52a2a"> 414</font>  <font color="#008b8b">+               biosmap[nr_map].size = addr-&gt;length_low + ((unsigned long long)addr-&gt;length_high &lt;&lt; 32);</font>
<font color="#a52a2a"> 415</font>  <font color="#008b8b">+               biosmap[nr_map].type = addr-&gt;type;</font>
<font color="#a52a2a"> 416</font>  <font color="#008b8b">+</font>
<font color="#a52a2a"> 417</font>  <font color="#008b8b">+               addr = (struct multiboot_memory_map *)</font>
<font color="#a52a2a"> 418</font>  <font color="#008b8b">+                       ((char *)addr + addr-&gt;size + sizeof (addr-&gt;size));</font>
<font color="#a52a2a"> 419</font>  <font color="#008b8b">+               nr_map++;</font>
<font color="#a52a2a"> 420</font>  <font color="#008b8b">+       }</font>
<font color="#a52a2a"> 421</font>  <font color="#008b8b">+</font>
<font color="#a52a2a"> 422</font>  <font color="#008b8b">+       return nr_map;</font>
<font color="#a52a2a"> 423</font>  <font color="#008b8b">+}</font>
<font color="#a52a2a"> 424</font>  <font color="#008b8b">+</font>
<font color="#a52a2a"> 425</font>  <font color="#008b8b">+/*</font>
<font color="#a52a2a"> 426</font>    * Do NOT EVER look at the BIOS memory size location.
<font color="#a52a2a"> 427</font>    * It does not work on many machines.
<font color="#a52a2a"> 428</font>    */
<font color="#a52a2a"> 429</font>  <font color="#a52a2a"><b>@@ -676,10 +705,18 @@</b></font>
<font color="#a52a2a"> 430</font>           * Otherwise fake a memory map; one section from 0k-&gt;640k,
<font color="#a52a2a"> 431</font>           * the next section from 1mb-&gt;appropriate_mem_k
<font color="#a52a2a"> 432</font>           */
<font color="#a52a2a"> 433</font>  <font color="#008b8b">+       if (mbootinfo &amp;&amp; (mbootinfo-&gt;flags &amp; MBOOTINFO_HAVE_MEMMAP))</font>
<font color="#a52a2a"> 434</font>  <font color="#008b8b">+               E820_MAP_NR = mboot_2_e820_map(E820_MAP, E820_MAP_NR);</font>
<font color="#a52a2a"> 435</font>          sanitize_e820_map(E820_MAP, &amp;E820_MAP_NR);
<font color="#a52a2a"> 436</font>          if (copy_e820_map(E820_MAP, E820_MAP_NR) &lt; 0) {
<font color="#a52a2a"> 437</font>                  unsigned long mem_size;
<font color="#a52a2a"> 438</font>
<font color="#a52a2a"> 439</font>  <font color="#008b8b">+               if (mbootinfo) {</font>
<font color="#a52a2a"> 440</font>  <font color="#008b8b">+                       who = &quot;Multiboot-Loader:&quot;;</font>
<font color="#a52a2a"> 441</font>  <font color="#008b8b">+                       e820.nr_map = 0;</font>
<font color="#a52a2a"> 442</font>  <font color="#008b8b">+                       add_memory_region(0, mbootinfo-&gt;mem_lower &lt;&lt; 10, E820_RAM);</font>
<font color="#a52a2a"> 443</font>  <font color="#008b8b">+                       add_memory_region(HIGH_MEMORY, mbootinfo-&gt;mem_upper &lt;&lt; 10, E820_RAM);</font>
<font color="#a52a2a"> 444</font>  <font color="#008b8b">+               } else {</font>
<font color="#a52a2a"> 445</font>                  /* compare results from other methods and take the greater */
<font color="#a52a2a"> 446</font>                  if (ALT_MEM_K &lt; EXT_MEM_K) {
<font color="#a52a2a"> 447</font>                          mem_size = EXT_MEM_K;
<font color="#a52a2a"> 448</font>  <font color="#a52a2a"><b>@@ -693,6 +730,7 @@</b></font>
<font color="#a52a2a"> 449</font>                  add_memory_region(0, LOWMEMSIZE(), E820_RAM);
<font color="#a52a2a"> 450</font>                  add_memory_region(HIGH_MEMORY, mem_size &lt;&lt; 10, E820_RAM);
<font color="#a52a2a"> 451</font>          }
<font color="#a52a2a"> 452</font>  <font color="#008b8b">+       }</font>
<font color="#a52a2a"> 453</font>          printk(KERN_INFO &quot;BIOS-provided physical RAM map:\n&quot;);
<font color="#a52a2a"> 454</font>          print_memory_map(who);
<font color="#a52a2a"> 455</font>   } /* setup_memory_region */
<font color="#a52a2a"> 456</font>  <font color="#a52a2a"><b>@@ -704,8 +742,11 @@</b></font>
<font color="#a52a2a"> 457</font>          int len = 0;
<font color="#a52a2a"> 458</font>          int usermem = 0;
<font color="#a52a2a"> 459</font>
<font color="#a52a2a"> 460</font>  <font color="#008b8b">+       if ((mbootinfo) &amp;&amp; (mbootinfo-&gt;flags &amp; MBOOTINFO_HAVE_CMDLINE))</font>
<font color="#a52a2a"> 461</font>  <font color="#008b8b">+               from = mbootinfo-&gt;cmdline;</font>
<font color="#a52a2a"> 462</font>  <font color="#008b8b">+</font>
<font color="#a52a2a"> 463</font>          /* Save unparsed command line copy for /proc/cmdline */
<font color="#a52a2a"> 464</font>  <font color="#6a5acd">-       memcpy(saved_command_line, COMMAND_LINE, COMMAND_LINE_SIZE);</font>
<font color="#a52a2a"> 465</font>  <font color="#008b8b">+       memcpy(saved_command_line, from, COMMAND_LINE_SIZE);</font>
<font color="#a52a2a"> 466</font>          saved_command_line[COMMAND_LINE_SIZE-1] = '\0';
<font color="#a52a2a"> 467</font>
<font color="#a52a2a"> 468</font>          for (;;) {
<font color="#a52a2a"> 469</font>  <font color="#a52a2a"><b>@@ -768,6 +809,86 @@</b></font>
<font color="#a52a2a"> 470</font>          }
<font color="#a52a2a"> 471</font>   }
<font color="#a52a2a"> 472</font>
<font color="#a52a2a"> 473</font>  <font color="#008b8b">+#define INFBOUND(a,b)  if (b &gt; a) a = b</font>
<font color="#a52a2a"> 474</font>  <font color="#008b8b">+#define SUPBOUND(a,b)  if (b &lt; a) a = b</font>
<font color="#a52a2a"> 475</font>  <font color="#008b8b">+</font>
<font color="#a52a2a"> 476</font>  <font color="#008b8b">+</font>
<font color="#a52a2a"> 477</font>  <font color="#008b8b">+unsigned long get_bootmembitmap_addr(void)</font>
<font color="#a52a2a"> 478</font>  <font color="#008b8b">+{</font>
<font color="#a52a2a"> 479</font>  <font color="#008b8b">+       unsigned long start_pfn = __pa(&amp;_end);</font>
<font color="#a52a2a"> 480</font>  <font color="#008b8b">+</font>
<font color="#a52a2a"> 481</font>  <font color="#008b8b">+#ifdef CONFIG_MODULES</font>
<font color="#a52a2a"> 482</font>  <font color="#008b8b">+</font>
<font color="#a52a2a"> 483</font>  <font color="#008b8b">+       if ((mbootinfo) &amp;&amp; (mbootinfo-&gt;flags &amp; MBOOTINFO_HAVE_MODULE)) {</font>
<font color="#a52a2a"> 484</font>  <font color="#008b8b">+               int i;</font>
<font color="#a52a2a"> 485</font>  <font color="#008b8b">+               struct multiboot_module *addr = mbootinfo-&gt;mods_addr;</font>
<font color="#a52a2a"> 486</font>  <font color="#008b8b">+</font>
<font color="#a52a2a"> 487</font>  <font color="#008b8b">+               mboot_module_start = 0xFFFFFFFF;</font>
<font color="#a52a2a"> 488</font>  <font color="#008b8b">+               mboot_module_end = 0;</font>
<font color="#a52a2a"> 489</font>  <font color="#008b8b">+</font>
<font color="#a52a2a"> 490</font>  <font color="#008b8b">+               for(i=0;i&lt;mbootinfo-&gt;mods_count;i++) {</font>
<font color="#a52a2a"> 491</font>  <font color="#008b8b">+                       INFBOUND(start_pfn,addr[i].mod_end);</font>
<font color="#a52a2a"> 492</font>  <font color="#008b8b">+</font>
<font color="#a52a2a"> 493</font>  <font color="#008b8b">+                       addr[i].mod_start += __PAGE_OFFSET;</font>
<font color="#a52a2a"> 494</font>  <font color="#008b8b">+                       addr[i].mod_end += __PAGE_OFFSET;</font>
<font color="#a52a2a"> 495</font>  <font color="#008b8b">+</font>
<font color="#a52a2a"> 496</font>  <font color="#008b8b">+                       SUPBOUND(mboot_module_start,addr[i].mod_start);</font>
<font color="#a52a2a"> 497</font>  <font color="#008b8b">+                       INFBOUND(mboot_module_end,addr[i].mod_end);</font>
<font color="#a52a2a"> 498</font>  <font color="#008b8b">+</font>
<font color="#a52a2a"> 499</font>  <font color="#008b8b">+               }</font>
<font color="#a52a2a"> 500</font>  <font color="#008b8b">+               printk(KERN_INFO &quot;Multiboot module mem 0x%lx - 0x%lx\n&quot;,mboot_module_start, mboot_module_end);</font>
<font color="#a52a2a"> 501</font>  <font color="#008b8b">+       }</font>
<font color="#a52a2a"> 502</font>  <font color="#008b8b">+</font>
<font color="#a52a2a"> 503</font>  <font color="#008b8b">+#endif</font>
<font color="#a52a2a"> 504</font>  <font color="#008b8b">+</font>
<font color="#a52a2a"> 505</font>  <font color="#008b8b">+       return start_pfn;</font>
<font color="#a52a2a"> 506</font>  <font color="#008b8b">+}</font>
<font color="#a52a2a"> 507</font>  <font color="#008b8b">+</font>
<font color="#a52a2a"> 508</font>  <font color="#008b8b">+#define PFN_UP(x)      (((x) + PAGE_SIZE-1) &gt;&gt; PAGE_SHIFT)</font>
<font color="#a52a2a"> 509</font>  <font color="#008b8b">+#define PFN_DOWN(x)    ((x) &gt;&gt; PAGE_SHIFT)</font>
<font color="#a52a2a"> 510</font>  <font color="#008b8b">+#define PFN_PHYS(x)    ((x) &lt;&lt; PAGE_SHIFT)</font>
<font color="#a52a2a"> 511</font>  <font color="#008b8b">+</font>
<font color="#a52a2a"> 512</font>  <font color="#008b8b">+void reserve_mbootinfo_mem(void)</font>
<font color="#a52a2a"> 513</font>  <font color="#008b8b">+{</font>
<font color="#a52a2a"> 514</font>  <font color="#008b8b">+       if (mbootinfo) {</font>
<font color="#a52a2a"> 515</font>  <font color="#008b8b">+               mboot_mem_start = (unsigned long)mbootinfo;</font>
<font color="#a52a2a"> 516</font>  <font color="#008b8b">+               mboot_mem_end = (unsigned long)mbootinfo + sizeof(*mbootinfo);</font>
<font color="#a52a2a"> 517</font>  <font color="#008b8b">+</font>
<font color="#a52a2a"> 518</font>  <font color="#008b8b">+               if (mbootinfo-&gt;flags &amp; MBOOTINFO_HAVE_MODULE) {</font>
<font color="#a52a2a"> 519</font>  <font color="#008b8b">+                       int i;</font>
<font color="#a52a2a"> 520</font>  <font color="#008b8b">+</font>
<font color="#a52a2a"> 521</font>  <font color="#008b8b">+                       SUPBOUND(mboot_mem_start,(unsigned long)mbootinfo-&gt;mods_addr);</font>
<font color="#a52a2a"> 522</font>  <font color="#008b8b">+                       INFBOUND(mboot_mem_end,(unsigned long)mbootinfo-&gt;mods_addr +</font>
<font color="#a52a2a"> 523</font>  <font color="#008b8b">+                               sizeof(struct multiboot_module) * mbootinfo-&gt;mods_count);</font>
<font color="#a52a2a"> 524</font>  <font color="#008b8b">+</font>
<font color="#a52a2a"> 525</font>  <font color="#008b8b">+                       for(i=0;i&lt;mbootinfo-&gt;mods_count;i++) {</font>
<font color="#a52a2a"> 526</font>  <font color="#008b8b">+                               char *str;</font>
<font color="#a52a2a"> 527</font>  <font color="#008b8b">+                               struct multiboot_module *addr = &amp;mbootinfo-&gt;mods_addr[i];</font>
<font color="#a52a2a"> 528</font>  <font color="#008b8b">+</font>
<font color="#a52a2a"> 529</font>  <font color="#008b8b">+                               SUPBOUND(mboot_mem_start,(unsigned long)addr-&gt;string);</font>
<font color="#a52a2a"> 530</font>  <font color="#008b8b">+                               for(str = addr-&gt;string;str[0] != 0;str++);</font>
<font color="#a52a2a"> 531</font>  <font color="#008b8b">+                               INFBOUND(mboot_mem_end,(unsigned long)str);</font>
<font color="#a52a2a"> 532</font>  <font color="#008b8b">+</font>
<font color="#a52a2a"> 533</font>  <font color="#008b8b">+                               (unsigned int)addr-&gt;string += __PAGE_OFFSET;</font>
<font color="#a52a2a"> 534</font>  <font color="#008b8b">+                       }</font>
<font color="#a52a2a"> 535</font>  <font color="#008b8b">+                       SUPBOUND(mboot_mem_start,(unsigned int)mbootinfo-&gt;mods_addr);</font>
<font color="#a52a2a"> 536</font>  <font color="#008b8b">+                       INFBOUND(mboot_mem_end,(unsigned int)mbootinfo-&gt;mods_addr);</font>
<font color="#a52a2a"> 537</font>  <font color="#008b8b">+                       (unsigned int)mbootinfo-&gt;mods_addr += __PAGE_OFFSET;</font>
<font color="#a52a2a"> 538</font>  <font color="#008b8b">+</font>
<font color="#a52a2a"> 539</font>  <font color="#008b8b">+               }</font>
<font color="#a52a2a"> 540</font>  <font color="#008b8b">+</font>
<font color="#a52a2a"> 541</font>  <font color="#008b8b">+               mboot_mem_start = PFN_PHYS(PFN_DOWN(mboot_mem_start));</font>
<font color="#a52a2a"> 542</font>  <font color="#008b8b">+               mboot_mem_end   = PFN_PHYS(PFN_UP(mboot_mem_end));</font>
<font color="#a52a2a"> 543</font>  <font color="#008b8b">+</font>
<font color="#a52a2a"> 544</font>  <font color="#008b8b">+               printk(KERN_NOTICE &quot;Reserving Multiboot Memory 0x%lx - 0x%lx\n&quot;,mboot_mem_start,mboot_mem_end);</font>
<font color="#a52a2a"> 545</font>  <font color="#008b8b">+               reserve_bootmem(mboot_mem_start, mboot_mem_end - mboot_mem_start);</font>
<font color="#a52a2a"> 546</font>  <font color="#008b8b">+</font>
<font color="#a52a2a"> 547</font>  <font color="#008b8b">+               mboot_mem_start += __PAGE_OFFSET;</font>
<font color="#a52a2a"> 548</font>  <font color="#008b8b">+               mboot_mem_end += __PAGE_OFFSET;</font>
<font color="#a52a2a"> 549</font>  <font color="#008b8b">+               (unsigned int)mbootinfo += __PAGE_OFFSET;</font>
<font color="#a52a2a"> 550</font>  <font color="#008b8b">+       }</font>
<font color="#a52a2a"> 551</font>  <font color="#008b8b">+}</font>
<font color="#a52a2a"> 552</font>  <font color="#008b8b">+</font>
<font color="#a52a2a"> 553</font>   void __init setup_arch(char **cmdline_p)
<font color="#a52a2a"> 554</font>   {
<font color="#a52a2a"> 555</font>          unsigned long bootmap_size, low_mem_size;
<font color="#a52a2a"> 556</font>  <font color="#a52a2a"><b>@@ -780,8 +901,27 @@</b></font>
<font color="#a52a2a"> 557</font>
<font color="#a52a2a"> 558</font>          ROOT_DEV = to_kdev_t(ORIG_ROOT_DEV);
<font color="#a52a2a"> 559</font>          drive_info = DRIVE_INFO;
<font color="#a52a2a"> 560</font>  <font color="#008b8b">+</font>
<font color="#a52a2a"> 561</font>  <font color="#008b8b">+       if (mbootinfo) {</font>
<font color="#a52a2a"> 562</font>  <font color="#008b8b">+</font>
<font color="#a52a2a"> 563</font>  <font color="#008b8b">+               screen_info.orig_x = 0;                 /* 0x00 */</font>
<font color="#a52a2a"> 564</font>  <font color="#008b8b">+               screen_info.orig_y = 0;                 /* 0x01 */</font>
<font color="#a52a2a"> 565</font>  <font color="#008b8b">+               screen_info.orig_video_page = 8;                /* 0x04 */</font>
<font color="#a52a2a"> 566</font>  <font color="#008b8b">+               screen_info.orig_video_mode = 3;                /* 0x06 */</font>
<font color="#a52a2a"> 567</font>  <font color="#008b8b">+               screen_info.orig_video_cols = 80;               /* 0x07 */</font>
<font color="#a52a2a"> 568</font>  <font color="#008b8b">+               screen_info.orig_video_ega_bx = 3;      /* 0x0a */</font>
<font color="#a52a2a"> 569</font>  <font color="#008b8b">+               screen_info.orig_video_lines = 25;      /* 0x0e */</font>
<font color="#a52a2a"> 570</font>  <font color="#008b8b">+               screen_info.orig_video_isVGA = 1;       /* 0x0f */</font>
<font color="#a52a2a"> 571</font>  <font color="#008b8b">+               screen_info.orig_video_points = 16;     /* 0x10 */</font>
<font color="#a52a2a"> 572</font>  <font color="#008b8b">+</font>
<font color="#a52a2a"> 573</font>  <font color="#008b8b">+               if (mbootinfo-&gt;flags &amp; MBOOTINFO_HAVE_APMTABLE)</font>
<font color="#a52a2a"> 574</font>  <font color="#008b8b">+                       apm_info.bios = *mbootinfo-&gt;apm_table;</font>
<font color="#a52a2a"> 575</font>  <font color="#008b8b">+</font>
<font color="#a52a2a"> 576</font>  <font color="#008b8b">+       } else {</font>
<font color="#a52a2a"> 577</font>          screen_info = SCREEN_INFO;
<font color="#a52a2a"> 578</font>          apm_info.bios = APM_BIOS_INFO;
<font color="#a52a2a"> 579</font>  <font color="#008b8b">+       }</font>
<font color="#a52a2a"> 580</font>  <font color="#008b8b">+</font>
<font color="#a52a2a"> 581</font>          if( SYS_DESC_TABLE.length != 0 ) {
<font color="#a52a2a"> 582</font>                  MCA_bus = SYS_DESC_TABLE.table[3] &amp;0x2;
<font color="#a52a2a"> 583</font>                  machine_id = SYS_DESC_TABLE.table[0];
<font color="#a52a2a"> 584</font>  <font color="#a52a2a"><b>@@ -811,10 +951,6 @@</b></font>
<font color="#a52a2a"> 585</font>
<font color="#a52a2a"> 586</font>          parse_mem_cmdline(cmdline_p);
<font color="#a52a2a"> 587</font>
<font color="#a52a2a"> 588</font>  <font color="#6a5acd">-#define PFN_UP(x)      (((x) + PAGE_SIZE-1) &gt;&gt; PAGE_SHIFT)</font>
<font color="#a52a2a"> 589</font>  <font color="#6a5acd">-#define PFN_DOWN(x)    ((x) &gt;&gt; PAGE_SHIFT)</font>
<font color="#a52a2a"> 590</font>  <font color="#6a5acd">-#define PFN_PHYS(x)    ((x) &lt;&lt; PAGE_SHIFT)</font>
<font color="#a52a2a"> 591</font>  <font color="#6a5acd">-</font>
<font color="#a52a2a"> 592</font>   /*
<font color="#a52a2a"> 593</font>    * 128MB for vmalloc and initrd
<font color="#a52a2a"> 594</font>    */
<font color="#a52a2a"> 595</font>  <font color="#a52a2a"><b>@@ -827,7 +963,7 @@</b></font>
<font color="#a52a2a"> 596</font>           * partially used pages are not usable - thus
<font color="#a52a2a"> 597</font>           * we are rounding upwards:
<font color="#a52a2a"> 598</font>           */
<font color="#a52a2a"> 599</font>  <font color="#6a5acd">-       start_pfn = PFN_UP(__pa(&amp;_end));</font>
<font color="#a52a2a"> 600</font>  <font color="#008b8b">+       start_pfn = PFN_UP(get_bootmembitmap_addr());</font>
<font color="#a52a2a"> 601</font>
<font color="#a52a2a"> 602</font>          /*
<font color="#a52a2a"> 603</font>           * Find the highest page frame number we have available
<font color="#a52a2a"> 604</font>  <font color="#a52a2a"><b>@@ -941,6 +1077,8 @@</b></font>
<font color="#a52a2a"> 605</font>           */
<font color="#a52a2a"> 606</font>          reserve_bootmem(PAGE_SIZE, PAGE_SIZE);
<font color="#a52a2a"> 607</font>   #endif
<font color="#a52a2a"> 608</font>  <font color="#008b8b">+</font>
<font color="#a52a2a"> 609</font>  <font color="#008b8b">+       reserve_mbootinfo_mem();</font>
<font color="#a52a2a"> 610</font>
<font color="#a52a2a"> 611</font>   #ifdef CONFIG_X86_LOCAL_APIC
<font color="#a52a2a"> 612</font>          /*
<font color="#a52a2a"> 613</font>  <font color="#2e8b57"><b>diff -urbN linux/arch/i386/mm/init.c linux.new/arch/i386/mm/init.c</b></font>
<font color="#a52a2a"> 614</font>  <font color="#2e8b57"><b>--- linux/arch/i386/mm/init.c   Fri Sep 21 04:59:20 2001</b></font>
<font color="#a52a2a"> 615</font>  <font color="#2e8b57"><b>+++ linux.new/arch/i386/mm/init.c       Wed Dec  5 23:59:33 2001</b></font>
<font color="#a52a2a"> 616</font>  <font color="#a52a2a"><b>@@ -36,6 +36,7 @@</b></font>
<font color="#a52a2a"> 617</font>   #include &lt;asm/e820.h&gt;
<font color="#a52a2a"> 618</font>   #include &lt;asm/apic.h&gt;
<font color="#a52a2a"> 619</font>   #include &lt;asm/tlb.h&gt;
<font color="#a52a2a"> 620</font>  <font color="#008b8b">+#include &lt;asm/multiboot.h&gt;</font>
<font color="#a52a2a"> 621</font>
<font color="#a52a2a"> 622</font>   mmu_gather_t mmu_gathers[NR_CPUS];
<font color="#a52a2a"> 623</font>   unsigned long highstart_pfn, highend_pfn;
<font color="#a52a2a"> 624</font>  <font color="#a52a2a"><b>@@ -541,18 +542,34 @@</b></font>
<font color="#a52a2a"> 625</font>          return flag;
<font color="#a52a2a"> 626</font>   }
<font color="#a52a2a"> 627</font>
<font color="#a52a2a"> 628</font>  <font color="#008b8b">+#define FREE_RESERVED_MEM(addr) {\</font>
<font color="#a52a2a"> 629</font>  <font color="#008b8b">+       ClearPageReserved(virt_to_page(addr)); \</font>
<font color="#a52a2a"> 630</font>  <font color="#008b8b">+       set_page_count(virt_to_page(addr), 1); \</font>
<font color="#a52a2a"> 631</font>  <font color="#008b8b">+       free_page(addr); \</font>
<font color="#a52a2a"> 632</font>  <font color="#008b8b">+       totalram_pages++; \</font>
<font color="#a52a2a"> 633</font>  <font color="#008b8b">+}</font>
<font color="#a52a2a"> 634</font>  <font color="#008b8b">+</font>
<font color="#a52a2a"> 635</font>   void free_initmem(void)
<font color="#a52a2a"> 636</font>   {
<font color="#a52a2a"> 637</font>          unsigned long addr;
<font color="#a52a2a"> 638</font>
<font color="#a52a2a"> 639</font>  <font color="#6a5acd">-       addr = (unsigned long)(&amp;__init_begin);</font>
<font color="#a52a2a"> 640</font>  <font color="#6a5acd">-       for (; addr &lt; (unsigned long)(&amp;__init_end); addr += PAGE_SIZE) {</font>
<font color="#a52a2a"> 641</font>  <font color="#6a5acd">-               ClearPageReserved(virt_to_page(addr));</font>
<font color="#a52a2a"> 642</font>  <font color="#6a5acd">-               set_page_count(virt_to_page(addr), 1);</font>
<font color="#a52a2a"> 643</font>  <font color="#6a5acd">-               free_page(addr);</font>
<font color="#a52a2a"> 644</font>  <font color="#6a5acd">-               totalram_pages++;</font>
<font color="#a52a2a"> 645</font>  <font color="#008b8b">+       if (mbootinfo) {</font>
<font color="#a52a2a"> 646</font>  <font color="#008b8b">+               for (addr = mboot_mem_start; addr &lt; mboot_mem_end; addr += PAGE_SIZE)</font>
<font color="#a52a2a"> 647</font>  <font color="#008b8b">+                       FREE_RESERVED_MEM(addr);</font>
<font color="#a52a2a"> 648</font>  <font color="#008b8b">+               printk (&quot;Freeing Multiboot memory: %ldk freed\n&quot;, (mboot_mem_end - mboot_mem_start) &gt;&gt; 10);</font>
<font color="#a52a2a"> 649</font>  <font color="#008b8b">+</font>
<font color="#a52a2a"> 650</font>  <font color="#008b8b">+               if ((mbootinfo-&gt;flags &amp; MBOOTINFO_HAVE_MODULE) &amp;&amp; (mbootinfo-&gt;mods_count &gt; 0)) {</font>
<font color="#a52a2a"> 651</font>  <font color="#008b8b">+                       for (addr = mboot_module_start; addr &lt; mboot_module_end; addr += PAGE_SIZE)</font>
<font color="#a52a2a"> 652</font>  <font color="#008b8b">+                               FREE_RESERVED_MEM(addr);</font>
<font color="#a52a2a"> 653</font>  <font color="#008b8b">+                       printk (&quot;Freeing Multiboot-Module memory: %ldk freed\n&quot;, (mboot_module_end - mboot_module_start) &gt;&gt; 10);</font>
<font color="#a52a2a"> 654</font>  <font color="#008b8b">+               }</font>
<font color="#a52a2a"> 655</font>  <font color="#008b8b">+</font>
<font color="#a52a2a"> 656</font>          }
<font color="#a52a2a"> 657</font>  <font color="#008b8b">+       addr = (unsigned long)(&amp;__init_begin);</font>
<font color="#a52a2a"> 658</font>  <font color="#008b8b">+       for (; addr &lt; (unsigned long)(&amp;__init_end); addr += PAGE_SIZE)</font>
<font color="#a52a2a"> 659</font>  <font color="#008b8b">+               FREE_RESERVED_MEM(addr);</font>
<font color="#a52a2a"> 660</font>          printk (&quot;Freeing unused kernel memory: %dk freed\n&quot;, (&amp;__init_end - &amp;__init_begin) &gt;&gt; 10);
<font color="#a52a2a"> 661</font>  <font color="#008b8b">+</font>
<font color="#a52a2a"> 662</font>   }
<font color="#a52a2a"> 663</font>
<font color="#a52a2a"> 664</font>   #ifdef CONFIG_BLK_DEV_INITRD
<font color="#a52a2a"> 665</font>  <font color="#a52a2a"><b>@@ -560,12 +577,8 @@</b></font>
<font color="#a52a2a"> 666</font>   {
<font color="#a52a2a"> 667</font>          if (start &lt; end)
<font color="#a52a2a"> 668</font>                  printk (&quot;Freeing initrd memory: %ldk freed\n&quot;, (end - start) &gt;&gt; 10);
<font color="#a52a2a"> 669</font>  <font color="#6a5acd">-       for (; start &lt; end; start += PAGE_SIZE) {</font>
<font color="#a52a2a"> 670</font>  <font color="#6a5acd">-               ClearPageReserved(virt_to_page(start));</font>
<font color="#a52a2a"> 671</font>  <font color="#6a5acd">-               set_page_count(virt_to_page(start), 1);</font>
<font color="#a52a2a"> 672</font>  <font color="#6a5acd">-               free_page(start);</font>
<font color="#a52a2a"> 673</font>  <font color="#6a5acd">-               totalram_pages++;</font>
<font color="#a52a2a"> 674</font>  <font color="#6a5acd">-       }</font>
<font color="#a52a2a"> 675</font>  <font color="#008b8b">+       for (; start &lt; end; start += PAGE_SIZE)</font>
<font color="#a52a2a"> 676</font>  <font color="#008b8b">+               FREE_RESERVED_MEM(start);</font>
<font color="#a52a2a"> 677</font>   }
<font color="#a52a2a"> 678</font>   #endif
<font color="#a52a2a"> 679</font>
<font color="#a52a2a"> 680</font>  <font color="#2e8b57"><b>diff -urbN linux/arch/i386/vmlinux.lds linux.new/arch/i386/vmlinux.lds</b></font>
<font color="#a52a2a"> 681</font>  <font color="#2e8b57"><b>--- linux/arch/i386/vmlinux.lds Mon Jul  2 23:40:14 2001</b></font>
<font color="#a52a2a"> 682</font>  <font color="#2e8b57"><b>+++ linux.new/arch/i386/vmlinux.lds     Wed Nov 28 00:11:57 2001</b></font>
<font color="#a52a2a"> 683</font>  <font color="#a52a2a"><b>@@ -3,33 +3,34 @@</b></font>
<font color="#a52a2a"> 684</font>    */
<font color="#a52a2a"> 685</font>   OUTPUT_FORMAT(&quot;elf32-i386&quot;, &quot;elf32-i386&quot;, &quot;elf32-i386&quot;)
<font color="#a52a2a"> 686</font>   OUTPUT_ARCH(i386)
<font color="#a52a2a"> 687</font>  <font color="#6a5acd">-ENTRY(_start)</font>
<font color="#a52a2a"> 688</font>  <font color="#008b8b">+ENTRY(_lmabase)</font>
<font color="#a52a2a"> 689</font>   SECTIONS
<font color="#a52a2a"> 690</font>   {
<font color="#a52a2a"> 691</font>  <font color="#008b8b">+  _lmabase = multiboot_entry - 0xC0000000;</font>
<font color="#a52a2a"> 692</font>     . = 0xC0000000 + 0x100000;
<font color="#a52a2a"> 693</font>     _text = .;                   /* Text and read-only data */
<font color="#a52a2a"> 694</font>  <font color="#6a5acd">-  .text : {</font>
<font color="#a52a2a"> 695</font>  <font color="#008b8b">+  .text : AT (ADDR(.text) - 0xC0000000) {</font>
<font color="#a52a2a"> 696</font>          *(.text)
<font color="#a52a2a"> 697</font>          *(.fixup)
<font color="#a52a2a"> 698</font>          *(.gnu.warning)
<font color="#a52a2a"> 699</font>          } = 0x9090
<font color="#a52a2a"> 700</font>  <font color="#6a5acd">-  .text.lock : { *(.text.lock) }       /* out-of-line lock text */</font>
<font color="#a52a2a"> 701</font>  <font color="#008b8b">+  .text.lock : AT (ADDR(.text.lock) - 0xC0000000) { *(.text.lock) }    /* out-of-line lock text */</font>
<font color="#a52a2a"> 702</font>
<font color="#a52a2a"> 703</font>     _etext = .;                  /* End of text section */
<font color="#a52a2a"> 704</font>
<font color="#a52a2a"> 705</font>  <font color="#6a5acd">-  .rodata : { *(.rodata) *(.rodata.*) }</font>
<font color="#a52a2a"> 706</font>  <font color="#6a5acd">-  .kstrtab : { *(.kstrtab) }</font>
<font color="#a52a2a"> 707</font>  <font color="#008b8b">+  .rodata : AT (ADDR(.rodata) - 0xC0000000) { *(.rodata) *(.rodata.*) }</font>
<font color="#a52a2a"> 708</font>  <font color="#008b8b">+  .kstrtab : AT (ADDR(.kstrtab) - 0xC0000000) { *(.kstrtab) }</font>
<font color="#a52a2a"> 709</font>
<font color="#a52a2a"> 710</font>     . = ALIGN(16);               /* Exception table */
<font color="#a52a2a"> 711</font>     __start___ex_table = .;
<font color="#a52a2a"> 712</font>  <font color="#6a5acd">-  __ex_table : { *(__ex_table) }</font>
<font color="#a52a2a"> 713</font>  <font color="#008b8b">+  __ex_table : AT (ADDR(__ex_table) - 0xC0000000) { *(__ex_table) }</font>
<font color="#a52a2a"> 714</font>     __stop___ex_table = .;
<font color="#a52a2a"> 715</font>
<font color="#a52a2a"> 716</font>     __start___ksymtab = .;       /* Kernel symbol table */
<font color="#a52a2a"> 717</font>  <font color="#6a5acd">-  __ksymtab : { *(__ksymtab) }</font>
<font color="#a52a2a"> 718</font>  <font color="#008b8b">+  __ksymtab : AT (ADDR(__ksymtab) - 0xC0000000) { *(__ksymtab) }</font>
<font color="#a52a2a"> 719</font>     __stop___ksymtab = .;
<font color="#a52a2a"> 720</font>
<font color="#a52a2a"> 721</font>  <font color="#6a5acd">-  .data : {                    /* Data */</font>
<font color="#a52a2a"> 722</font>  <font color="#008b8b">+  .data : AT (ADDR(.data) - 0xC0000000) {                      /* Data */</font>
<font color="#a52a2a"> 723</font>          *(.data)
<font color="#a52a2a"> 724</font>          CONSTRUCTORS
<font color="#a52a2a"> 725</font>          }
<font color="#a52a2a"> 726</font>  <font color="#a52a2a"><b>@@ -37,30 +38,30 @@</b></font>
<font color="#a52a2a"> 727</font>     _edata = .;                  /* End of data section */
<font color="#a52a2a"> 728</font>
<font color="#a52a2a"> 729</font>     . = ALIGN(8192);             /* init_task */
<font color="#a52a2a"> 730</font>  <font color="#6a5acd">-  .data.init_task : { *(.data.init_task) }</font>
<font color="#a52a2a"> 731</font>  <font color="#008b8b">+  .data.init_task : AT (ADDR(.data.init_task) - 0xC0000000) { *(.data.init_task) }</font>
<font color="#a52a2a"> 732</font>
<font color="#a52a2a"> 733</font>     . = ALIGN(4096);             /* Init code and data */
<font color="#a52a2a"> 734</font>     __init_begin = .;
<font color="#a52a2a"> 735</font>  <font color="#6a5acd">-  .text.init : { *(.text.init) }</font>
<font color="#a52a2a"> 736</font>  <font color="#6a5acd">-  .data.init : { *(.data.init) }</font>
<font color="#a52a2a"> 737</font>  <font color="#008b8b">+  .text.init : AT (ADDR(.text.init) - 0xC0000000) { *(.text.init) }</font>
<font color="#a52a2a"> 738</font>  <font color="#008b8b">+  .data.init : AT (ADDR(.data.init) - 0xC0000000) { *(.data.init) }</font>
<font color="#a52a2a"> 739</font>     . = ALIGN(16);
<font color="#a52a2a"> 740</font>     __setup_start = .;
<font color="#a52a2a"> 741</font>  <font color="#6a5acd">-  .setup.init : { *(.setup.init) }</font>
<font color="#a52a2a"> 742</font>  <font color="#008b8b">+  .setup.init : AT (ADDR(.setup.init) - 0xC0000000) { *(.setup.init) }</font>
<font color="#a52a2a"> 743</font>     __setup_end = .;
<font color="#a52a2a"> 744</font>     __initcall_start = .;
<font color="#a52a2a"> 745</font>  <font color="#6a5acd">-  .initcall.init : { *(.initcall.init) }</font>
<font color="#a52a2a"> 746</font>  <font color="#008b8b">+  .initcall.init : AT (ADDR(.initcall.init) - 0xC0000000) { *(.initcall.init) }</font>
<font color="#a52a2a"> 747</font>     __initcall_end = .;
<font color="#a52a2a"> 748</font>     . = ALIGN(4096);
<font color="#a52a2a"> 749</font>     __init_end = .;
<font color="#a52a2a"> 750</font>
<font color="#a52a2a"> 751</font>     . = ALIGN(4096);
<font color="#a52a2a"> 752</font>  <font color="#6a5acd">-  .data.page_aligned : { *(.data.idt) }</font>
<font color="#a52a2a"> 753</font>  <font color="#008b8b">+  .data.page_aligned : AT (ADDR(.data.page_aligned) - 0xC0000000) { *(.data.idt) }</font>
<font color="#a52a2a"> 754</font>
<font color="#a52a2a"> 755</font>     . = ALIGN(32);
<font color="#a52a2a"> 756</font>  <font color="#6a5acd">-  .data.cacheline_aligned : { *(.data.cacheline_aligned) }</font>
<font color="#a52a2a"> 757</font>  <font color="#008b8b">+  .data.cacheline_aligned : AT (ADDR(.data.cacheline_aligned) - 0xC0000000) { *(.data.cacheline_aligned) }</font>
<font color="#a52a2a"> 758</font>
<font color="#a52a2a"> 759</font>     __bss_start = .;             /* BSS */
<font color="#a52a2a"> 760</font>  <font color="#6a5acd">-  .bss : {</font>
<font color="#a52a2a"> 761</font>  <font color="#008b8b">+  .bss : AT (ADDR(.bss) - 0xC0000000) {</font>
<font color="#a52a2a"> 762</font>          *(.bss)
<font color="#a52a2a"> 763</font>          }
<font color="#a52a2a"> 764</font>     _end = . ;
<font color="#a52a2a"> 765</font>  <font color="#2e8b57"><b>diff -urbN linux/include/asm-i386/multiboot.h linux.new/include/asm-i386/multiboot.h</b></font>
<font color="#a52a2a"> 766</font>  <font color="#2e8b57"><b>--- linux/include/asm-i386/multiboot.h  Thu Jan  1 01:00:00 1970</b></font>
<font color="#a52a2a"> 767</font>  <font color="#2e8b57"><b>+++ linux.new/include/asm-i386/multiboot.h      Thu Dec  6 17:39:44 2001</b></font>
<font color="#a52a2a"> 768</font>  <font color="#a52a2a"><b>@@ -0,0 +1,147 @@</b></font>
<font color="#a52a2a"> 769</font>  <font color="#008b8b">+/* multiboot.h - the header for Multiboot */</font>
<font color="#a52a2a"> 770</font>  <font color="#008b8b">+/* Copyright (C) 1999, 2001  Free Software Foundation, Inc.</font>
<font color="#a52a2a"> 771</font>  <font color="#008b8b">+   </font>
<font color="#a52a2a"> 772</font>  <font color="#008b8b">+   This program is free software; you can redistribute it and/or modify</font>
<font color="#a52a2a"> 773</font>  <font color="#008b8b">+   it under the terms of the GNU General Public License as published by</font>
<font color="#a52a2a"> 774</font>  <font color="#008b8b">+   the Free Software Foundation; either version 2 of the License, or</font>
<font color="#a52a2a"> 775</font>  <font color="#008b8b">+   (at your option) any later version.</font>
<font color="#a52a2a"> 776</font>  <font color="#008b8b">+   </font>
<font color="#a52a2a"> 777</font>  <font color="#008b8b">+   This program is distributed in the hope that it will be useful,</font>
<font color="#a52a2a"> 778</font>  <font color="#008b8b">+   but WITHOUT ANY WARRANTY; without even the implied warranty of</font>
<font color="#a52a2a"> 779</font>  <font color="#008b8b">+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</font>
<font color="#a52a2a"> 780</font>  <font color="#008b8b">+   GNU General Public License for more details.</font>
<font color="#a52a2a"> 781</font>  <font color="#008b8b">+   </font>
<font color="#a52a2a"> 782</font>  <font color="#008b8b">+   You should have received a copy of the GNU General Public License</font>
<font color="#a52a2a"> 783</font>  <font color="#008b8b">+   aint with this program; if not, write to the Free Software</font>
<font color="#a52a2a"> 784</font>  <font color="#008b8b">+   Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.  */</font>
<font color="#a52a2a"> 785</font>  <font color="#008b8b">+</font>
<font color="#a52a2a"> 786</font>  <font color="#008b8b">+/* Macros.  */</font>
<font color="#a52a2a"> 787</font>  <font color="#008b8b">+</font>
<font color="#a52a2a"> 788</font>  <font color="#008b8b">+/* The magic number for the Multiboot header.  */</font>
<font color="#a52a2a"> 789</font>  <font color="#008b8b">+#define MULTIBOOT_HEADER_MAGIC         0x1BADB002</font>
<font color="#a52a2a"> 790</font>  <font color="#008b8b">+</font>
<font color="#a52a2a"> 791</font>  <font color="#008b8b">+/* The flags for the Multiboot header.  */</font>
<font color="#a52a2a"> 792</font>  <font color="#008b8b">+# define MULTIBOOT_HEADER_FLAGS                0x00000003</font>
<font color="#a52a2a"> 793</font>  <font color="#008b8b">+</font>
<font color="#a52a2a"> 794</font>  <font color="#008b8b">+/* The magic number passed by a Multiboot-compliant boot loader.  */</font>
<font color="#a52a2a"> 795</font>  <font color="#008b8b">+#define MULTIBOOT_BOOTLOADER_MAGIC     0x2BADB002</font>
<font color="#a52a2a"> 796</font>  <font color="#008b8b">+</font>
<font color="#a52a2a"> 797</font>  <font color="#008b8b">+/* The size of our stack (16KB).  */</font>
<font color="#a52a2a"> 798</font>  <font color="#008b8b">+#define STACK_SIZE                     0x4000</font>
<font color="#a52a2a"> 799</font>  <font color="#008b8b">+</font>
<font color="#a52a2a"> 800</font>  <font color="#008b8b">+/* C symbol format. HAVE_ASM_USCORE is defined by configure.  */</font>
<font color="#a52a2a"> 801</font>  <font color="#008b8b">+#ifdef HAVE_ASM_USCORE</font>
<font color="#a52a2a"> 802</font>  <font color="#008b8b">+# define EXT_C(sym)                    _ ## sym</font>
<font color="#a52a2a"> 803</font>  <font color="#008b8b">+#else</font>
<font color="#a52a2a"> 804</font>  <font color="#008b8b">+# define EXT_C(sym)                    sym</font>
<font color="#a52a2a"> 805</font>  <font color="#008b8b">+#endif</font>
<font color="#a52a2a"> 806</font>  <font color="#008b8b">+</font>
<font color="#a52a2a"> 807</font>  <font color="#008b8b">+#define MBOOTINFO_HAVE_MEMINFO         1</font>
<font color="#a52a2a"> 808</font>  <font color="#008b8b">+#define MBOOTINFO_HAVE_BOOTDEVICE      2</font>
<font color="#a52a2a"> 809</font>  <font color="#008b8b">+#define MBOOTINFO_HAVE_CMDLINE         4</font>
<font color="#a52a2a"> 810</font>  <font color="#008b8b">+#define MBOOTINFO_HAVE_MODULE          8</font>
<font color="#a52a2a"> 811</font>  <font color="#008b8b">+#define MBOOTINFO_HAVE_AOUTINFO                16</font>
<font color="#a52a2a"> 812</font>  <font color="#008b8b">+#define MBOOTINFO_HAVE_ELFINFO         32</font>
<font color="#a52a2a"> 813</font>  <font color="#008b8b">+#define MBOOTINFO_HAVE_MEMMAP          64</font>
<font color="#a52a2a"> 814</font>  <font color="#008b8b">+#define MBOOTINFO_HAVE_DRIVEINFO       128</font>
<font color="#a52a2a"> 815</font>  <font color="#008b8b">+#define MBOOTINFO_HAVE_ROMINFO         256</font>
<font color="#a52a2a"> 816</font>  <font color="#008b8b">+#define MBOOTINFO_HAVE_LOADERNAME      512</font>
<font color="#a52a2a"> 817</font>  <font color="#008b8b">+#define MBOOTINFO_HAVE_APMTABLE                1024</font>
<font color="#a52a2a"> 818</font>  <font color="#008b8b">+#define MBOOTINFO_HAVE_VIDEOINFO       2048</font>
<font color="#a52a2a"> 819</font>  <font color="#008b8b">+</font>
<font color="#a52a2a"> 820</font>  <font color="#008b8b">+#ifndef ASM</font>
<font color="#a52a2a"> 821</font>  <font color="#008b8b">+</font>
<font color="#a52a2a"> 822</font>  <font color="#008b8b">+#include &lt;linux/apm_bios.h&gt;</font>
<font color="#a52a2a"> 823</font>  <font color="#008b8b">+/* Do not include here in boot.S.  */</font>
<font color="#a52a2a"> 824</font>  <font color="#008b8b">+</font>
<font color="#a52a2a"> 825</font>  <font color="#008b8b">+extern struct multiboot_info *mbootinfo;</font>
<font color="#a52a2a"> 826</font>  <font color="#008b8b">+extern unsigned long mboot_mem_start;</font>
<font color="#a52a2a"> 827</font>  <font color="#008b8b">+extern unsigned long mboot_mem_end;</font>
<font color="#a52a2a"> 828</font>  <font color="#008b8b">+extern unsigned long mboot_module_start;</font>
<font color="#a52a2a"> 829</font>  <font color="#008b8b">+extern unsigned long mboot_module_end;</font>
<font color="#a52a2a"> 830</font>  <font color="#008b8b">+</font>
<font color="#a52a2a"> 831</font>  <font color="#008b8b">+/* Types.  */</font>
<font color="#a52a2a"> 832</font>  <font color="#008b8b">+</font>
<font color="#a52a2a"> 833</font>  <font color="#008b8b">+/* The Multiboot header.  */</font>
<font color="#a52a2a"> 834</font>  <font color="#008b8b">+struct multiboot_header</font>
<font color="#a52a2a"> 835</font>  <font color="#008b8b">+{</font>
<font color="#a52a2a"> 836</font>  <font color="#008b8b">+  unsigned int magic;</font>
<font color="#a52a2a"> 837</font>  <font color="#008b8b">+  unsigned int flags;</font>
<font color="#a52a2a"> 838</font>  <font color="#008b8b">+  unsigned int checksum;</font>
<font color="#a52a2a"> 839</font>  <font color="#008b8b">+  unsigned int header_addr;</font>
<font color="#a52a2a"> 840</font>  <font color="#008b8b">+  unsigned int load_addr;</font>
<font color="#a52a2a"> 841</font>  <font color="#008b8b">+  unsigned int load_end_addr;</font>
<font color="#a52a2a"> 842</font>  <font color="#008b8b">+  unsigned int bss_end_addr;</font>
<font color="#a52a2a"> 843</font>  <font color="#008b8b">+  unsigned int entry_addr;</font>
<font color="#a52a2a"> 844</font>  <font color="#008b8b">+};</font>
<font color="#a52a2a"> 845</font>  <font color="#008b8b">+</font>
<font color="#a52a2a"> 846</font>  <font color="#008b8b">+/* The symbol table for a.out.  */</font>
<font color="#a52a2a"> 847</font>  <font color="#008b8b">+struct multiboot_aout_symbol_table</font>
<font color="#a52a2a"> 848</font>  <font color="#008b8b">+{</font>
<font color="#a52a2a"> 849</font>  <font color="#008b8b">+  unsigned int tabsize;</font>
<font color="#a52a2a"> 850</font>  <font color="#008b8b">+  unsigned int strsize;</font>
<font color="#a52a2a"> 851</font>  <font color="#008b8b">+  unsigned int addr;</font>
<font color="#a52a2a"> 852</font>  <font color="#008b8b">+  unsigned int reserved;</font>
<font color="#a52a2a"> 853</font>  <font color="#008b8b">+};</font>
<font color="#a52a2a"> 854</font>  <font color="#008b8b">+</font>
<font color="#a52a2a"> 855</font>  <font color="#008b8b">+/* The section header table for ELF.  */</font>
<font color="#a52a2a"> 856</font>  <font color="#008b8b">+struct multiboot_elf_section_header_table</font>
<font color="#a52a2a"> 857</font>  <font color="#008b8b">+{</font>
<font color="#a52a2a"> 858</font>  <font color="#008b8b">+  unsigned int num;</font>
<font color="#a52a2a"> 859</font>  <font color="#008b8b">+  unsigned int size;</font>
<font color="#a52a2a"> 860</font>  <font color="#008b8b">+  unsigned int addr;</font>
<font color="#a52a2a"> 861</font>  <font color="#008b8b">+  unsigned int shndx;</font>
<font color="#a52a2a"> 862</font>  <font color="#008b8b">+};</font>
<font color="#a52a2a"> 863</font>  <font color="#008b8b">+</font>
<font color="#a52a2a"> 864</font>  <font color="#008b8b">+/* The module structure.  */</font>
<font color="#a52a2a"> 865</font>  <font color="#008b8b">+struct multiboot_module</font>
<font color="#a52a2a"> 866</font>  <font color="#008b8b">+{</font>
<font color="#a52a2a"> 867</font>  <font color="#008b8b">+  unsigned int mod_start;</font>
<font color="#a52a2a"> 868</font>  <font color="#008b8b">+  unsigned int mod_end;</font>
<font color="#a52a2a"> 869</font>  <font color="#008b8b">+  char *string;</font>
<font color="#a52a2a"> 870</font>  <font color="#008b8b">+  unsigned int reserved;</font>
<font color="#a52a2a"> 871</font>  <font color="#008b8b">+};</font>
<font color="#a52a2a"> 872</font>  <font color="#008b8b">+</font>
<font color="#a52a2a"> 873</font>  <font color="#008b8b">+/* The Multiboot information.  */</font>
<font color="#a52a2a"> 874</font>  <font color="#008b8b">+struct multiboot_info</font>
<font color="#a52a2a"> 875</font>  <font color="#008b8b">+{</font>
<font color="#a52a2a"> 876</font>  <font color="#008b8b">+  unsigned int flags;</font>
<font color="#a52a2a"> 877</font>  <font color="#008b8b">+  unsigned int mem_lower;</font>
<font color="#a52a2a"> 878</font>  <font color="#008b8b">+  unsigned int mem_upper;</font>
<font color="#a52a2a"> 879</font>  <font color="#008b8b">+  unsigned int boot_device;</font>
<font color="#a52a2a"> 880</font>  <font color="#008b8b">+  char *cmdline;</font>
<font color="#a52a2a"> 881</font>  <font color="#008b8b">+  unsigned int mods_count;</font>
<font color="#a52a2a"> 882</font>  <font color="#008b8b">+  struct multiboot_module *mods_addr;</font>
<font color="#a52a2a"> 883</font>  <font color="#008b8b">+  union</font>
<font color="#a52a2a"> 884</font>  <font color="#008b8b">+  {</font>
<font color="#a52a2a"> 885</font>  <font color="#008b8b">+    struct multiboot_aout_symbol_table aout_sym;</font>
<font color="#a52a2a"> 886</font>  <font color="#008b8b">+    struct multiboot_elf_section_header_table elf_sec;</font>
<font color="#a52a2a"> 887</font>  <font color="#008b8b">+  } u;</font>
<font color="#a52a2a"> 888</font>  <font color="#008b8b">+  unsigned int mmap_length;</font>
<font color="#a52a2a"> 889</font>  <font color="#008b8b">+  char *mmap_addr;</font>
<font color="#a52a2a"> 890</font>  <font color="#008b8b">+  unsigned int drives_length;</font>
<font color="#a52a2a"> 891</font>  <font color="#008b8b">+  unsigned int drives_addr;</font>
<font color="#a52a2a"> 892</font>  <font color="#008b8b">+  unsigned int config_table;</font>
<font color="#a52a2a"> 893</font>  <font color="#008b8b">+  char *boot_loader_name;</font>
<font color="#a52a2a"> 894</font>  <font color="#008b8b">+  struct apm_bios_info *apm_table;</font>
<font color="#a52a2a"> 895</font>  <font color="#008b8b">+  unsigned int vbe_control_info;</font>
<font color="#a52a2a"> 896</font>  <font color="#008b8b">+  unsigned int vbe_mode_info;</font>
<font color="#a52a2a"> 897</font>  <font color="#008b8b">+  unsigned short vbe_mode;</font>
<font color="#a52a2a"> 898</font>  <font color="#008b8b">+  unsigned short vbe_interface_seg;</font>
<font color="#a52a2a"> 899</font>  <font color="#008b8b">+  unsigned short vbe_interface_off;</font>
<font color="#a52a2a"> 900</font>  <font color="#008b8b">+  unsigned short vbe_interface_len;</font>
<font color="#a52a2a"> 901</font>  <font color="#008b8b">+};</font>
<font color="#a52a2a"> 902</font>  <font color="#008b8b">+</font>
<font color="#a52a2a"> 903</font>  <font color="#008b8b">+/* The memory map. Be careful that the offset 0 is base_addr_low</font>
<font color="#a52a2a"> 904</font>  <font color="#008b8b">+   but no size.  */</font>
<font color="#a52a2a"> 905</font>  <font color="#008b8b">+struct multiboot_memory_map</font>
<font color="#a52a2a"> 906</font>  <font color="#008b8b">+{</font>
<font color="#a52a2a"> 907</font>  <font color="#008b8b">+  unsigned int size;</font>
<font color="#a52a2a"> 908</font>  <font color="#008b8b">+  unsigned int base_addr_low;</font>
<font color="#a52a2a"> 909</font>  <font color="#008b8b">+  unsigned int base_addr_high;</font>
<font color="#a52a2a"> 910</font>  <font color="#008b8b">+  unsigned int length_low;</font>
<font color="#a52a2a"> 911</font>  <font color="#008b8b">+  unsigned int length_high;</font>
<font color="#a52a2a"> 912</font>  <font color="#008b8b">+  unsigned int  type;</font>
<font color="#a52a2a"> 913</font>  <font color="#008b8b">+};</font>
<font color="#a52a2a"> 914</font>  <font color="#008b8b">+</font>
<font color="#a52a2a"> 915</font>  <font color="#008b8b">+#endif /* ! ASM */</font>
<font color="#a52a2a"> 916</font>  <font color="#2e8b57"><b>diff -urbN linux/include/linux/obj_load.h linux.new/include/linux/obj_load.h</b></font>
<font color="#a52a2a"> 917</font>  <font color="#2e8b57"><b>--- linux/include/linux/obj_load.h      Thu Jan  1 01:00:00 1970</b></font>
<font color="#a52a2a"> 918</font>  <font color="#2e8b57"><b>+++ linux.new/include/linux/obj_load.h  Thu Dec  6 15:11:10 2001</b></font>
<font color="#a52a2a"> 919</font>  <font color="#a52a2a"><b>@@ -0,0 +1,297 @@</b></font>
<font color="#a52a2a"> 920</font>  <font color="#008b8b">+/* Elf object file loading and relocation routines.</font>
<font color="#a52a2a"> 921</font>  <font color="#008b8b">+   Copyright 1996, 1997 Linux International.</font>
<font color="#a52a2a"> 922</font>  <font color="#008b8b">+</font>
<font color="#a52a2a"> 923</font>  <font color="#008b8b">+   Contributed by Richard Henderson &lt;rth@tamu.edu&gt;</font>
<font color="#a52a2a"> 924</font>  <font color="#008b8b">+   obj_free() added by Björn Ekwall &lt;bj0rn@blox.se&gt; March 1999</font>
<font color="#a52a2a"> 925</font>  <font color="#008b8b">+</font>
<font color="#a52a2a"> 926</font>  <font color="#008b8b">+   This file is part of the Linux modutils.</font>
<font color="#a52a2a"> 927</font>  <font color="#008b8b">+</font>
<font color="#a52a2a"> 928</font>  <font color="#008b8b">+   This program is free software; you can redistribute it and/or modify it</font>
<font color="#a52a2a"> 929</font>  <font color="#008b8b">+   under the terms of the GNU General Public License as published by the</font>
<font color="#a52a2a"> 930</font>  <font color="#008b8b">+   Free Software Foundation; either version 2 of the License, or (at your</font>
<font color="#a52a2a"> 931</font>  <font color="#008b8b">+   option) any later version.</font>
<font color="#a52a2a"> 932</font>  <font color="#008b8b">+</font>
<font color="#a52a2a"> 933</font>  <font color="#008b8b">+   This program is distributed in the hope that it will be useful, but</font>
<font color="#a52a2a"> 934</font>  <font color="#008b8b">+   WITHOUT ANY WARRANTY; without even the implied warranty of</font>
<font color="#a52a2a"> 935</font>  <font color="#008b8b">+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</font>
<font color="#a52a2a"> 936</font>  <font color="#008b8b">+   General Public License for more details.</font>
<font color="#a52a2a"> 937</font>  <font color="#008b8b">+</font>
<font color="#a52a2a"> 938</font>  <font color="#008b8b">+   You should have received a copy of the GNU General Public License</font>
<font color="#a52a2a"> 939</font>  <font color="#008b8b">+   along with this program; if not, write to the Free Software Foundation,</font>
<font color="#a52a2a"> 940</font>  <font color="#008b8b">+   Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */</font>
<font color="#a52a2a"> 941</font>  <font color="#008b8b">+</font>
<font color="#a52a2a"> 942</font>  <font color="#008b8b">+</font>
<font color="#a52a2a"> 943</font>  <font color="#008b8b">+#ifndef MODUTILS_OBJ_H</font>
<font color="#a52a2a"> 944</font>  <font color="#008b8b">+#define MODUTILS_OBJ_H 1</font>
<font color="#a52a2a"> 945</font>  <font color="#008b8b">+</font>
<font color="#a52a2a"> 946</font>  <font color="#008b8b">+#ident &quot;$Id: obj.h 1.7 Tue, 02 Oct 2001 11:22:51 +1000 kaos $&quot;</font>
<font color="#a52a2a"> 947</font>  <font color="#008b8b">+</font>
<font color="#a52a2a"> 948</font>  <font color="#008b8b">+/* The relocatable object is manipulated using elfin types.  */</font>
<font color="#a52a2a"> 949</font>  <font color="#008b8b">+</font>
<font color="#a52a2a"> 950</font>  <font color="#008b8b">+#include &lt;linux/types.h&gt;</font>
<font color="#a52a2a"> 951</font>  <font color="#008b8b">+#include &lt;linux/elf.h&gt;</font>
<font color="#a52a2a"> 952</font>  <font color="#008b8b">+</font>
<font color="#a52a2a"> 953</font>  <font color="#008b8b">+//#ifndef ElfW</font>
<font color="#a52a2a"> 954</font>  <font color="#008b8b">+//# if ELF_CLASS == ELFCLASS32</font>
<font color="#a52a2a"> 955</font>  <font color="#008b8b">+#  define ElfW(x)  Elf32_ ## x</font>
<font color="#a52a2a"> 956</font>  <font color="#008b8b">+#  define ELFW(x)  ELF32_ ## x</font>
<font color="#a52a2a"> 957</font>  <font color="#008b8b">+//# else</font>
<font color="#a52a2a"> 958</font>  <font color="#008b8b">+//#  define ElfW(x)  Elf64_ ## x</font>
<font color="#a52a2a"> 959</font>  <font color="#008b8b">+//#  define ELFW(x)  ELF64_ ## x</font>
<font color="#a52a2a"> 960</font>  <font color="#008b8b">+//# endif</font>
<font color="#a52a2a"> 961</font>  <font color="#008b8b">+//#endif</font>
<font color="#a52a2a"> 962</font>  <font color="#008b8b">+</font>
<font color="#a52a2a"> 963</font>  <font color="#008b8b">+#if defined(COMMON_3264) &amp;&amp; defined(ONLY_32)</font>
<font color="#a52a2a"> 964</font>  <font color="#008b8b">+#  define ObjW(x)  obj32_ ## x</font>
<font color="#a52a2a"> 965</font>  <font color="#008b8b">+#else</font>
<font color="#a52a2a"> 966</font>  <font color="#008b8b">+#  if defined(COMMON_3264) &amp;&amp; defined(ONLY_64)</font>
<font color="#a52a2a"> 967</font>  <font color="#008b8b">+#    define ObjW(x)  obj64_ ## x</font>
<font color="#a52a2a"> 968</font>  <font color="#008b8b">+#  else</font>
<font color="#a52a2a"> 969</font>  <font color="#008b8b">+#    define ObjW(x)    obj_ ## x</font>
<font color="#a52a2a"> 970</font>  <font color="#008b8b">+#  endif</font>
<font color="#a52a2a"> 971</font>  <font color="#008b8b">+#endif</font>
<font color="#a52a2a"> 972</font>  <font color="#008b8b">+</font>
<font color="#a52a2a"> 973</font>  <font color="#008b8b">+/* For some reason this is missing from lib5.  */</font>
<font color="#a52a2a"> 974</font>  <font color="#008b8b">+#ifndef ELF32_ST_INFO</font>
<font color="#a52a2a"> 975</font>  <font color="#008b8b">+# define ELF32_ST_INFO(bind, type)       (((bind) &lt;&lt; 4) + ((type) &amp; 0xf))</font>
<font color="#a52a2a"> 976</font>  <font color="#008b8b">+#endif</font>
<font color="#a52a2a"> 977</font>  <font color="#008b8b">+</font>
<font color="#a52a2a"> 978</font>  <font color="#008b8b">+#ifndef ELF64_ST_INFO</font>
<font color="#a52a2a"> 979</font>  <font color="#008b8b">+# define ELF64_ST_INFO(bind, type)       (((bind) &lt;&lt; 4) + ((type) &amp; 0xf))</font>
<font color="#a52a2a"> 980</font>  <font color="#008b8b">+#endif</font>
<font color="#a52a2a"> 981</font>  <font color="#008b8b">+</font>
<font color="#a52a2a"> 982</font>  <font color="#008b8b">+struct obj_string_patch_struct;</font>
<font color="#a52a2a"> 983</font>  <font color="#008b8b">+struct obj_symbol_patch_struct;</font>
<font color="#a52a2a"> 984</font>  <font color="#008b8b">+</font>
<font color="#a52a2a"> 985</font>  <font color="#008b8b">+struct obj_section</font>
<font color="#a52a2a"> 986</font>  <font color="#008b8b">+{</font>
<font color="#a52a2a"> 987</font>  <font color="#008b8b">+  ElfW(Shdr) header;</font>
<font color="#a52a2a"> 988</font>  <font color="#008b8b">+  const char *name;</font>
<font color="#a52a2a"> 989</font>  <font color="#008b8b">+  char *contents;</font>
<font color="#a52a2a"> 990</font>  <font color="#008b8b">+  struct obj_section *load_next;</font>
<font color="#a52a2a"> 991</font>  <font color="#008b8b">+  int idx;</font>
<font color="#a52a2a"> 992</font>  <font color="#008b8b">+};</font>
<font color="#a52a2a"> 993</font>  <font color="#008b8b">+</font>
<font color="#a52a2a"> 994</font>  <font color="#008b8b">+struct obj_symbol</font>
<font color="#a52a2a"> 995</font>  <font color="#008b8b">+{</font>
<font color="#a52a2a"> 996</font>  <font color="#008b8b">+  struct obj_symbol *next;     /* hash table link */</font>
<font color="#a52a2a"> 997</font>  <font color="#008b8b">+  const char *name;</font>
<font color="#a52a2a"> 998</font>  <font color="#008b8b">+  unsigned long value;</font>
<font color="#a52a2a"> 999</font>  <font color="#008b8b">+  unsigned long size;</font>
<font color="#a52a2a">1000</font>  <font color="#008b8b">+  int secidx;                  /* the defining section index/module */</font>
<font color="#a52a2a">1001</font>  <font color="#008b8b">+  int info;</font>
<font color="#a52a2a">1002</font>  <font color="#008b8b">+  int ksymidx;                 /* for export to the kernel symtab */</font>
<font color="#a52a2a">1003</font>  <font color="#008b8b">+  int r_type;                  /* relocation type */</font>
<font color="#a52a2a">1004</font>  <font color="#008b8b">+};</font>
<font color="#a52a2a">1005</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1006</font>  <font color="#008b8b">+/* Hardcode the hash table size.  We shouldn't be needing so many</font>
<font color="#a52a2a">1007</font>  <font color="#008b8b">+   symbols that we begin to degrade performance, and we get a big win</font>
<font color="#a52a2a">1008</font>  <font color="#008b8b">+   by giving the compiler a constant divisor.  */</font>
<font color="#a52a2a">1009</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1010</font>  <font color="#008b8b">+#define HASH_BUCKETS  521</font>
<font color="#a52a2a">1011</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1012</font>  <font color="#008b8b">+struct obj_file</font>
<font color="#a52a2a">1013</font>  <font color="#008b8b">+{</font>
<font color="#a52a2a">1014</font>  <font color="#008b8b">+  ElfW(Ehdr) header;</font>
<font color="#a52a2a">1015</font>  <font color="#008b8b">+  ElfW(Addr) baseaddr;</font>
<font color="#a52a2a">1016</font>  <font color="#008b8b">+  struct obj_section **sections;</font>
<font color="#a52a2a">1017</font>  <font color="#008b8b">+  struct obj_section *load_order;</font>
<font color="#a52a2a">1018</font>  <font color="#008b8b">+  struct obj_section **load_order_search_start;</font>
<font color="#a52a2a">1019</font>  <font color="#008b8b">+  struct obj_string_patch_struct *string_patches;</font>
<font color="#a52a2a">1020</font>  <font color="#008b8b">+  struct obj_symbol_patch_struct *symbol_patches;</font>
<font color="#a52a2a">1021</font>  <font color="#008b8b">+  int (*symbol_cmp)(const char *, const char *);</font>
<font color="#a52a2a">1022</font>  <font color="#008b8b">+  unsigned long (*symbol_hash)(const char *);</font>
<font color="#a52a2a">1023</font>  <font color="#008b8b">+  unsigned long local_symtab_size;</font>
<font color="#a52a2a">1024</font>  <font color="#008b8b">+  struct obj_symbol **local_symtab;</font>
<font color="#a52a2a">1025</font>  <font color="#008b8b">+  struct obj_symbol *symtab[HASH_BUCKETS];</font>
<font color="#a52a2a">1026</font>  <font color="#008b8b">+  const char *filename;</font>
<font color="#a52a2a">1027</font>  <font color="#008b8b">+  char *persist;</font>
<font color="#a52a2a">1028</font>  <font color="#008b8b">+};</font>
<font color="#a52a2a">1029</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1030</font>  <font color="#008b8b">+enum obj_reloc</font>
<font color="#a52a2a">1031</font>  <font color="#008b8b">+{</font>
<font color="#a52a2a">1032</font>  <font color="#008b8b">+  obj_reloc_ok,</font>
<font color="#a52a2a">1033</font>  <font color="#008b8b">+  obj_reloc_overflow,</font>
<font color="#a52a2a">1034</font>  <font color="#008b8b">+  obj_reloc_dangerous,</font>
<font color="#a52a2a">1035</font>  <font color="#008b8b">+  obj_reloc_unhandled,</font>
<font color="#a52a2a">1036</font>  <font color="#008b8b">+  obj_reloc_constant_gp</font>
<font color="#a52a2a">1037</font>  <font color="#008b8b">+};</font>
<font color="#a52a2a">1038</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1039</font>  <font color="#008b8b">+struct obj_string_patch_struct</font>
<font color="#a52a2a">1040</font>  <font color="#008b8b">+{</font>
<font color="#a52a2a">1041</font>  <font color="#008b8b">+  struct obj_string_patch_struct *next;</font>
<font color="#a52a2a">1042</font>  <font color="#008b8b">+  int reloc_secidx;</font>
<font color="#a52a2a">1043</font>  <font color="#008b8b">+  ElfW(Addr) reloc_offset;</font>
<font color="#a52a2a">1044</font>  <font color="#008b8b">+  ElfW(Addr) string_offset;</font>
<font color="#a52a2a">1045</font>  <font color="#008b8b">+};</font>
<font color="#a52a2a">1046</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1047</font>  <font color="#008b8b">+struct obj_symbol_patch_struct</font>
<font color="#a52a2a">1048</font>  <font color="#008b8b">+{</font>
<font color="#a52a2a">1049</font>  <font color="#008b8b">+  struct obj_symbol_patch_struct *next;</font>
<font color="#a52a2a">1050</font>  <font color="#008b8b">+  int reloc_secidx;</font>
<font color="#a52a2a">1051</font>  <font color="#008b8b">+  ElfW(Addr) reloc_offset;</font>
<font color="#a52a2a">1052</font>  <font color="#008b8b">+  struct obj_symbol *sym;</font>
<font color="#a52a2a">1053</font>  <font color="#008b8b">+};</font>
<font color="#a52a2a">1054</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1055</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1056</font>  <font color="#008b8b">+/* Generic object manipulation routines.  */</font>
<font color="#a52a2a">1057</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1058</font>  <font color="#008b8b">+#define obj_elf_hash                   ObjW(elf_hash)</font>
<font color="#a52a2a">1059</font>  <font color="#008b8b">+#define obj_elf_hash_n                 ObjW(elf_hash_n)</font>
<font color="#a52a2a">1060</font>  <font color="#008b8b">+#define obj_add_symbol                 ObjW(add_symbol)</font>
<font color="#a52a2a">1061</font>  <font color="#008b8b">+#define obj_find_symbol                        ObjW(find_symbol)</font>
<font color="#a52a2a">1062</font>  <font color="#008b8b">+#define obj_symbol_final_value         ObjW(symbol_final_value)</font>
<font color="#a52a2a">1063</font>  <font color="#008b8b">+#define obj_set_symbol_compare         ObjW(set_symbol_compare)</font>
<font color="#a52a2a">1064</font>  <font color="#008b8b">+#define obj_find_section               ObjW(find_section)</font>
<font color="#a52a2a">1065</font>  <font color="#008b8b">+#define obj_insert_section_load_order  ObjW(insert_section_load_order)</font>
<font color="#a52a2a">1066</font>  <font color="#008b8b">+#define obj_create_alloced_section     ObjW(create_alloced_section)</font>
<font color="#a52a2a">1067</font>  <font color="#008b8b">+#define obj_create_alloced_section_first \</font>
<font color="#a52a2a">1068</font>  <font color="#008b8b">+                                       ObjW(create_alloced_section_first)</font>
<font color="#a52a2a">1069</font>  <font color="#008b8b">+#define obj_extend_section             ObjW(extend_section)</font>
<font color="#a52a2a">1070</font>  <font color="#008b8b">+#define obj_string_patch               ObjW(string_patch)</font>
<font color="#a52a2a">1071</font>  <font color="#008b8b">+#define obj_symbol_patch               ObjW(symbol_patch)</font>
<font color="#a52a2a">1072</font>  <font color="#008b8b">+#define obj_check_undefineds           ObjW(check_undefineds)</font>
<font color="#a52a2a">1073</font>  <font color="#008b8b">+#define obj_clear_undefineds           ObjW(clear_undefineds)</font>
<font color="#a52a2a">1074</font>  <font color="#008b8b">+#define obj_allocate_commons           ObjW(allocate_commons)</font>
<font color="#a52a2a">1075</font>  <font color="#008b8b">+#define obj_load_size                  ObjW(load_size)</font>
<font color="#a52a2a">1076</font>  <font color="#008b8b">+#define obj_relocate                   ObjW(relocate)</font>
<font color="#a52a2a">1077</font>  <font color="#008b8b">+#define obj_load                       ObjW(load)</font>
<font color="#a52a2a">1078</font>  <font color="#008b8b">+#define obj_free                       ObjW(free)</font>
<font color="#a52a2a">1079</font>  <font color="#008b8b">+#define obj_create_image               ObjW(create_image)</font>
<font color="#a52a2a">1080</font>  <font color="#008b8b">+#define obj_addr_to_native_ptr         ObjW(addr_to_native_ptr)</font>
<font color="#a52a2a">1081</font>  <font color="#008b8b">+#define obj_native_ptr_to_addr         ObjW(native_ptr_to_addr)</font>
<font color="#a52a2a">1082</font>  <font color="#008b8b">+#define obj_kallsyms                   ObjW(kallsyms)</font>
<font color="#a52a2a">1083</font>  <font color="#008b8b">+#define arch_new_file                  ObjW(arch_new_file)</font>
<font color="#a52a2a">1084</font>  <font color="#008b8b">+#define arch_new_section               ObjW(arch_new_section)</font>
<font color="#a52a2a">1085</font>  <font color="#008b8b">+#define arch_new_symbol                        ObjW(arch_new_symbol)</font>
<font color="#a52a2a">1086</font>  <font color="#008b8b">+#define arch_apply_relocation          ObjW(arch_apply_relocation)</font>
<font color="#a52a2a">1087</font>  <font color="#008b8b">+#define arch_create_got                        ObjW(arch_create_got)</font>
<font color="#a52a2a">1088</font>  <font color="#008b8b">+#define arch_init_module               ObjW(arch_init_module)</font>
<font color="#a52a2a">1089</font>  <font color="#008b8b">+#define arch_load_proc_section         ObjW(arch_load_proc_section)</font>
<font color="#a52a2a">1090</font>  <font color="#008b8b">+#define arch_finalize_section_address  ObjW(arch_finalize_section_address)</font>
<font color="#a52a2a">1091</font>  <font color="#008b8b">+#define arch_archdata                  ObjW(arch_archdata)</font>
<font color="#a52a2a">1092</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1093</font>  <font color="#008b8b">+unsigned long obj_elf_hash (const char *);</font>
<font color="#a52a2a">1094</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1095</font>  <font color="#008b8b">+unsigned long obj_elf_hash_n (const char *, unsigned long len);</font>
<font color="#a52a2a">1096</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1097</font>  <font color="#008b8b">+struct obj_symbol *obj_add_symbol (struct obj_file *f, const char *name,</font>
<font color="#a52a2a">1098</font>  <font color="#008b8b">+                                  unsigned long symidx, int info, int secidx,</font>
<font color="#a52a2a">1099</font>  <font color="#008b8b">+                                  ElfW(Addr) value, unsigned long size);</font>
<font color="#a52a2a">1100</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1101</font>  <font color="#008b8b">+struct obj_symbol *obj_find_symbol (struct obj_file *f,</font>
<font color="#a52a2a">1102</font>  <font color="#008b8b">+                                        const char *name);</font>
<font color="#a52a2a">1103</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1104</font>  <font color="#008b8b">+ElfW(Addr) obj_symbol_final_value (struct obj_file *f,</font>
<font color="#a52a2a">1105</font>  <font color="#008b8b">+                                 struct obj_symbol *sym);</font>
<font color="#a52a2a">1106</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1107</font>  <font color="#008b8b">+void obj_set_symbol_compare (struct obj_file *f,</font>
<font color="#a52a2a">1108</font>  <font color="#008b8b">+                           int (*cmp)(const char *, const char *),</font>
<font color="#a52a2a">1109</font>  <font color="#008b8b">+                           unsigned long (*hash)(const char *));</font>
<font color="#a52a2a">1110</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1111</font>  <font color="#008b8b">+struct obj_section *obj_find_section (struct obj_file *f,</font>
<font color="#a52a2a">1112</font>  <font color="#008b8b">+                                          const char *name);</font>
<font color="#a52a2a">1113</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1114</font>  <font color="#008b8b">+void obj_insert_section_load_order (struct obj_file *f,</font>
<font color="#a52a2a">1115</font>  <font color="#008b8b">+                                   struct obj_section *sec);</font>
<font color="#a52a2a">1116</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1117</font>  <font color="#008b8b">+struct obj_section *obj_create_alloced_section (struct obj_file *f,</font>
<font color="#a52a2a">1118</font>  <font color="#008b8b">+                                               const char *name,</font>
<font color="#a52a2a">1119</font>  <font color="#008b8b">+                                               unsigned long align,</font>
<font color="#a52a2a">1120</font>  <font color="#008b8b">+                                               unsigned long size,</font>
<font color="#a52a2a">1121</font>  <font color="#008b8b">+                                               unsigned long flags);</font>
<font color="#a52a2a">1122</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1123</font>  <font color="#008b8b">+struct obj_section *obj_create_alloced_section_first (struct obj_file *f,</font>
<font color="#a52a2a">1124</font>  <font color="#008b8b">+                                                     const char *name,</font>
<font color="#a52a2a">1125</font>  <font color="#008b8b">+                                                     unsigned long align,</font>
<font color="#a52a2a">1126</font>  <font color="#008b8b">+                                                     unsigned long size);</font>
<font color="#a52a2a">1127</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1128</font>  <font color="#008b8b">+void *obj_extend_section (struct obj_section *sec, unsigned long more);</font>
<font color="#a52a2a">1129</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1130</font>  <font color="#008b8b">+int obj_string_patch (struct obj_file *f, int secidx, ElfW(Addr) offset,</font>
<font color="#a52a2a">1131</font>  <font color="#008b8b">+                    const char *string);</font>
<font color="#a52a2a">1132</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1133</font>  <font color="#008b8b">+int obj_symbol_patch (struct obj_file *f, int secidx, ElfW(Addr) offset,</font>
<font color="#a52a2a">1134</font>  <font color="#008b8b">+                    struct obj_symbol *sym);</font>
<font color="#a52a2a">1135</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1136</font>  <font color="#008b8b">+int obj_check_undefineds (struct obj_file *f, int quiet);</font>
<font color="#a52a2a">1137</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1138</font>  <font color="#008b8b">+void obj_clear_undefineds (struct obj_file *f);</font>
<font color="#a52a2a">1139</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1140</font>  <font color="#008b8b">+void obj_allocate_commons (struct obj_file *f);</font>
<font color="#a52a2a">1141</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1142</font>  <font color="#008b8b">+unsigned long obj_load_size (struct obj_file *f);</font>
<font color="#a52a2a">1143</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1144</font>  <font color="#008b8b">+int obj_relocate (struct obj_file *f, ElfW(Addr) base);</font>
<font color="#a52a2a">1145</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1146</font>  <font color="#008b8b">+struct obj_file *</font>
<font color="#a52a2a">1147</font>  <font color="#008b8b">+obj_load (void *modmem, unsigned int modsize, Elf32_Half e_type, const char *filename);</font>
<font color="#a52a2a">1148</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1149</font>  <font color="#008b8b">+void obj_free (struct obj_file *f);</font>
<font color="#a52a2a">1150</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1151</font>  <font color="#008b8b">+int obj_create_image (struct obj_file *f, char *image);</font>
<font color="#a52a2a">1152</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1153</font>  <font color="#008b8b">+int obj_kallsyms (struct obj_file *fin, struct obj_file **fout);</font>
<font color="#a52a2a">1154</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1155</font>  <font color="#008b8b">+/* Architecture specific manipulation routines.  */</font>
<font color="#a52a2a">1156</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1157</font>  <font color="#008b8b">+struct obj_file *arch_new_file (void);</font>
<font color="#a52a2a">1158</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1159</font>  <font color="#008b8b">+struct obj_section *arch_new_section (void);</font>
<font color="#a52a2a">1160</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1161</font>  <font color="#008b8b">+struct obj_symbol *arch_new_symbol (void);</font>
<font color="#a52a2a">1162</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1163</font>  <font color="#008b8b">+enum obj_reloc arch_apply_relocation (struct obj_file *f,</font>
<font color="#a52a2a">1164</font>  <font color="#008b8b">+                                     struct obj_section *targsec,</font>
<font color="#a52a2a">1165</font>  <font color="#008b8b">+                                     struct obj_section *symsec,</font>
<font color="#a52a2a">1166</font>  <font color="#008b8b">+                                     struct obj_symbol *sym,</font>
<font color="#a52a2a">1167</font>  <font color="#008b8b">+                                     ElfW(Rel) *rel, ElfW(Addr) value);</font>
<font color="#a52a2a">1168</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1169</font>  <font color="#008b8b">+int arch_create_got (struct obj_file *f);</font>
<font color="#a52a2a">1170</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1171</font>  <font color="#008b8b">+struct module;</font>
<font color="#a52a2a">1172</font>  <font color="#008b8b">+int arch_init_module (struct obj_file *f, struct module *);</font>
<font color="#a52a2a">1173</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1174</font>  <font color="#008b8b">+int arch_load_proc_section (struct obj_section *sec, int fp);</font>
<font color="#a52a2a">1175</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1176</font>  <font color="#008b8b">+int arch_finalize_section_address (struct obj_file *f, ElfW(Addr) base);</font>
<font color="#a52a2a">1177</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1178</font>  <font color="#008b8b">+int arch_archdata (struct obj_file *fin, struct obj_section *sec);</font>
<font color="#a52a2a">1179</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1180</font>  <font color="#008b8b">+#define ARCHDATA_SEC_NAME &quot;__archdata&quot;</font>
<font color="#a52a2a">1181</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1182</font>  <font color="#008b8b">+/* Pointers in objects can be 32 or 64 bit */</font>
<font color="#a52a2a">1183</font>  <font color="#008b8b">+union obj_ptr_4 {</font>
<font color="#a52a2a">1184</font>  <font color="#008b8b">+       Elf32_Word addr;</font>
<font color="#a52a2a">1185</font>  <font color="#008b8b">+       void *ptr;</font>
<font color="#a52a2a">1186</font>  <font color="#008b8b">+};</font>
<font color="#a52a2a">1187</font>  <font color="#008b8b">+union obj_ptr_8 {</font>
<font color="#a52a2a">1188</font>  <font color="#008b8b">+       u_int64_t addr; /* Should be Elf64_Xword but not all users have this yet */</font>
<font color="#a52a2a">1189</font>  <font color="#008b8b">+       void *ptr;</font>
<font color="#a52a2a">1190</font>  <font color="#008b8b">+};</font>
<font color="#a52a2a">1191</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1192</font>  <font color="#008b8b">+void *obj_addr_to_native_ptr(ElfW(Addr));</font>
<font color="#a52a2a">1193</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1194</font>  <font color="#008b8b">+ElfW(Addr) obj_native_ptr_to_addr(void *);</font>
<font color="#a52a2a">1195</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1196</font>  <font color="#008b8b">+/* Standard method of finding relocation symbols, sets isym */</font>
<font color="#a52a2a">1197</font>  <font color="#008b8b">+#define obj_find_relsym(isym, f, find, rel, symtab, strtab) \</font>
<font color="#a52a2a">1198</font>  <font color="#008b8b">+       { \</font>
<font color="#a52a2a">1199</font>  <font color="#008b8b">+               unsigned long symndx = ELFW(R_SYM)((rel)-&gt;r_info); \</font>
<font color="#a52a2a">1200</font>  <font color="#008b8b">+               ElfW(Sym) *extsym = (symtab)+symndx; \</font>
<font color="#a52a2a">1201</font>  <font color="#008b8b">+               if (ELFW(ST_BIND)(extsym-&gt;st_info) == STB_LOCAL) { \</font>
<font color="#a52a2a">1202</font>  <font color="#008b8b">+                       isym = (typeof(isym)) (f)-&gt;local_symtab[symndx]; \</font>
<font color="#a52a2a">1203</font>  <font color="#008b8b">+               } \</font>
<font color="#a52a2a">1204</font>  <font color="#008b8b">+               else { \</font>
<font color="#a52a2a">1205</font>  <font color="#008b8b">+                       const char *name; \</font>
<font color="#a52a2a">1206</font>  <font color="#008b8b">+                       if (extsym-&gt;st_name) \</font>
<font color="#a52a2a">1207</font>  <font color="#008b8b">+                               name = (strtab) + extsym-&gt;st_name; \</font>
<font color="#a52a2a">1208</font>  <font color="#008b8b">+                       else \</font>
<font color="#a52a2a">1209</font>  <font color="#008b8b">+                               name = (f)-&gt;sections[extsym-&gt;st_shndx]-&gt;name; \</font>
<font color="#a52a2a">1210</font>  <font color="#008b8b">+                       isym = (typeof(isym)) obj_find_symbol((find), name); \</font>
<font color="#a52a2a">1211</font>  <font color="#008b8b">+               } \</font>
<font color="#a52a2a">1212</font>  <font color="#008b8b">+       }</font>
<font color="#a52a2a">1213</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1214</font>  <font color="#008b8b">+int obj_gpl_license(struct obj_file *, const char **);</font>
<font color="#a52a2a">1215</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1216</font>  <font color="#008b8b">+#endif /* obj.h */</font>
<font color="#a52a2a">1217</font>  <font color="#2e8b57"><b>diff -urbN linux/init/main.c linux.new/init/main.c</b></font>
<font color="#a52a2a">1218</font>  <font color="#2e8b57"><b>--- linux/init/main.c   Fri Oct 12 19:17:15 2001</b></font>
<font color="#a52a2a">1219</font>  <font color="#2e8b57"><b>+++ linux.new/init/main.c       Tue Dec  4 02:13:42 2001</b></font>
<font color="#a52a2a">1220</font>  <font color="#a52a2a"><b>@@ -94,6 +94,7 @@</b></font>
<font color="#a52a2a">1221</font>   extern void sysctl_init(void);
<font color="#a52a2a">1222</font>   extern void signals_init(void);
<font color="#a52a2a">1223</font>   extern int init_pcmcia_ds(void);
<font color="#a52a2a">1224</font>  <font color="#008b8b">+extern void init_boot_modules(void);</font>
<font color="#a52a2a">1225</font>
<font color="#a52a2a">1226</font>   extern void free_initmem(void);
<font color="#a52a2a">1227</font>
<font color="#a52a2a">1228</font>  <font color="#a52a2a"><b>@@ -736,6 +737,7 @@</b></font>
<font color="#a52a2a">1229</font>   #ifdef CONFIG_PCMCIA
<font color="#a52a2a">1230</font>          init_pcmcia_ds();               /* Do this last */
<font color="#a52a2a">1231</font>   #endif
<font color="#a52a2a">1232</font>  <font color="#008b8b">+       init_boot_modules();</font>
<font color="#a52a2a">1233</font>   }
<font color="#a52a2a">1234</font>
<font color="#a52a2a">1235</font>   extern void rd_load(void);
<font color="#a52a2a">1236</font>  <font color="#2e8b57"><b>diff -urbN linux/kernel/Makefile linux.new/kernel/Makefile</b></font>
<font color="#a52a2a">1237</font>  <font color="#2e8b57"><b>--- linux/kernel/Makefile       Mon Sep 17 06:22:40 2001</b></font>
<font color="#a52a2a">1238</font>  <font color="#2e8b57"><b>+++ linux.new/kernel/Makefile   Wed Dec  5 22:28:24 2001</b></font>
<font color="#a52a2a">1239</font>  <font color="#a52a2a"><b>@@ -14,7 +14,8 @@</b></font>
<font color="#a52a2a">1240</font>   obj-y     = sched.o dma.o fork.o exec_domain.o panic.o printk.o \
<font color="#a52a2a">1241</font>              module.o exit.o itimer.o info.o time.o softirq.o resource.o \
<font color="#a52a2a">1242</font>              sysctl.o acct.o capability.o ptrace.o timer.o user.o \
<font color="#a52a2a">1243</font>  <font color="#6a5acd">-           signal.o sys.o kmod.o context.o</font>
<font color="#a52a2a">1244</font>  <font color="#008b8b">+           signal.o sys.o kmod.o context.o boot_modules.o \</font>
<font color="#a52a2a">1245</font>  <font color="#008b8b">+           obj_common.o obj_reloc.o obj_gpl_license.o obj_load.o</font>
<font color="#a52a2a">1246</font>
<font color="#a52a2a">1247</font>   obj-$(CONFIG_UID16) += uid16.o
<font color="#a52a2a">1248</font>   obj-$(CONFIG_MODULES) += ksyms.o
<font color="#a52a2a">1249</font>  <font color="#2e8b57"><b>diff -urbN linux/kernel/boot_modules.c linux.new/kernel/boot_modules.c</b></font>
<font color="#a52a2a">1250</font>  <font color="#2e8b57"><b>--- linux/kernel/boot_modules.c Thu Jan  1 01:00:00 1970</b></font>
<font color="#a52a2a">1251</font>  <font color="#2e8b57"><b>+++ linux.new/kernel/boot_modules.c     Thu Dec  6 15:11:02 2001</b></font>
<font color="#a52a2a">1252</font>  <font color="#a52a2a"><b>@@ -0,0 +1,413 @@</b></font>
<font color="#a52a2a">1253</font>  <font color="#008b8b">+/*</font>
<font color="#a52a2a">1254</font>  <font color="#008b8b">+ *  linux/kernel/boot_modules.c</font>
<font color="#a52a2a">1255</font>  <font color="#008b8b">+ *</font>
<font color="#a52a2a">1256</font>  <font color="#008b8b">+ *  Copyright (C) 2001 Christian König</font>
<font color="#a52a2a">1257</font>  <font color="#008b8b">+ *</font>
<font color="#a52a2a">1258</font>  <font color="#008b8b">+ *  Ervery thing here is GPL'ed.</font>
<font color="#a52a2a">1259</font>  <font color="#008b8b">+ */</font>
<font color="#a52a2a">1260</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1261</font>  <font color="#008b8b">+#include &lt;linux/slab.h&gt;</font>
<font color="#a52a2a">1262</font>  <font color="#008b8b">+#include &lt;linux/kernel.h&gt;</font>
<font color="#a52a2a">1263</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1264</font>  <font color="#008b8b">+#ifndef __i386__ //this file should'n be arch dependent, but I'am lazy</font>
<font color="#a52a2a">1265</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1266</font>  <font color="#008b8b">+void init_boot_modules(void) {}</font>
<font color="#a52a2a">1267</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1268</font>  <font color="#008b8b">+#else</font>
<font color="#a52a2a">1269</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1270</font>  <font color="#008b8b">+#include &lt;asm/multiboot.h&gt;</font>
<font color="#a52a2a">1271</font>  <font color="#008b8b">+#include &lt;linux/obj_load.h&gt;</font>
<font color="#a52a2a">1272</font>  <font color="#008b8b">+#include &lt;linux/version.h&gt;</font>
<font color="#a52a2a">1273</font>  <font color="#008b8b">+#include &lt;linux/module.h&gt;</font>
<font color="#a52a2a">1274</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1275</font>  <font color="#008b8b">+#define STRVERSIONLEN  32</font>
<font color="#a52a2a">1276</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1277</font>  <font color="#008b8b">+/*</font>
<font color="#a52a2a">1278</font>  <font color="#008b8b">+ * Conditionally add the symbols from the given symbol set</font>
<font color="#a52a2a">1279</font>  <font color="#008b8b">+ * to the new module.</font>
<font color="#a52a2a">1280</font>  <font color="#008b8b">+ */</font>
<font color="#a52a2a">1281</font>  <font color="#008b8b">+static int add_symbols_from(struct obj_file *f, int idx,</font>
<font color="#a52a2a">1282</font>  <font color="#008b8b">+                           struct module_symbol *syms, size_t nsyms, int gpl)</font>
<font color="#a52a2a">1283</font>  <font color="#008b8b">+{</font>
<font color="#a52a2a">1284</font>  <font color="#008b8b">+       struct module_symbol *s;</font>
<font color="#a52a2a">1285</font>  <font color="#008b8b">+       size_t i;</font>
<font color="#a52a2a">1286</font>  <font color="#008b8b">+       int used = 0;</font>
<font color="#a52a2a">1287</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1288</font>  <font color="#008b8b">+       for (i = 0, s = syms; i &lt; nsyms; ++i, ++s) {</font>
<font color="#a52a2a">1289</font>  <font color="#008b8b">+               /*</font>
<font color="#a52a2a">1290</font>  <font color="#008b8b">+                * Only add symbols that are already marked external.</font>
<font color="#a52a2a">1291</font>  <font color="#008b8b">+                * If we override locals we may cause problems for</font>
<font color="#a52a2a">1292</font>  <font color="#008b8b">+                * argument initialization.</font>
<font color="#a52a2a">1293</font>  <font color="#008b8b">+                * We will also create a false dependency on the module.</font>
<font color="#a52a2a">1294</font>  <font color="#008b8b">+                */</font>
<font color="#a52a2a">1295</font>  <font color="#008b8b">+               struct obj_symbol *sym;</font>
<font color="#a52a2a">1296</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1297</font>  <font color="#008b8b">+               /* GPL licensed modules can use symbols exported with</font>
<font color="#a52a2a">1298</font>  <font color="#008b8b">+                * EXPORT_SYMBOL_GPL, so ignore any GPLONLY_ prefix on the</font>
<font color="#a52a2a">1299</font>  <font color="#008b8b">+                * exported names.  Non-GPL modules never see any GPLONLY_</font>
<font color="#a52a2a">1300</font>  <font color="#008b8b">+                * symbols so they cannot fudge it by adding the prefix on</font>
<font color="#a52a2a">1301</font>  <font color="#008b8b">+                * their references.</font>
<font color="#a52a2a">1302</font>  <font color="#008b8b">+                */</font>
<font color="#a52a2a">1303</font>  <font color="#008b8b">+               if (strncmp((char *)s-&gt;name, &quot;GPLONLY_&quot;, 8) == 0) {</font>
<font color="#a52a2a">1304</font>  <font color="#008b8b">+                       if (gpl)</font>
<font color="#a52a2a">1305</font>  <font color="#008b8b">+                               ((char *)s-&gt;name) += 8;</font>
<font color="#a52a2a">1306</font>  <font color="#008b8b">+                       else</font>
<font color="#a52a2a">1307</font>  <font color="#008b8b">+                               continue;</font>
<font color="#a52a2a">1308</font>  <font color="#008b8b">+               }</font>
<font color="#a52a2a">1309</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1310</font>  <font color="#008b8b">+               sym = obj_find_symbol(f, (char *) s-&gt;name);</font>
<font color="#a52a2a">1311</font>  <font color="#008b8b">+               if (sym &amp;&amp; ELFW(ST_BIND) (sym-&gt;info) != STB_LOCAL) {</font>
<font color="#a52a2a">1312</font>  <font color="#008b8b">+                       sym = obj_add_symbol(f, (char *) s-&gt;name, -1,</font>
<font color="#a52a2a">1313</font>  <font color="#008b8b">+                                 ELFW(ST_INFO) (STB_GLOBAL, STT_NOTYPE),</font>
<font color="#a52a2a">1314</font>  <font color="#008b8b">+                                            idx, s-&gt;value, 0);</font>
<font color="#a52a2a">1315</font>  <font color="#008b8b">+                       /*</font>
<font color="#a52a2a">1316</font>  <font color="#008b8b">+                        * Did our symbol just get installed?</font>
<font color="#a52a2a">1317</font>  <font color="#008b8b">+                        * If so, mark the module as &quot;used&quot;.</font>
<font color="#a52a2a">1318</font>  <font color="#008b8b">+                        */</font>
<font color="#a52a2a">1319</font>  <font color="#008b8b">+                       if (sym-&gt;secidx == idx)</font>
<font color="#a52a2a">1320</font>  <font color="#008b8b">+                               used = 1;</font>
<font color="#a52a2a">1321</font>  <font color="#008b8b">+               }</font>
<font color="#a52a2a">1322</font>  <font color="#008b8b">+       }</font>
<font color="#a52a2a">1323</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1324</font>  <font color="#008b8b">+       return used;</font>
<font color="#a52a2a">1325</font>  <font color="#008b8b">+}</font>
<font color="#a52a2a">1326</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1327</font>  <font color="#008b8b">+static void add_kernel_symbols(struct obj_file *f, int gpl)</font>
<font color="#a52a2a">1328</font>  <font color="#008b8b">+{</font>
<font color="#a52a2a">1329</font>  <font color="#008b8b">+       struct module *mod;</font>
<font color="#a52a2a">1330</font>  <font color="#008b8b">+       size_t i;</font>
<font color="#a52a2a">1331</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1332</font>  <font color="#008b8b">+       /* Add module symbols first.  */</font>
<font color="#a52a2a">1333</font>  <font color="#008b8b">+       for (mod=module_list, i = 0; mod; mod=mod-&gt;next, i++)</font>
<font color="#a52a2a">1334</font>  <font color="#008b8b">+               if (mod-&gt;nsyms)</font>
<font color="#a52a2a">1335</font>  <font color="#008b8b">+                       add_symbols_from(f, SHN_HIRESERVE + 2 + i, mod-&gt;syms, mod-&gt;nsyms, gpl);</font>
<font color="#a52a2a">1336</font>  <font color="#008b8b">+}</font>
<font color="#a52a2a">1337</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1338</font>  <font color="#008b8b">+static int create_this_module(struct obj_file *f, const char *m_name)</font>
<font color="#a52a2a">1339</font>  <font color="#008b8b">+{</font>
<font color="#a52a2a">1340</font>  <font color="#008b8b">+       struct obj_section *sec;</font>
<font color="#a52a2a">1341</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1342</font>  <font color="#008b8b">+       sec = obj_create_alloced_section_first(f, &quot;.this&quot;, sizeof(long),</font>
<font color="#a52a2a">1343</font>  <font color="#008b8b">+                                              sizeof(struct module));</font>
<font color="#a52a2a">1344</font>  <font color="#008b8b">+       memset(sec-&gt;contents, 0, sizeof(struct module));</font>
<font color="#a52a2a">1345</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1346</font>  <font color="#008b8b">+       obj_add_symbol(f, &quot;__this_module&quot;, -1, ELFW(ST_INFO) (STB_LOCAL, STT_OBJECT),</font>
<font color="#a52a2a">1347</font>  <font color="#008b8b">+                      sec-&gt;idx, 0, sizeof(struct module));</font>
<font color="#a52a2a">1348</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1349</font>  <font color="#008b8b">+       obj_string_patch(f, sec-&gt;idx, offsetof(struct module, name), m_name);</font>
<font color="#a52a2a">1350</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1351</font>  <font color="#008b8b">+       return 1;</font>
<font color="#a52a2a">1352</font>  <font color="#008b8b">+}</font>
<font color="#a52a2a">1353</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1354</font>  <font color="#008b8b">+static void hide_special_symbols(struct obj_file *f)</font>
<font color="#a52a2a">1355</font>  <font color="#008b8b">+{</font>
<font color="#a52a2a">1356</font>  <font color="#008b8b">+       struct obj_symbol *sym;</font>
<font color="#a52a2a">1357</font>  <font color="#008b8b">+       const char *const *p;</font>
<font color="#a52a2a">1358</font>  <font color="#008b8b">+       static const char *const specials[] =</font>
<font color="#a52a2a">1359</font>  <font color="#008b8b">+       {</font>
<font color="#a52a2a">1360</font>  <font color="#008b8b">+               &quot;cleanup_module&quot;,</font>
<font color="#a52a2a">1361</font>  <font color="#008b8b">+               &quot;init_module&quot;,</font>
<font color="#a52a2a">1362</font>  <font color="#008b8b">+               &quot;kernel_version&quot;,</font>
<font color="#a52a2a">1363</font>  <font color="#008b8b">+               NULL</font>
<font color="#a52a2a">1364</font>  <font color="#008b8b">+       };</font>
<font color="#a52a2a">1365</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1366</font>  <font color="#008b8b">+       for (p = specials; *p; ++p)</font>
<font color="#a52a2a">1367</font>  <font color="#008b8b">+               if ((sym = obj_find_symbol(f, *p)) != NULL)</font>
<font color="#a52a2a">1368</font>  <font color="#008b8b">+                       sym-&gt;info = ELFW(ST_INFO) (STB_LOCAL, ELFW(ST_TYPE) (sym-&gt;info));</font>
<font color="#a52a2a">1369</font>  <font color="#008b8b">+}</font>
<font color="#a52a2a">1370</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1371</font>  <font color="#008b8b">+static int create_module_ksymtab(struct obj_file *f)</font>
<font color="#a52a2a">1372</font>  <font color="#008b8b">+{</font>
<font color="#a52a2a">1373</font>  <font color="#008b8b">+       struct obj_section *sec;</font>
<font color="#a52a2a">1374</font>  <font color="#008b8b">+       int i;</font>
<font color="#a52a2a">1375</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1376</font>  <font color="#008b8b">+       /* We must always add the module references.  */</font>
<font color="#a52a2a">1377</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1378</font>  <font color="#008b8b">+/*     if (n_ext_modules_used) {</font>
<font color="#a52a2a">1379</font>  <font color="#008b8b">+               struct module_ref *dep;</font>
<font color="#a52a2a">1380</font>  <font color="#008b8b">+               struct obj_symbol *tm;</font>
<font color="#a52a2a">1381</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1382</font>  <font color="#008b8b">+               sec = obj_create_alloced_section(f, &quot;.kmodtab&quot;,</font>
<font color="#a52a2a">1383</font>  <font color="#008b8b">+                       tgt_sizeof_void_p,</font>
<font color="#a52a2a">1384</font>  <font color="#008b8b">+                       sizeof(struct module_ref) * n_ext_modules_used, 0);</font>
<font color="#a52a2a">1385</font>  <font color="#008b8b">+               if (!sec)</font>
<font color="#a52a2a">1386</font>  <font color="#008b8b">+                       return 0;</font>
<font color="#a52a2a">1387</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1388</font>  <font color="#008b8b">+               tm = obj_find_symbol(f, &quot;__this_module&quot;);</font>
<font color="#a52a2a">1389</font>  <font color="#008b8b">+               dep = (struct module_ref *) sec-&gt;contents;</font>
<font color="#a52a2a">1390</font>  <font color="#008b8b">+               for (i = 0; i &lt; n_module_stat; ++i)</font>
<font color="#a52a2a">1391</font>  <font color="#008b8b">+                       if (module_stat[i].status ) {</font>
<font color="#a52a2a">1392</font>  <font color="#008b8b">+                               dep-&gt;dep = module_stat[i].addr;</font>
<font color="#a52a2a">1393</font>  <font color="#008b8b">+                               obj_symbol_patch(f, sec-&gt;idx, (char *) &amp;dep-&gt;ref - sec-&gt;contents, tm);</font>
<font color="#a52a2a">1394</font>  <font color="#008b8b">+                               dep-&gt;next_ref = 0;</font>
<font color="#a52a2a">1395</font>  <font color="#008b8b">+                               ++dep;</font>
<font color="#a52a2a">1396</font>  <font color="#008b8b">+                       }</font>
<font color="#a52a2a">1397</font>  <font color="#008b8b">+       }*/</font>
<font color="#a52a2a">1398</font>  <font color="#008b8b">+/*     if (!obj_find_section(f, &quot;__ksymtab&quot;)) {</font>
<font color="#a52a2a">1399</font>  <font color="#008b8b">+               int *loaded;</font>
<font color="#a52a2a">1400</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1401</font>  <font color="#008b8b">+                We don't want to export symbols residing in sections that</font>
<font color="#a52a2a">1402</font>  <font color="#008b8b">+                  aren't loaded.  There are a number of these created so that</font>
<font color="#a52a2a">1403</font>  <font color="#008b8b">+                  we make sure certain module options don't appear twice.</font>
<font color="#a52a2a">1404</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1405</font>  <font color="#008b8b">+               loaded = alloca(sizeof(int) * (i = f-&gt;header.e_shnum));</font>
<font color="#a52a2a">1406</font>  <font color="#008b8b">+               while (--i &gt;= 0)</font>
<font color="#a52a2a">1407</font>  <font color="#008b8b">+                       loaded[i] = (f-&gt;sections[i]-&gt;header.sh_flags &amp; SHF_ALLOC) != 0;</font>
<font color="#a52a2a">1408</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1409</font>  <font color="#008b8b">+               for (i = 0; i &lt; HASH_BUCKETS; ++i) {</font>
<font color="#a52a2a">1410</font>  <font color="#008b8b">+                       struct obj_symbol *sym;</font>
<font color="#a52a2a">1411</font>  <font color="#008b8b">+                       for (sym = f-&gt;symtab[i]; sym; sym = sym-&gt;next) {</font>
<font color="#a52a2a">1412</font>  <font color="#008b8b">+                               if (ELFW(ST_BIND) (sym-&gt;info) != STB_LOCAL</font>
<font color="#a52a2a">1413</font>  <font color="#008b8b">+                                   &amp;&amp; sym-&gt;secidx &lt;= SHN_HIRESERVE</font>
<font color="#a52a2a">1414</font>  <font color="#008b8b">+                                   &amp;&amp; (sym-&gt;secidx &gt;= SHN_LORESERVE</font>
<font color="#a52a2a">1415</font>  <font color="#008b8b">+                                       || loaded[sym-&gt;secidx])) {</font>
<font color="#a52a2a">1416</font>  <font color="#008b8b">+                                       add_ksymtab(f, sym);</font>
<font color="#a52a2a">1417</font>  <font color="#008b8b">+                               }</font>
<font color="#a52a2a">1418</font>  <font color="#008b8b">+                       }</font>
<font color="#a52a2a">1419</font>  <font color="#008b8b">+               }</font>
<font color="#a52a2a">1420</font>  <font color="#008b8b">+       }*/</font>
<font color="#a52a2a">1421</font>  <font color="#008b8b">+       return 1;</font>
<font color="#a52a2a">1422</font>  <font color="#008b8b">+}</font>
<font color="#a52a2a">1423</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1424</font>  <font color="#008b8b">+extern asmlinkage unsigned long sys_create_module(const char *name_user, size_t size);</font>
<font color="#a52a2a">1425</font>  <font color="#008b8b">+extern asmlinkage long sys_delete_module(const char *name_user);</font>
<font color="#a52a2a">1426</font>  <font color="#008b8b">+extern asmlinkage long sys_init_module(const char *name_user, struct module *mod_user);</font>
<font color="#a52a2a">1427</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1428</font>  <font color="#008b8b">+static int init_module(const char *m_name, struct obj_file *f,</font>
<font color="#a52a2a">1429</font>  <font color="#008b8b">+                      unsigned long m_size)</font>
<font color="#a52a2a">1430</font>  <font color="#008b8b">+{</font>
<font color="#a52a2a">1431</font>  <font color="#008b8b">+       struct module *module;</font>
<font color="#a52a2a">1432</font>  <font color="#008b8b">+       struct obj_section *sec;</font>
<font color="#a52a2a">1433</font>  <font color="#008b8b">+       void *image;</font>
<font color="#a52a2a">1434</font>  <font color="#008b8b">+       int ret = 0;</font>
<font color="#a52a2a">1435</font>  <font color="#008b8b">+       long m_addr;</font>
<font color="#a52a2a">1436</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1437</font>  <font color="#008b8b">+       sec = obj_find_section(f, &quot;.this&quot;);</font>
<font color="#a52a2a">1438</font>  <font color="#008b8b">+       module = (struct module *) sec-&gt;contents;</font>
<font color="#a52a2a">1439</font>  <font color="#008b8b">+       m_addr = sec-&gt;header.sh_addr;</font>
<font color="#a52a2a">1440</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1441</font>  <font color="#008b8b">+       module-&gt;size_of_struct = sizeof(*module);</font>
<font color="#a52a2a">1442</font>  <font color="#008b8b">+       module-&gt;size = m_size;</font>
<font color="#a52a2a">1443</font>  <font color="#008b8b">+       module-&gt;flags = 0; //flag_autoclean ? NEW_MOD_AUTOCLEAN : 0;</font>
<font color="#a52a2a">1444</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1445</font>  <font color="#008b8b">+       sec = obj_find_section(f, &quot;__ksymtab&quot;);</font>
<font color="#a52a2a">1446</font>  <font color="#008b8b">+       if (sec &amp;&amp; sec-&gt;header.sh_size) {</font>
<font color="#a52a2a">1447</font>  <font color="#008b8b">+               module-&gt;syms = sec-&gt;header.sh_addr;</font>
<font color="#a52a2a">1448</font>  <font color="#008b8b">+               module-&gt;nsyms = sec-&gt;header.sh_size / (2 * sizeof(char *));</font>
<font color="#a52a2a">1449</font>  <font color="#008b8b">+       }</font>
<font color="#a52a2a">1450</font>  <font color="#008b8b">+/*     if (n_ext_modules_used) {</font>
<font color="#a52a2a">1451</font>  <font color="#008b8b">+               sec = obj_find_section(f, &quot;.kmodtab&quot;);</font>
<font color="#a52a2a">1452</font>  <font color="#008b8b">+               module-&gt;deps = sec-&gt;header.sh_addr;</font>
<font color="#a52a2a">1453</font>  <font color="#008b8b">+               module-&gt;ndeps = n_ext_modules_used;</font>
<font color="#a52a2a">1454</font>  <font color="#008b8b">+       }*/</font>
<font color="#a52a2a">1455</font>  <font color="#008b8b">+       module-&gt;init = obj_symbol_final_value(f, obj_find_symbol(f, &quot;init_module&quot;));</font>
<font color="#a52a2a">1456</font>  <font color="#008b8b">+       module-&gt;cleanup = obj_symbol_final_value(f,</font>
<font color="#a52a2a">1457</font>  <font color="#008b8b">+               obj_find_symbol(f, &quot;cleanup_module&quot;));</font>
<font color="#a52a2a">1458</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1459</font>  <font color="#008b8b">+       sec = obj_find_section(f, &quot;__ex_table&quot;);</font>
<font color="#a52a2a">1460</font>  <font color="#008b8b">+       if (sec) {</font>
<font color="#a52a2a">1461</font>  <font color="#008b8b">+               module-&gt;ex_table_start = sec-&gt;header.sh_addr;</font>
<font color="#a52a2a">1462</font>  <font color="#008b8b">+               module-&gt;ex_table_end = sec-&gt;header.sh_addr + sec-&gt;header.sh_size;</font>
<font color="#a52a2a">1463</font>  <font color="#008b8b">+       }</font>
<font color="#a52a2a">1464</font>  <font color="#008b8b">+       sec = obj_find_section(f, &quot;.text.init&quot;);</font>
<font color="#a52a2a">1465</font>  <font color="#008b8b">+       if (sec) {</font>
<font color="#a52a2a">1466</font>  <font color="#008b8b">+               module-&gt;runsize = sec-&gt;header.sh_addr - m_addr;</font>
<font color="#a52a2a">1467</font>  <font color="#008b8b">+       }</font>
<font color="#a52a2a">1468</font>  <font color="#008b8b">+       sec = obj_find_section(f, &quot;.data.init&quot;);</font>
<font color="#a52a2a">1469</font>  <font color="#008b8b">+       if (sec) {</font>
<font color="#a52a2a">1470</font>  <font color="#008b8b">+               if (!module-&gt;runsize ||</font>
<font color="#a52a2a">1471</font>  <font color="#008b8b">+                   module-&gt;runsize &gt; sec-&gt;header.sh_addr - m_addr)</font>
<font color="#a52a2a">1472</font>  <font color="#008b8b">+                       module-&gt;runsize = sec-&gt;header.sh_addr - m_addr;</font>
<font color="#a52a2a">1473</font>  <font color="#008b8b">+       }</font>
<font color="#a52a2a">1474</font>  <font color="#008b8b">+/*     sec = obj_find_section(f, ARCHDATA_SEC_NAME);</font>
<font color="#a52a2a">1475</font>  <font color="#008b8b">+       if (sec &amp;&amp; sec-&gt;header.sh_size) {</font>
<font color="#a52a2a">1476</font>  <font color="#008b8b">+               module-&gt;archdata_start = sec-&gt;header.sh_addr;</font>
<font color="#a52a2a">1477</font>  <font color="#008b8b">+               module-&gt;archdata_end = module-&gt;archdata_start + sec-&gt;header.sh_size;</font>
<font color="#a52a2a">1478</font>  <font color="#008b8b">+       }</font>
<font color="#a52a2a">1479</font>  <font color="#008b8b">+       sec = obj_find_section(f, KALLSYMS_SEC_NAME);</font>
<font color="#a52a2a">1480</font>  <font color="#008b8b">+       if (sec &amp;&amp; sec-&gt;header.sh_size) {</font>
<font color="#a52a2a">1481</font>  <font color="#008b8b">+               module-&gt;kallsyms_start = sec-&gt;header.sh_addr;</font>
<font color="#a52a2a">1482</font>  <font color="#008b8b">+               module-&gt;kallsyms_end = module-&gt;kallsyms_start + sec-&gt;header.sh_size;</font>
<font color="#a52a2a">1483</font>  <font color="#008b8b">+       }</font>
<font color="#a52a2a">1484</font>  <font color="#008b8b">+       if (!arch_init_module(f, module))</font>
<font color="#a52a2a">1485</font>  <font color="#008b8b">+               return 0;</font>
<font color="#a52a2a">1486</font>  <font color="#008b8b">+*/</font>
<font color="#a52a2a">1487</font>  <font color="#008b8b">+       /*</font>
<font color="#a52a2a">1488</font>  <font color="#008b8b">+        * Whew!  All of the initialization is complete.</font>
<font color="#a52a2a">1489</font>  <font color="#008b8b">+        * Collect the final module image and give it to the kernel.</font>
<font color="#a52a2a">1490</font>  <font color="#008b8b">+        */</font>
<font color="#a52a2a">1491</font>  <font color="#008b8b">+       image = kmalloc(m_size, GFP_KERNEL);</font>
<font color="#a52a2a">1492</font>  <font color="#008b8b">+       obj_create_image(f, image);</font>
<font color="#a52a2a">1493</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1494</font>  <font color="#008b8b">+       if (ret == 0) {</font>
<font color="#a52a2a">1495</font>  <font color="#008b8b">+//             fflush(stdout);         /* Flush any debugging output */</font>
<font color="#a52a2a">1496</font>  <font color="#008b8b">+               ret = sys_init_module(m_name, (struct module *) image);</font>
<font color="#a52a2a">1497</font>  <font color="#008b8b">+               if (ret) {</font>
<font color="#a52a2a">1498</font>  <font color="#008b8b">+                       printk(KERN_INFO &quot;init_module: %m\n&quot;);</font>
<font color="#a52a2a">1499</font>  <font color="#008b8b">+                       printk(KERN_INFO &quot;Hint: insmod errors can be caused by incorrect module parameters, &quot;</font>
<font color="#a52a2a">1500</font>  <font color="#008b8b">+                               &quot;including invalid IO or IRQ parameters\n&quot;);</font>
<font color="#a52a2a">1501</font>  <font color="#008b8b">+               }</font>
<font color="#a52a2a">1502</font>  <font color="#008b8b">+       }</font>
<font color="#a52a2a">1503</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1504</font>  <font color="#008b8b">+       kfree(image);</font>
<font color="#a52a2a">1505</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1506</font>  <font color="#008b8b">+       return ret == 0;</font>
<font color="#a52a2a">1507</font>  <font color="#008b8b">+}</font>
<font color="#a52a2a">1508</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1509</font>  <font color="#008b8b">+static int insert_module(struct obj_file *f, const char *m_name, int argc, char **argv)</font>
<font color="#a52a2a">1510</font>  <font color="#008b8b">+{</font>
<font color="#a52a2a">1511</font>  <font color="#008b8b">+       int gpl;</font>
<font color="#a52a2a">1512</font>  <font color="#008b8b">+       unsigned long m_size;</font>
<font color="#a52a2a">1513</font>  <font color="#008b8b">+       unsigned long m_addr;</font>
<font color="#a52a2a">1514</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1515</font>  <font color="#008b8b">+/*     int k_crcs;</font>
<font color="#a52a2a">1516</font>  <font color="#008b8b">+       int m_version;</font>
<font color="#a52a2a">1517</font>  <font color="#008b8b">+       char m_strversion[STRVERSIONLEN];</font>
<font color="#a52a2a">1518</font>  <font color="#008b8b">+       int m_crcs;</font>
<font color="#a52a2a">1519</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1520</font>  <font color="#008b8b">+       m_version = get_module_version(f, m_strversion);</font>
<font color="#a52a2a">1521</font>  <font color="#008b8b">+       if (m_version == -1) {</font>
<font color="#a52a2a">1522</font>  <font color="#008b8b">+               printk(KERN_INFO &quot;couldn't find the kernel version the module was compiled for&quot;);</font>
<font color="#a52a2a">1523</font>  <font color="#008b8b">+               return 0;</font>
<font color="#a52a2a">1524</font>  <font color="#008b8b">+       }</font>
<font color="#a52a2a">1525</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1526</font>  <font color="#008b8b">+       k_crcs = is_kernel_checksummed();</font>
<font color="#a52a2a">1527</font>  <font color="#008b8b">+       m_crcs = is_module_checksummed(f);</font>
<font color="#a52a2a">1528</font>  <font color="#008b8b">+       if ((m_crcs == 0 || k_crcs == 0) &amp;&amp;</font>
<font color="#a52a2a">1529</font>  <font color="#008b8b">+           strncmp(m_strversion, UTS_RELEASE, STRVERSIONLEN) != 0) {</font>
<font color="#a52a2a">1530</font>  <font color="#008b8b">+               printk(KERN_INFO &quot;kernel-module version mismatch\n&quot;</font>
<font color="#a52a2a">1531</font>  <font color="#008b8b">+                     &quot;\t%s was compiled for kernel version %s\n&quot;</font>
<font color="#a52a2a">1532</font>  <font color="#008b8b">+                     &quot;\twhile this kernel is version %s.&quot;,</font>
<font color="#a52a2a">1533</font>  <font color="#008b8b">+                     filename, m_strversion, UTS_RELEASE);</font>
<font color="#a52a2a">1534</font>  <font color="#008b8b">+               return 0;</font>
<font color="#a52a2a">1535</font>  <font color="#008b8b">+       }</font>
<font color="#a52a2a">1536</font>  <font color="#008b8b">+       if (m_crcs != k_crcs)</font>
<font color="#a52a2a">1537</font>  <font color="#008b8b">+               obj_set_symbol_compare(f, ncv_strcmp, ncv_symbol_hash);*/</font>
<font color="#a52a2a">1538</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1539</font>  <font color="#008b8b">+       // We don't care about Versions for now</font>
<font color="#a52a2a">1540</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1541</font>  <font color="#008b8b">+       /* Let the module know about the kernel symbols.  */</font>
<font color="#a52a2a">1542</font>  <font color="#008b8b">+       gpl = obj_gpl_license(f, NULL) == 0;</font>
<font color="#a52a2a">1543</font>  <font color="#008b8b">+       add_kernel_symbols(f, gpl);</font>
<font color="#a52a2a">1544</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1545</font>  <font color="#008b8b">+       /* Allocate common symbols, symbol tables, and string tables.</font>
<font color="#a52a2a">1546</font>  <font color="#008b8b">+        *</font>
<font color="#a52a2a">1547</font>  <font color="#008b8b">+        * The calls marked DEPMOD indicate the bits of code that depmod</font>
<font color="#a52a2a">1548</font>  <font color="#008b8b">+        * uses to do a pseudo relocation, ignoring undefined symbols.</font>
<font color="#a52a2a">1549</font>  <font color="#008b8b">+        * Any changes made to the relocation sequence here should be</font>
<font color="#a52a2a">1550</font>  <font color="#008b8b">+        * checked against depmod.</font>
<font color="#a52a2a">1551</font>  <font color="#008b8b">+        */</font>
<font color="#a52a2a">1552</font>  <font color="#008b8b">+       if (!create_this_module(f, m_name))</font>
<font color="#a52a2a">1553</font>  <font color="#008b8b">+               return 0;</font>
<font color="#a52a2a">1554</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1555</font>  <font color="#008b8b">+       arch_create_got(f);     /* DEPMOD */</font>
<font color="#a52a2a">1556</font>  <font color="#008b8b">+       if (!obj_check_undefineds(f, 0)) {      /* DEPMOD, obj_clear_undefineds */</font>
<font color="#a52a2a">1557</font>  <font color="#008b8b">+               if (!gpl)</font>
<font color="#a52a2a">1558</font>  <font color="#008b8b">+                       printk(KERN_INFO &quot;Note: modules without a GPL compatible license cannot use GPLONLY_ symbols\n&quot;);</font>
<font color="#a52a2a">1559</font>  <font color="#008b8b">+               return 0;</font>
<font color="#a52a2a">1560</font>  <font color="#008b8b">+       }</font>
<font color="#a52a2a">1561</font>  <font color="#008b8b">+       obj_allocate_commons(f);        /* DEPMOD */</font>
<font color="#a52a2a">1562</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1563</font>  <font color="#008b8b">+//     check_module_parameters(f, &amp;persist_parms);</font>
<font color="#a52a2a">1564</font>  <font color="#008b8b">+//     check_tainted_module(f, noload);</font>
<font color="#a52a2a">1565</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1566</font>  <font color="#008b8b">+/*     if (argc) {</font>
<font color="#a52a2a">1567</font>  <font color="#008b8b">+               if (!process_module_arguments(f, argc, argv, 1))</font>
<font color="#a52a2a">1568</font>  <font color="#008b8b">+                       return 0;</font>
<font color="#a52a2a">1569</font>  <font color="#008b8b">+       }*/</font>
<font color="#a52a2a">1570</font>  <font color="#008b8b">+       hide_special_symbols(f);</font>
<font color="#a52a2a">1571</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1572</font>  <font color="#008b8b">+/*     if (flag_ksymoops)</font>
<font color="#a52a2a">1573</font>  <font color="#008b8b">+               add_ksymoops_symbols(f, filename, m_name);*/</font>
<font color="#a52a2a">1574</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1575</font>  <font color="#008b8b">+//     if (k_new_syscalls)</font>
<font color="#a52a2a">1576</font>  <font color="#008b8b">+       create_module_ksymtab(f);</font>
<font color="#a52a2a">1577</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1578</font>  <font color="#008b8b">+       /* archdata based on relocatable addresses */</font>
<font color="#a52a2a">1579</font>  <font color="#008b8b">+//     if (add_archdata(f, &amp;archdata))</font>
<font color="#a52a2a">1580</font>  <font color="#008b8b">+//             return 0;</font>
<font color="#a52a2a">1581</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1582</font>  <font color="#008b8b">+       /* kallsyms based on relocatable addresses */</font>
<font color="#a52a2a">1583</font>  <font color="#008b8b">+//     if (add_kallsyms(f, &amp;kallsyms, force_kallsyms))</font>
<font color="#a52a2a">1584</font>  <font color="#008b8b">+//             return 0;</font>
<font color="#a52a2a">1585</font>  <font color="#008b8b">+       /**** No symbols or sections to be changed after kallsyms above ***/</font>
<font color="#a52a2a">1586</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1587</font>  <font color="#008b8b">+//     if (errors)</font>
<font color="#a52a2a">1588</font>  <font color="#008b8b">+//             return 0;</font>
<font color="#a52a2a">1589</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1590</font>  <font color="#008b8b">+       /* Module has now finished growing; find its size and install it.  */</font>
<font color="#a52a2a">1591</font>  <font color="#008b8b">+       m_size = obj_load_size(f);      /* DEPMOD */</font>
<font color="#a52a2a">1592</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1593</font>  <font color="#008b8b">+//     errno = 0;</font>
<font color="#a52a2a">1594</font>  <font color="#008b8b">+       m_addr = sys_create_module(m_name, m_size);</font>
<font color="#a52a2a">1595</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1596</font>  <font color="#008b8b">+       switch (-m_addr) {</font>
<font color="#a52a2a">1597</font>  <font color="#008b8b">+       case 0:</font>
<font color="#a52a2a">1598</font>  <font color="#008b8b">+               break;</font>
<font color="#a52a2a">1599</font>  <font color="#008b8b">+       case EEXIST:</font>
<font color="#a52a2a">1600</font>  <font color="#008b8b">+               printk(KERN_INFO &quot;a module named %s already exists\n&quot;, m_name);</font>
<font color="#a52a2a">1601</font>  <font color="#008b8b">+               return 0;</font>
<font color="#a52a2a">1602</font>  <font color="#008b8b">+       case ENOMEM:</font>
<font color="#a52a2a">1603</font>  <font color="#008b8b">+               printk(KERN_INFO &quot;can't allocate kernel memory for module; needed %lu bytes\n&quot;,</font>
<font color="#a52a2a">1604</font>  <font color="#008b8b">+                     m_size);</font>
<font color="#a52a2a">1605</font>  <font color="#008b8b">+               return 0;</font>
<font color="#a52a2a">1606</font>  <font color="#008b8b">+       default:</font>
<font color="#a52a2a">1607</font>  <font color="#008b8b">+               if(m_addr &gt; 127)</font>
<font color="#a52a2a">1608</font>  <font color="#008b8b">+                       break;</font>
<font color="#a52a2a">1609</font>  <font color="#008b8b">+               printk(KERN_INFO &quot;create_module: %m\n&quot;);</font>
<font color="#a52a2a">1610</font>  <font color="#008b8b">+               return 0;</font>
<font color="#a52a2a">1611</font>  <font color="#008b8b">+       }</font>
<font color="#a52a2a">1612</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1613</font>  <font color="#008b8b">+       printk(KERN_INFO &quot;Trying to relocate module @ 0x%x\n&quot;,m_addr);</font>
<font color="#a52a2a">1614</font>  <font color="#008b8b">+       if (!obj_relocate(f, m_addr)) { /* DEPMOD */</font>
<font color="#a52a2a">1615</font>  <font color="#008b8b">+               sys_delete_module(m_name);</font>
<font color="#a52a2a">1616</font>  <font color="#008b8b">+               return 0;</font>
<font color="#a52a2a">1617</font>  <font color="#008b8b">+       }</font>
<font color="#a52a2a">1618</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1619</font>  <font color="#008b8b">+       /* Do archdata again, this time we have the final addresses */</font>
<font color="#a52a2a">1620</font>  <font color="#008b8b">+//     if (add_archdata(f, &amp;archdata))</font>
<font color="#a52a2a">1621</font>  <font color="#008b8b">+//             return 0;</font>
<font color="#a52a2a">1622</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1623</font>  <font color="#008b8b">+       /* Do kallsyms again, this time we have the final addresses */</font>
<font color="#a52a2a">1624</font>  <font color="#008b8b">+//     if (add_kallsyms(f, &amp;kallsyms, force_kallsyms))</font>
<font color="#a52a2a">1625</font>  <font color="#008b8b">+//             return 0;</font>
<font color="#a52a2a">1626</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1627</font>  <font color="#008b8b">+       init_module(m_name, f, m_size);</font>
<font color="#a52a2a">1628</font>  <font color="#008b8b">+/*     if (errors) {</font>
<font color="#a52a2a">1629</font>  <font color="#008b8b">+               delete_module(m_name);</font>
<font color="#a52a2a">1630</font>  <font color="#008b8b">+               return 0;</font>
<font color="#a52a2a">1631</font>  <font color="#008b8b">+       }*/</font>
<font color="#a52a2a">1632</font>  <font color="#008b8b">+       return 1;</font>
<font color="#a52a2a">1633</font>  <font color="#008b8b">+}</font>
<font color="#a52a2a">1634</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1635</font>  <font color="#008b8b">+void init_boot_modules(void)</font>
<font color="#a52a2a">1636</font>  <font color="#008b8b">+{</font>
<font color="#a52a2a">1637</font>  <font color="#008b8b">+       int i;</font>
<font color="#a52a2a">1638</font>  <font color="#008b8b">+       struct obj_file *f;</font>
<font color="#a52a2a">1639</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1640</font>  <font color="#008b8b">+       if(!mbootinfo)</font>
<font color="#a52a2a">1641</font>  <font color="#008b8b">+               return;</font>
<font color="#a52a2a">1642</font>  <font color="#008b8b">+       if(!(mbootinfo-&gt;flags &amp; 8))</font>
<font color="#a52a2a">1643</font>  <font color="#008b8b">+               return;</font>
<font color="#a52a2a">1644</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1645</font>  <font color="#008b8b">+       for(i=0;i&lt;mbootinfo-&gt;mods_count;i++) {</font>
<font color="#a52a2a">1646</font>  <font color="#008b8b">+               char *m_name;</font>
<font color="#a52a2a">1647</font>  <font color="#008b8b">+               struct multiboot_module *mod = &amp;mbootinfo-&gt;mods_addr[i];</font>
<font color="#a52a2a">1648</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1649</font>  <font color="#008b8b">+               for(m_name = mod-&gt;string;</font>
<font color="#a52a2a">1650</font>  <font color="#008b8b">+                   (*m_name != 0) &amp;&amp; (*m_name != ' ') &amp;&amp; (strncmp(m_name,&quot;.o&quot;,2) != 0);</font>
<font color="#a52a2a">1651</font>  <font color="#008b8b">+                   m_name++);</font>
<font color="#a52a2a">1652</font>  <font color="#008b8b">+               *m_name = 0;</font>
<font color="#a52a2a">1653</font>  <font color="#008b8b">+               for(;(m_name &gt; mod-&gt;string) &amp;&amp; (*m_name != '/');m_name--);</font>
<font color="#a52a2a">1654</font>  <font color="#008b8b">+               m_name++;</font>
<font color="#a52a2a">1655</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1656</font>  <font color="#008b8b">+               printk(KERN_INFO &quot;Ok Starting to load Module %s from addr 0x%x - 0x%x\n&quot;, m_name, mod-&gt;mod_start, mod-&gt;mod_end);</font>
<font color="#a52a2a">1657</font>  <font color="#008b8b">+               f = obj_load ((void *)mod-&gt;mod_start, mod-&gt;mod_end - mod-&gt;mod_start, ET_REL, mod-&gt;string);</font>
<font color="#a52a2a">1658</font>  <font color="#008b8b">+               if (!f) continue;</font>
<font color="#a52a2a">1659</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1660</font>  <font color="#008b8b">+               insert_module(f,m_name,0,0);</font>
<font color="#a52a2a">1661</font>  <font color="#008b8b">+               obj_free(f);</font>
<font color="#a52a2a">1662</font>  <font color="#008b8b">+       }</font>
<font color="#a52a2a">1663</font>  <font color="#008b8b">+}</font>
<font color="#a52a2a">1664</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1665</font>  <font color="#008b8b">+#endif</font>
<font color="#a52a2a">1666</font>  <font color="#2e8b57"><b>diff -urbN linux/kernel/obj_common.c linux.new/kernel/obj_common.c</b></font>
<font color="#a52a2a">1667</font>  <font color="#2e8b57"><b>--- linux/kernel/obj_common.c   Thu Jan  1 01:00:00 1970</b></font>
<font color="#a52a2a">1668</font>  <font color="#2e8b57"><b>+++ linux.new/kernel/obj_common.c       Wed Dec  5 23:24:38 2001</b></font>
<font color="#a52a2a">1669</font>  <font color="#a52a2a"><b>@@ -0,0 +1,424 @@</b></font>
<font color="#a52a2a">1670</font>  <font color="#008b8b">+/* Elf file, section, and symbol manipulation routines.</font>
<font color="#a52a2a">1671</font>  <font color="#008b8b">+   Copyright 1996, 1997 Linux International.</font>
<font color="#a52a2a">1672</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1673</font>  <font color="#008b8b">+   Contributed by Richard Henderson &lt;rth@tamu.edu&gt;</font>
<font color="#a52a2a">1674</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1675</font>  <font color="#008b8b">+   This file is part of the Linux modutils.</font>
<font color="#a52a2a">1676</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1677</font>  <font color="#008b8b">+   This program is free software; you can redistribute it and/or modify it</font>
<font color="#a52a2a">1678</font>  <font color="#008b8b">+   under the terms of the GNU General Public License as published by the</font>
<font color="#a52a2a">1679</font>  <font color="#008b8b">+   Free Software Foundation; either version 2 of the License, or (at your</font>
<font color="#a52a2a">1680</font>  <font color="#008b8b">+   option) any later version.</font>
<font color="#a52a2a">1681</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1682</font>  <font color="#008b8b">+   This program is distributed in the hope that it will be useful, but</font>
<font color="#a52a2a">1683</font>  <font color="#008b8b">+   WITHOUT ANY WARRANTY; without even the implied warranty of</font>
<font color="#a52a2a">1684</font>  <font color="#008b8b">+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</font>
<font color="#a52a2a">1685</font>  <font color="#008b8b">+   General Public License for more details.</font>
<font color="#a52a2a">1686</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1687</font>  <font color="#008b8b">+   You should have received a copy of the GNU General Public License</font>
<font color="#a52a2a">1688</font>  <font color="#008b8b">+   along with this program; if not, write to the Free Software Foundation,</font>
<font color="#a52a2a">1689</font>  <font color="#008b8b">+   Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.</font>
<font color="#a52a2a">1690</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1691</font>  <font color="#008b8b">+   Modified by Christian König (ChristianK.@t-online.de) to work inside the kernel*/</font>
<font color="#a52a2a">1692</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1693</font>  <font color="#008b8b">+#ident &quot;$Id: obj_common.c 1.4 Wed, 26 Sep 2001 11:58:34 +1000 kaos $&quot;</font>
<font color="#a52a2a">1694</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1695</font>  <font color="#008b8b">+#include &lt;linux/slab.h&gt;</font>
<font color="#a52a2a">1696</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1697</font>  <font color="#008b8b">+#include &lt;linux/obj_load.h&gt;</font>
<font color="#a52a2a">1698</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1699</font>  <font color="#008b8b">+/*======================================================================*/</font>
<font color="#a52a2a">1700</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1701</font>  <font color="#008b8b">+/* Standard ELF hash function.  */</font>
<font color="#a52a2a">1702</font>  <font color="#008b8b">+inline unsigned long</font>
<font color="#a52a2a">1703</font>  <font color="#008b8b">+obj_elf_hash_n(const char *name, unsigned long n)</font>
<font color="#a52a2a">1704</font>  <font color="#008b8b">+{</font>
<font color="#a52a2a">1705</font>  <font color="#008b8b">+  unsigned long h = 0;</font>
<font color="#a52a2a">1706</font>  <font color="#008b8b">+  unsigned long g;</font>
<font color="#a52a2a">1707</font>  <font color="#008b8b">+  unsigned char ch;</font>
<font color="#a52a2a">1708</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1709</font>  <font color="#008b8b">+  while (n &gt; 0)</font>
<font color="#a52a2a">1710</font>  <font color="#008b8b">+    {</font>
<font color="#a52a2a">1711</font>  <font color="#008b8b">+      ch = *name++;</font>
<font color="#a52a2a">1712</font>  <font color="#008b8b">+      h = (h &lt;&lt; 4) + ch;</font>
<font color="#a52a2a">1713</font>  <font color="#008b8b">+      if ((g = (h &amp; 0xf0000000)) != 0)</font>
<font color="#a52a2a">1714</font>  <font color="#008b8b">+       {</font>
<font color="#a52a2a">1715</font>  <font color="#008b8b">+         h ^= g &gt;&gt; 24;</font>
<font color="#a52a2a">1716</font>  <font color="#008b8b">+         h &amp;= ~g;</font>
<font color="#a52a2a">1717</font>  <font color="#008b8b">+       }</font>
<font color="#a52a2a">1718</font>  <font color="#008b8b">+      n--;</font>
<font color="#a52a2a">1719</font>  <font color="#008b8b">+    }</font>
<font color="#a52a2a">1720</font>  <font color="#008b8b">+  return h;</font>
<font color="#a52a2a">1721</font>  <font color="#008b8b">+}</font>
<font color="#a52a2a">1722</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1723</font>  <font color="#008b8b">+unsigned long</font>
<font color="#a52a2a">1724</font>  <font color="#008b8b">+obj_elf_hash (const char *name)</font>
<font color="#a52a2a">1725</font>  <font color="#008b8b">+{</font>
<font color="#a52a2a">1726</font>  <font color="#008b8b">+  return obj_elf_hash_n(name, strlen(name));</font>
<font color="#a52a2a">1727</font>  <font color="#008b8b">+}</font>
<font color="#a52a2a">1728</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1729</font>  <font color="#008b8b">+void</font>
<font color="#a52a2a">1730</font>  <font color="#008b8b">+obj_set_symbol_compare (struct obj_file *f,</font>
<font color="#a52a2a">1731</font>  <font color="#008b8b">+                       int (*cmp)(const char *, const char *),</font>
<font color="#a52a2a">1732</font>  <font color="#008b8b">+                       unsigned long (*hash)(const char *))</font>
<font color="#a52a2a">1733</font>  <font color="#008b8b">+{</font>
<font color="#a52a2a">1734</font>  <font color="#008b8b">+  if (cmp)</font>
<font color="#a52a2a">1735</font>  <font color="#008b8b">+    f-&gt;symbol_cmp = cmp;</font>
<font color="#a52a2a">1736</font>  <font color="#008b8b">+  if (hash)</font>
<font color="#a52a2a">1737</font>  <font color="#008b8b">+    {</font>
<font color="#a52a2a">1738</font>  <font color="#008b8b">+      struct obj_symbol *tmptab[HASH_BUCKETS], *sym, *next;</font>
<font color="#a52a2a">1739</font>  <font color="#008b8b">+      int i;</font>
<font color="#a52a2a">1740</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1741</font>  <font color="#008b8b">+      f-&gt;symbol_hash = hash;</font>
<font color="#a52a2a">1742</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1743</font>  <font color="#008b8b">+      memcpy(tmptab, f-&gt;symtab, sizeof(tmptab));</font>
<font color="#a52a2a">1744</font>  <font color="#008b8b">+      memset(f-&gt;symtab, 0, sizeof(f-&gt;symtab));</font>
<font color="#a52a2a">1745</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1746</font>  <font color="#008b8b">+      for (i = 0; i &lt; HASH_BUCKETS; ++i)</font>
<font color="#a52a2a">1747</font>  <font color="#008b8b">+       for (sym = tmptab[i]; sym ; sym = next)</font>
<font color="#a52a2a">1748</font>  <font color="#008b8b">+         {</font>
<font color="#a52a2a">1749</font>  <font color="#008b8b">+           unsigned long h = hash(sym-&gt;name) % HASH_BUCKETS;</font>
<font color="#a52a2a">1750</font>  <font color="#008b8b">+           next = sym-&gt;next;</font>
<font color="#a52a2a">1751</font>  <font color="#008b8b">+           sym-&gt;next = f-&gt;symtab[h];</font>
<font color="#a52a2a">1752</font>  <font color="#008b8b">+           f-&gt;symtab[h] = sym;</font>
<font color="#a52a2a">1753</font>  <font color="#008b8b">+         }</font>
<font color="#a52a2a">1754</font>  <font color="#008b8b">+    }</font>
<font color="#a52a2a">1755</font>  <font color="#008b8b">+}</font>
<font color="#a52a2a">1756</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1757</font>  <font color="#008b8b">+struct obj_symbol *</font>
<font color="#a52a2a">1758</font>  <font color="#008b8b">+obj_add_symbol (struct obj_file *f, const char *name, unsigned long symidx,</font>
<font color="#a52a2a">1759</font>  <font color="#008b8b">+               int info, int secidx, ElfW(Addr) value, unsigned long size)</font>
<font color="#a52a2a">1760</font>  <font color="#008b8b">+{</font>
<font color="#a52a2a">1761</font>  <font color="#008b8b">+  struct obj_symbol *sym;</font>
<font color="#a52a2a">1762</font>  <font color="#008b8b">+  unsigned long hash = f-&gt;symbol_hash(name) % HASH_BUCKETS;</font>
<font color="#a52a2a">1763</font>  <font color="#008b8b">+  int n_type = ELFW(ST_TYPE)(info);</font>
<font color="#a52a2a">1764</font>  <font color="#008b8b">+  int n_binding = ELFW(ST_BIND)(info);</font>
<font color="#a52a2a">1765</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1766</font>  <font color="#008b8b">+  for (sym = f-&gt;symtab[hash]; sym; sym = sym-&gt;next)</font>
<font color="#a52a2a">1767</font>  <font color="#008b8b">+    if (f-&gt;symbol_cmp(sym-&gt;name, name) == 0)</font>
<font color="#a52a2a">1768</font>  <font color="#008b8b">+      {</font>
<font color="#a52a2a">1769</font>  <font color="#008b8b">+       int o_secidx = sym-&gt;secidx;</font>
<font color="#a52a2a">1770</font>  <font color="#008b8b">+       int o_info = sym-&gt;info;</font>
<font color="#a52a2a">1771</font>  <font color="#008b8b">+       int o_type = ELFW(ST_TYPE)(o_info);</font>
<font color="#a52a2a">1772</font>  <font color="#008b8b">+       int o_binding = ELFW(ST_BIND)(o_info);</font>
<font color="#a52a2a">1773</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1774</font>  <font color="#008b8b">+       /* A redefinition!  Is it legal?  */</font>
<font color="#a52a2a">1775</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1776</font>  <font color="#008b8b">+       if (secidx == SHN_UNDEF)</font>
<font color="#a52a2a">1777</font>  <font color="#008b8b">+         return sym;</font>
<font color="#a52a2a">1778</font>  <font color="#008b8b">+       else if (o_secidx == SHN_UNDEF)</font>
<font color="#a52a2a">1779</font>  <font color="#008b8b">+         goto found;</font>
<font color="#a52a2a">1780</font>  <font color="#008b8b">+       else if (n_binding == STB_GLOBAL &amp;&amp; o_binding == STB_LOCAL)</font>
<font color="#a52a2a">1781</font>  <font color="#008b8b">+         {</font>
<font color="#a52a2a">1782</font>  <font color="#008b8b">+           /* Cope with local and global symbols of the same name</font>
<font color="#a52a2a">1783</font>  <font color="#008b8b">+              in the same object file, as might have been created</font>
<font color="#a52a2a">1784</font>  <font color="#008b8b">+              by ld -r.  The only reason locals are now seen at this</font>
<font color="#a52a2a">1785</font>  <font color="#008b8b">+              level at all is so that we can do semi-sensible things</font>
<font color="#a52a2a">1786</font>  <font color="#008b8b">+              with parameters.  */</font>
<font color="#a52a2a">1787</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1788</font>  <font color="#008b8b">+           struct obj_symbol *nsym, **p;</font>
<font color="#a52a2a">1789</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1790</font>  <font color="#008b8b">+           nsym = arch_new_symbol();</font>
<font color="#a52a2a">1791</font>  <font color="#008b8b">+           nsym-&gt;next = sym-&gt;next;</font>
<font color="#a52a2a">1792</font>  <font color="#008b8b">+           nsym-&gt;ksymidx = -1;</font>
<font color="#a52a2a">1793</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1794</font>  <font color="#008b8b">+           /* Excise the old (local) symbol from the hash chain.  */</font>
<font color="#a52a2a">1795</font>  <font color="#008b8b">+           for (p = &amp;f-&gt;symtab[hash]; *p != sym; p = &amp;(*p)-&gt;next)</font>
<font color="#a52a2a">1796</font>  <font color="#008b8b">+             continue;</font>
<font color="#a52a2a">1797</font>  <font color="#008b8b">+           *p = sym = nsym;</font>
<font color="#a52a2a">1798</font>  <font color="#008b8b">+           goto found;</font>
<font color="#a52a2a">1799</font>  <font color="#008b8b">+         }</font>
<font color="#a52a2a">1800</font>  <font color="#008b8b">+       else if (n_binding == STB_LOCAL)</font>
<font color="#a52a2a">1801</font>  <font color="#008b8b">+         {</font>
<font color="#a52a2a">1802</font>  <font color="#008b8b">+           /* Another symbol of the same name has already been defined.</font>
<font color="#a52a2a">1803</font>  <font color="#008b8b">+              Just add this to the local table.  */</font>
<font color="#a52a2a">1804</font>  <font color="#008b8b">+           sym = arch_new_symbol();</font>
<font color="#a52a2a">1805</font>  <font color="#008b8b">+           sym-&gt;next = NULL;</font>
<font color="#a52a2a">1806</font>  <font color="#008b8b">+           sym-&gt;ksymidx = -1;</font>
<font color="#a52a2a">1807</font>  <font color="#008b8b">+           f-&gt;local_symtab[symidx] = sym;</font>
<font color="#a52a2a">1808</font>  <font color="#008b8b">+           goto found;</font>
<font color="#a52a2a">1809</font>  <font color="#008b8b">+         }</font>
<font color="#a52a2a">1810</font>  <font color="#008b8b">+       else if (n_binding == STB_WEAK)</font>
<font color="#a52a2a">1811</font>  <font color="#008b8b">+         return sym;</font>
<font color="#a52a2a">1812</font>  <font color="#008b8b">+       else if (o_binding == STB_WEAK)</font>
<font color="#a52a2a">1813</font>  <font color="#008b8b">+         goto found;</font>
<font color="#a52a2a">1814</font>  <font color="#008b8b">+       /* Don't unify COMMON symbols with object types the programmer</font>
<font color="#a52a2a">1815</font>  <font color="#008b8b">+          doesn't expect.  */</font>
<font color="#a52a2a">1816</font>  <font color="#008b8b">+       else if (secidx == SHN_COMMON</font>
<font color="#a52a2a">1817</font>  <font color="#008b8b">+                &amp;&amp; (o_type == STT_NOTYPE || o_type == STT_OBJECT))</font>
<font color="#a52a2a">1818</font>  <font color="#008b8b">+         return sym;</font>
<font color="#a52a2a">1819</font>  <font color="#008b8b">+       else if (o_secidx == SHN_COMMON</font>
<font color="#a52a2a">1820</font>  <font color="#008b8b">+                &amp;&amp; (n_type == STT_NOTYPE || n_type == STT_OBJECT))</font>
<font color="#a52a2a">1821</font>  <font color="#008b8b">+         goto found;</font>
<font color="#a52a2a">1822</font>  <font color="#008b8b">+       else</font>
<font color="#a52a2a">1823</font>  <font color="#008b8b">+         {</font>
<font color="#a52a2a">1824</font>  <font color="#008b8b">+           /* Don't report an error if the symbol is coming from</font>
<font color="#a52a2a">1825</font>  <font color="#008b8b">+              the kernel or some external module.  */</font>
<font color="#a52a2a">1826</font>  <font color="#008b8b">+           if (secidx &lt;= SHN_HIRESERVE)</font>
<font color="#a52a2a">1827</font>  <font color="#008b8b">+             printk(KERN_INFO &quot;%s multiply defined&quot;, name);</font>
<font color="#a52a2a">1828</font>  <font color="#008b8b">+           return sym;</font>
<font color="#a52a2a">1829</font>  <font color="#008b8b">+         }</font>
<font color="#a52a2a">1830</font>  <font color="#008b8b">+      }</font>
<font color="#a52a2a">1831</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1832</font>  <font color="#008b8b">+  /* Completely new symbol.  */</font>
<font color="#a52a2a">1833</font>  <font color="#008b8b">+  sym = arch_new_symbol();</font>
<font color="#a52a2a">1834</font>  <font color="#008b8b">+  sym-&gt;next = f-&gt;symtab[hash];</font>
<font color="#a52a2a">1835</font>  <font color="#008b8b">+  f-&gt;symtab[hash] = sym;</font>
<font color="#a52a2a">1836</font>  <font color="#008b8b">+  sym-&gt;ksymidx = -1;</font>
<font color="#a52a2a">1837</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1838</font>  <font color="#008b8b">+  if (ELFW(ST_BIND)(info) == STB_LOCAL &amp;&amp; symidx != -1) {</font>
<font color="#a52a2a">1839</font>  <font color="#008b8b">+    if (symidx &gt;= f-&gt;local_symtab_size)</font>
<font color="#a52a2a">1840</font>  <font color="#008b8b">+      printk(KERN_INFO &quot;local symbol %s with index %ld exceeds local_symtab_size %ld&quot;,</font>
<font color="#a52a2a">1841</font>  <font color="#008b8b">+        name, (long) symidx, (long) f-&gt;local_symtab_size);</font>
<font color="#a52a2a">1842</font>  <font color="#008b8b">+    else</font>
<font color="#a52a2a">1843</font>  <font color="#008b8b">+      f-&gt;local_symtab[symidx] = sym;</font>
<font color="#a52a2a">1844</font>  <font color="#008b8b">+  }</font>
<font color="#a52a2a">1845</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1846</font>  <font color="#008b8b">+found:</font>
<font color="#a52a2a">1847</font>  <font color="#008b8b">+  sym-&gt;name = name;</font>
<font color="#a52a2a">1848</font>  <font color="#008b8b">+  sym-&gt;value = value;</font>
<font color="#a52a2a">1849</font>  <font color="#008b8b">+  sym-&gt;size = size;</font>
<font color="#a52a2a">1850</font>  <font color="#008b8b">+  sym-&gt;secidx = secidx;</font>
<font color="#a52a2a">1851</font>  <font color="#008b8b">+  sym-&gt;info = info;</font>
<font color="#a52a2a">1852</font>  <font color="#008b8b">+  sym-&gt;r_type = 0;     /* should be R_arch_NONE for all arch */</font>
<font color="#a52a2a">1853</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1854</font>  <font color="#008b8b">+  return sym;</font>
<font color="#a52a2a">1855</font>  <font color="#008b8b">+}</font>
<font color="#a52a2a">1856</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1857</font>  <font color="#008b8b">+struct obj_symbol *</font>
<font color="#a52a2a">1858</font>  <font color="#008b8b">+obj_find_symbol (struct obj_file *f, const char *name)</font>
<font color="#a52a2a">1859</font>  <font color="#008b8b">+{</font>
<font color="#a52a2a">1860</font>  <font color="#008b8b">+  struct obj_symbol *sym;</font>
<font color="#a52a2a">1861</font>  <font color="#008b8b">+  unsigned long hash = f-&gt;symbol_hash(name) % HASH_BUCKETS;</font>
<font color="#a52a2a">1862</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1863</font>  <font color="#008b8b">+  for (sym = f-&gt;symtab[hash]; sym; sym = sym-&gt;next)</font>
<font color="#a52a2a">1864</font>  <font color="#008b8b">+    if (f-&gt;symbol_cmp(sym-&gt;name, name) == 0)</font>
<font color="#a52a2a">1865</font>  <font color="#008b8b">+      return sym;</font>
<font color="#a52a2a">1866</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1867</font>  <font color="#008b8b">+  return NULL;</font>
<font color="#a52a2a">1868</font>  <font color="#008b8b">+}</font>
<font color="#a52a2a">1869</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1870</font>  <font color="#008b8b">+ElfW(Addr)</font>
<font color="#a52a2a">1871</font>  <font color="#008b8b">+obj_symbol_final_value (struct obj_file *f, struct obj_symbol *sym)</font>
<font color="#a52a2a">1872</font>  <font color="#008b8b">+{</font>
<font color="#a52a2a">1873</font>  <font color="#008b8b">+  if (sym)</font>
<font color="#a52a2a">1874</font>  <font color="#008b8b">+    {</font>
<font color="#a52a2a">1875</font>  <font color="#008b8b">+      if (sym-&gt;secidx &gt;= SHN_LORESERVE)</font>
<font color="#a52a2a">1876</font>  <font color="#008b8b">+       return sym-&gt;value;</font>
<font color="#a52a2a">1877</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1878</font>  <font color="#008b8b">+      return sym-&gt;value + f-&gt;sections[sym-&gt;secidx]-&gt;header.sh_addr;</font>
<font color="#a52a2a">1879</font>  <font color="#008b8b">+    }</font>
<font color="#a52a2a">1880</font>  <font color="#008b8b">+  else</font>
<font color="#a52a2a">1881</font>  <font color="#008b8b">+    {</font>
<font color="#a52a2a">1882</font>  <font color="#008b8b">+      /* As a special case, a NULL sym has value zero.  */</font>
<font color="#a52a2a">1883</font>  <font color="#008b8b">+      return 0;</font>
<font color="#a52a2a">1884</font>  <font color="#008b8b">+    }</font>
<font color="#a52a2a">1885</font>  <font color="#008b8b">+}</font>
<font color="#a52a2a">1886</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1887</font>  <font color="#008b8b">+struct obj_section *</font>
<font color="#a52a2a">1888</font>  <font color="#008b8b">+obj_find_section (struct obj_file *f, const char *name)</font>
<font color="#a52a2a">1889</font>  <font color="#008b8b">+{</font>
<font color="#a52a2a">1890</font>  <font color="#008b8b">+  int i, n = f-&gt;header.e_shnum;</font>
<font color="#a52a2a">1891</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1892</font>  <font color="#008b8b">+  for (i = 0; i &lt; n; ++i)</font>
<font color="#a52a2a">1893</font>  <font color="#008b8b">+    if (strcmp(f-&gt;sections[i]-&gt;name, name) == 0)</font>
<font color="#a52a2a">1894</font>  <font color="#008b8b">+      return f-&gt;sections[i];</font>
<font color="#a52a2a">1895</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1896</font>  <font color="#008b8b">+  return NULL;</font>
<font color="#a52a2a">1897</font>  <font color="#008b8b">+}</font>
<font color="#a52a2a">1898</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1899</font>  <font color="#008b8b">+#if defined (ARCH_alpha)</font>
<font color="#a52a2a">1900</font>  <font color="#008b8b">+#define ARCH_SHF_SHORT SHF_ALPHA_GPREL</font>
<font color="#a52a2a">1901</font>  <font color="#008b8b">+#elif defined (ARCH_ia64)</font>
<font color="#a52a2a">1902</font>  <font color="#008b8b">+#define ARCH_SHF_SHORT SHF_IA_64_SHORT</font>
<font color="#a52a2a">1903</font>  <font color="#008b8b">+#else</font>
<font color="#a52a2a">1904</font>  <font color="#008b8b">+#define ARCH_SHF_SHORT 0</font>
<font color="#a52a2a">1905</font>  <font color="#008b8b">+#endif</font>
<font color="#a52a2a">1906</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1907</font>  <font color="#008b8b">+static int</font>
<font color="#a52a2a">1908</font>  <font color="#008b8b">+obj_load_order_prio(struct obj_section *a)</font>
<font color="#a52a2a">1909</font>  <font color="#008b8b">+{</font>
<font color="#a52a2a">1910</font>  <font color="#008b8b">+  unsigned long af, ac;</font>
<font color="#a52a2a">1911</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1912</font>  <font color="#008b8b">+  af = a-&gt;header.sh_flags;</font>
<font color="#a52a2a">1913</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1914</font>  <font color="#008b8b">+  ac = 0;</font>
<font color="#a52a2a">1915</font>  <font color="#008b8b">+  if (a-&gt;name[0] != '.'</font>
<font color="#a52a2a">1916</font>  <font color="#008b8b">+      || strlen(a-&gt;name) != 10</font>
<font color="#a52a2a">1917</font>  <font color="#008b8b">+      || strcmp(a-&gt;name + 5, &quot;.init&quot;))</font>
<font color="#a52a2a">1918</font>  <font color="#008b8b">+    ac |= 64;</font>
<font color="#a52a2a">1919</font>  <font color="#008b8b">+  if (af &amp; SHF_ALLOC) ac |= 32;</font>
<font color="#a52a2a">1920</font>  <font color="#008b8b">+  if (af &amp; SHF_EXECINSTR) ac |= 16;</font>
<font color="#a52a2a">1921</font>  <font color="#008b8b">+  if (!(af &amp; SHF_WRITE)) ac |= 8;</font>
<font color="#a52a2a">1922</font>  <font color="#008b8b">+  if (a-&gt;header.sh_type != SHT_NOBITS) ac |= 4;</font>
<font color="#a52a2a">1923</font>  <font color="#008b8b">+  /* Desired order is</font>
<font color="#a52a2a">1924</font>  <font color="#008b8b">+               P S  AC &amp; 7</font>
<font color="#a52a2a">1925</font>  <font color="#008b8b">+       .data   1 0  4</font>
<font color="#a52a2a">1926</font>  <font color="#008b8b">+       .got    1 1  3</font>
<font color="#a52a2a">1927</font>  <font color="#008b8b">+       .sdata  1 1  1</font>
<font color="#a52a2a">1928</font>  <font color="#008b8b">+       .sbss   0 1  1</font>
<font color="#a52a2a">1929</font>  <font color="#008b8b">+       .bss    0 0  0  */</font>
<font color="#a52a2a">1930</font>  <font color="#008b8b">+  if (strcmp (a-&gt;name, &quot;.got&quot;) == 0) ac |= 2;</font>
<font color="#a52a2a">1931</font>  <font color="#008b8b">+  if (af &amp; ARCH_SHF_SHORT)</font>
<font color="#a52a2a">1932</font>  <font color="#008b8b">+    ac = (ac &amp; ~4) | 1;</font>
<font color="#a52a2a">1933</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1934</font>  <font color="#008b8b">+  return ac;</font>
<font color="#a52a2a">1935</font>  <font color="#008b8b">+}</font>
<font color="#a52a2a">1936</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1937</font>  <font color="#008b8b">+void</font>
<font color="#a52a2a">1938</font>  <font color="#008b8b">+obj_insert_section_load_order (struct obj_file *f, struct obj_section *sec)</font>
<font color="#a52a2a">1939</font>  <font color="#008b8b">+{</font>
<font color="#a52a2a">1940</font>  <font color="#008b8b">+  struct obj_section **p;</font>
<font color="#a52a2a">1941</font>  <font color="#008b8b">+  int prio = obj_load_order_prio(sec);</font>
<font color="#a52a2a">1942</font>  <font color="#008b8b">+  for (p = f-&gt;load_order_search_start; *p ; p = &amp;(*p)-&gt;load_next)</font>
<font color="#a52a2a">1943</font>  <font color="#008b8b">+    if (obj_load_order_prio(*p) &lt; prio)</font>
<font color="#a52a2a">1944</font>  <font color="#008b8b">+      break;</font>
<font color="#a52a2a">1945</font>  <font color="#008b8b">+  sec-&gt;load_next = *p;</font>
<font color="#a52a2a">1946</font>  <font color="#008b8b">+  *p = sec;</font>
<font color="#a52a2a">1947</font>  <font color="#008b8b">+}</font>
<font color="#a52a2a">1948</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1949</font>  <font color="#008b8b">+static void *realloc(void *ptr, unsigned int size, unsigned int oldsize)</font>
<font color="#a52a2a">1950</font>  <font color="#008b8b">+{</font>
<font color="#a52a2a">1951</font>  <font color="#008b8b">+       void *new;</font>
<font color="#a52a2a">1952</font>  <font color="#008b8b">+       new = kmalloc(size, GFP_KERNEL);</font>
<font color="#a52a2a">1953</font>  <font color="#008b8b">+       memcpy(new, ptr, oldsize);</font>
<font color="#a52a2a">1954</font>  <font color="#008b8b">+       kfree(ptr);</font>
<font color="#a52a2a">1955</font>  <font color="#008b8b">+       return new;</font>
<font color="#a52a2a">1956</font>  <font color="#008b8b">+}</font>
<font color="#a52a2a">1957</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1958</font>  <font color="#008b8b">+struct obj_section *</font>
<font color="#a52a2a">1959</font>  <font color="#008b8b">+obj_create_alloced_section (struct obj_file *f, const char *name,</font>
<font color="#a52a2a">1960</font>  <font color="#008b8b">+                           unsigned long align, unsigned long size,</font>
<font color="#a52a2a">1961</font>  <font color="#008b8b">+                           unsigned long flags)</font>
<font color="#a52a2a">1962</font>  <font color="#008b8b">+{</font>
<font color="#a52a2a">1963</font>  <font color="#008b8b">+  int newidx = f-&gt;header.e_shnum++;</font>
<font color="#a52a2a">1964</font>  <font color="#008b8b">+  struct obj_section *sec;</font>
<font color="#a52a2a">1965</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1966</font>  <font color="#008b8b">+  f-&gt;sections = realloc(f-&gt;sections, (newidx+1) * sizeof(sec), newidx * sizeof(sec));</font>
<font color="#a52a2a">1967</font>  <font color="#008b8b">+  f-&gt;sections[newidx] = sec = arch_new_section();</font>
<font color="#a52a2a">1968</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1969</font>  <font color="#008b8b">+  memset(sec, 0, sizeof(*sec));</font>
<font color="#a52a2a">1970</font>  <font color="#008b8b">+  sec-&gt;header.sh_type = SHT_PROGBITS;</font>
<font color="#a52a2a">1971</font>  <font color="#008b8b">+  sec-&gt;header.sh_flags = flags | SHF_ALLOC;</font>
<font color="#a52a2a">1972</font>  <font color="#008b8b">+  sec-&gt;header.sh_size = size;</font>
<font color="#a52a2a">1973</font>  <font color="#008b8b">+  sec-&gt;header.sh_addralign = align;</font>
<font color="#a52a2a">1974</font>  <font color="#008b8b">+  sec-&gt;name = name;</font>
<font color="#a52a2a">1975</font>  <font color="#008b8b">+  sec-&gt;idx = newidx;</font>
<font color="#a52a2a">1976</font>  <font color="#008b8b">+  if (size)</font>
<font color="#a52a2a">1977</font>  <font color="#008b8b">+    sec-&gt;contents = kmalloc(size, GFP_KERNEL);</font>
<font color="#a52a2a">1978</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1979</font>  <font color="#008b8b">+  obj_insert_section_load_order(f, sec);</font>
<font color="#a52a2a">1980</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1981</font>  <font color="#008b8b">+  return sec;</font>
<font color="#a52a2a">1982</font>  <font color="#008b8b">+}</font>
<font color="#a52a2a">1983</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1984</font>  <font color="#008b8b">+struct obj_section *</font>
<font color="#a52a2a">1985</font>  <font color="#008b8b">+obj_create_alloced_section_first (struct obj_file *f, const char *name,</font>
<font color="#a52a2a">1986</font>  <font color="#008b8b">+                                 unsigned long align, unsigned long size)</font>
<font color="#a52a2a">1987</font>  <font color="#008b8b">+{</font>
<font color="#a52a2a">1988</font>  <font color="#008b8b">+  int newidx = f-&gt;header.e_shnum++;</font>
<font color="#a52a2a">1989</font>  <font color="#008b8b">+  struct obj_section *sec;</font>
<font color="#a52a2a">1990</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1991</font>  <font color="#008b8b">+  f-&gt;sections = realloc(f-&gt;sections, (newidx+1) * sizeof(sec), newidx * sizeof(sec));</font>
<font color="#a52a2a">1992</font>  <font color="#008b8b">+  f-&gt;sections[newidx] = sec = arch_new_section();</font>
<font color="#a52a2a">1993</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">1994</font>  <font color="#008b8b">+  memset(sec, 0, sizeof(*sec));</font>
<font color="#a52a2a">1995</font>  <font color="#008b8b">+  sec-&gt;header.sh_type = SHT_PROGBITS;</font>
<font color="#a52a2a">1996</font>  <font color="#008b8b">+  sec-&gt;header.sh_flags = SHF_WRITE|SHF_ALLOC;</font>
<font color="#a52a2a">1997</font>  <font color="#008b8b">+  sec-&gt;header.sh_size = size;</font>
<font color="#a52a2a">1998</font>  <font color="#008b8b">+  sec-&gt;header.sh_addralign = align;</font>
<font color="#a52a2a">1999</font>  <font color="#008b8b">+  sec-&gt;name = name;</font>
<font color="#a52a2a">2000</font>  <font color="#008b8b">+  sec-&gt;idx = newidx;</font>
<font color="#a52a2a">2001</font>  <font color="#008b8b">+  if (size)</font>
<font color="#a52a2a">2002</font>  <font color="#008b8b">+    sec-&gt;contents = kmalloc(size, GFP_KERNEL);</font>
<font color="#a52a2a">2003</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">2004</font>  <font color="#008b8b">+  sec-&gt;load_next = f-&gt;load_order;</font>
<font color="#a52a2a">2005</font>  <font color="#008b8b">+  f-&gt;load_order = sec;</font>
<font color="#a52a2a">2006</font>  <font color="#008b8b">+  if (f-&gt;load_order_search_start == &amp;f-&gt;load_order)</font>
<font color="#a52a2a">2007</font>  <font color="#008b8b">+    f-&gt;load_order_search_start = &amp;sec-&gt;load_next;</font>
<font color="#a52a2a">2008</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">2009</font>  <font color="#008b8b">+  return sec;</font>
<font color="#a52a2a">2010</font>  <font color="#008b8b">+}</font>
<font color="#a52a2a">2011</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">2012</font>  <font color="#008b8b">+void *</font>
<font color="#a52a2a">2013</font>  <font color="#008b8b">+obj_extend_section (struct obj_section *sec, unsigned long more)</font>
<font color="#a52a2a">2014</font>  <font color="#008b8b">+{</font>
<font color="#a52a2a">2015</font>  <font color="#008b8b">+  unsigned long oldsize = sec-&gt;header.sh_size;</font>
<font color="#a52a2a">2016</font>  <font color="#008b8b">+  sec-&gt;contents = realloc(sec-&gt;contents, sec-&gt;header.sh_size += more, oldsize);</font>
<font color="#a52a2a">2017</font>  <font color="#008b8b">+  return sec-&gt;contents + oldsize;</font>
<font color="#a52a2a">2018</font>  <font color="#008b8b">+}</font>
<font color="#a52a2a">2019</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">2020</font>  <font color="#008b8b">+/* Convert an object pointer (address) to a native pointer and vice versa.</font>
<font color="#a52a2a">2021</font>  <font color="#008b8b">+ * It gets interesting when the object has 64 bit pointers but modutils</font>
<font color="#a52a2a">2022</font>  <font color="#008b8b">+ * is running 32 bit.  This is nasty code but it stops the compiler giving</font>
<font color="#a52a2a">2023</font>  <font color="#008b8b">+ * spurious warning messages.  &quot;I know what I am doing&quot; ...</font>
<font color="#a52a2a">2024</font>  <font color="#008b8b">+ */</font>
<font color="#a52a2a">2025</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">2026</font>  <font color="#008b8b">+void *</font>
<font color="#a52a2a">2027</font>  <font color="#008b8b">+obj_addr_to_native_ptr (ElfW(Addr) addr)</font>
<font color="#a52a2a">2028</font>  <font color="#008b8b">+{</font>
<font color="#a52a2a">2029</font>  <font color="#008b8b">+       unsigned int convert = (sizeof(void *) &lt;&lt; 8) + sizeof(addr);    /* to, from */</font>
<font color="#a52a2a">2030</font>  <font color="#008b8b">+       union obj_ptr_4 p4;</font>
<font color="#a52a2a">2031</font>  <font color="#008b8b">+       union obj_ptr_8 p8;</font>
<font color="#a52a2a">2032</font>  <font color="#008b8b">+       switch (convert) {</font>
<font color="#a52a2a">2033</font>  <font color="#008b8b">+       case 0x0404:</font>
<font color="#a52a2a">2034</font>  <font color="#008b8b">+               p4.addr = addr;</font>
<font color="#a52a2a">2035</font>  <font color="#008b8b">+               return(p4.ptr);</font>
<font color="#a52a2a">2036</font>  <font color="#008b8b">+               break;</font>
<font color="#a52a2a">2037</font>  <font color="#008b8b">+       case 0x0408:</font>
<font color="#a52a2a">2038</font>  <font color="#008b8b">+               p4.addr = addr;</font>
<font color="#a52a2a">2039</font>  <font color="#008b8b">+               if (p4.addr != addr) {</font>
<font color="#a52a2a">2040</font>  <font color="#008b8b">+                       printk(KERN_INFO &quot;obj_addr_to_native_ptr truncation %lx&quot;,</font>
<font color="#a52a2a">2041</font>  <font color="#008b8b">+                               (unsigned long) addr);</font>
<font color="#a52a2a">2042</font>  <font color="#008b8b">+                       return NULL;</font>
<font color="#a52a2a">2043</font>  <font color="#008b8b">+               }</font>
<font color="#a52a2a">2044</font>  <font color="#008b8b">+               return(p4.ptr);</font>
<font color="#a52a2a">2045</font>  <font color="#008b8b">+               break;</font>
<font color="#a52a2a">2046</font>  <font color="#008b8b">+       case 0x0804:</font>
<font color="#a52a2a">2047</font>  <font color="#008b8b">+               p8.addr = addr;</font>
<font color="#a52a2a">2048</font>  <font color="#008b8b">+               return(p8.ptr);</font>
<font color="#a52a2a">2049</font>  <font color="#008b8b">+               break;</font>
<font color="#a52a2a">2050</font>  <font color="#008b8b">+       case 0x0808:</font>
<font color="#a52a2a">2051</font>  <font color="#008b8b">+               p8.addr = addr;</font>
<font color="#a52a2a">2052</font>  <font color="#008b8b">+               return(p8.ptr);</font>
<font color="#a52a2a">2053</font>  <font color="#008b8b">+               break;</font>
<font color="#a52a2a">2054</font>  <font color="#008b8b">+       default:</font>
<font color="#a52a2a">2055</font>  <font color="#008b8b">+               printk(KERN_INFO &quot;obj_addr_to_native_ptr unknown conversion 0x%04x&quot;, convert);</font>
<font color="#a52a2a">2056</font>  <font color="#008b8b">+               return NULL;</font>
<font color="#a52a2a">2057</font>  <font color="#008b8b">+       }</font>
<font color="#a52a2a">2058</font>  <font color="#008b8b">+}</font>
<font color="#a52a2a">2059</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">2060</font>  <font color="#008b8b">+ElfW(Addr)</font>
<font color="#a52a2a">2061</font>  <font color="#008b8b">+obj_native_ptr_to_addr (void *ptr)</font>
<font color="#a52a2a">2062</font>  <font color="#008b8b">+{</font>
<font color="#a52a2a">2063</font>  <font color="#008b8b">+       unsigned int convert = (sizeof(ElfW(Addr)) &lt;&lt; 8) + sizeof(ptr); /* to, from */</font>
<font color="#a52a2a">2064</font>  <font color="#008b8b">+       union obj_ptr_4 p4;</font>
<font color="#a52a2a">2065</font>  <font color="#008b8b">+       union obj_ptr_8 p8;</font>
<font color="#a52a2a">2066</font>  <font color="#008b8b">+       switch (convert) {</font>
<font color="#a52a2a">2067</font>  <font color="#008b8b">+       case 0x0404:</font>
<font color="#a52a2a">2068</font>  <font color="#008b8b">+               p4.ptr = ptr;</font>
<font color="#a52a2a">2069</font>  <font color="#008b8b">+               return(p4.addr);</font>
<font color="#a52a2a">2070</font>  <font color="#008b8b">+               break;</font>
<font color="#a52a2a">2071</font>  <font color="#008b8b">+       case 0x0408:</font>
<font color="#a52a2a">2072</font>  <font color="#008b8b">+               p8.ptr = ptr;</font>
<font color="#a52a2a">2073</font>  <font color="#008b8b">+               p4.addr = p8.addr;</font>
<font color="#a52a2a">2074</font>  <font color="#008b8b">+               if (p4.addr != p8.addr) {</font>
<font color="#a52a2a">2075</font>  <font color="#008b8b">+                       printk(KERN_INFO &quot;obj_native_ptr_to_addr truncation %x&quot;,</font>
<font color="#a52a2a">2076</font>  <font color="#008b8b">+                               p8.addr);</font>
<font color="#a52a2a">2077</font>  <font color="#008b8b">+                       return 0;</font>
<font color="#a52a2a">2078</font>  <font color="#008b8b">+               }</font>
<font color="#a52a2a">2079</font>  <font color="#008b8b">+               return(p4.addr);</font>
<font color="#a52a2a">2080</font>  <font color="#008b8b">+               break;</font>
<font color="#a52a2a">2081</font>  <font color="#008b8b">+       case 0x0804:</font>
<font color="#a52a2a">2082</font>  <font color="#008b8b">+               p4.ptr = ptr;</font>
<font color="#a52a2a">2083</font>  <font color="#008b8b">+               return(p4.addr);        /* compiler expands to 8 */</font>
<font color="#a52a2a">2084</font>  <font color="#008b8b">+               break;</font>
<font color="#a52a2a">2085</font>  <font color="#008b8b">+       case 0x0808:</font>
<font color="#a52a2a">2086</font>  <font color="#008b8b">+               p8.ptr = ptr;</font>
<font color="#a52a2a">2087</font>  <font color="#008b8b">+               return(p8.addr);</font>
<font color="#a52a2a">2088</font>  <font color="#008b8b">+               break;</font>
<font color="#a52a2a">2089</font>  <font color="#008b8b">+       default:</font>
<font color="#a52a2a">2090</font>  <font color="#008b8b">+               printk(KERN_INFO &quot;obj_native_ptr_to_addr unknown conversion 0x%04x&quot;, convert);</font>
<font color="#a52a2a">2091</font>  <font color="#008b8b">+               return 0;</font>
<font color="#a52a2a">2092</font>  <font color="#008b8b">+       }</font>
<font color="#a52a2a">2093</font>  <font color="#008b8b">+}</font>
<font color="#a52a2a">2094</font>  <font color="#2e8b57"><b>diff -urbN linux/kernel/obj_gpl_license.c linux.new/kernel/obj_gpl_license.c</b></font>
<font color="#a52a2a">2095</font>  <font color="#2e8b57"><b>--- linux/kernel/obj_gpl_license.c      Thu Jan  1 01:00:00 1970</b></font>
<font color="#a52a2a">2096</font>  <font color="#2e8b57"><b>+++ linux.new/kernel/obj_gpl_license.c  Wed Dec  5 23:24:47 2001</b></font>
<font color="#a52a2a">2097</font>  <font color="#a52a2a"><b>@@ -0,0 +1,63 @@</b></font>
<font color="#a52a2a">2098</font>  <font color="#008b8b">+/* Return the type of license for a module.  0 for GPL, 1 for no license, 2 for</font>
<font color="#a52a2a">2099</font>  <font color="#008b8b">+   non-GPL.  The license parameter is set to the license string or NULL.</font>
<font color="#a52a2a">2100</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">2101</font>  <font color="#008b8b">+   This file is part of the Linux modutils.</font>
<font color="#a52a2a">2102</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">2103</font>  <font color="#008b8b">+   This program is free software; you can redistribute it and/or modify it</font>
<font color="#a52a2a">2104</font>  <font color="#008b8b">+   under the terms of the GNU General Public License as published by the</font>
<font color="#a52a2a">2105</font>  <font color="#008b8b">+   Free Software Foundation; either version 2 of the License, or (at your</font>
<font color="#a52a2a">2106</font>  <font color="#008b8b">+   option) any later version.</font>
<font color="#a52a2a">2107</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">2108</font>  <font color="#008b8b">+   This program is distributed in the hope that it will be useful, but</font>
<font color="#a52a2a">2109</font>  <font color="#008b8b">+   WITHOUT ANY WARRANTY; without even the implied warranty of</font>
<font color="#a52a2a">2110</font>  <font color="#008b8b">+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</font>
<font color="#a52a2a">2111</font>  <font color="#008b8b">+   General Public License for more details.</font>
<font color="#a52a2a">2112</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">2113</font>  <font color="#008b8b">+   You should have received a copy of the GNU General Public License</font>
<font color="#a52a2a">2114</font>  <font color="#008b8b">+   along with this program; if not, write to the Free Software Foundation,</font>
<font color="#a52a2a">2115</font>  <font color="#008b8b">+   Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.</font>
<font color="#a52a2a">2116</font>  <font color="#008b8b">+  */</font>
<font color="#a52a2a">2117</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">2118</font>  <font color="#008b8b">+#include &lt;linux/kernel.h&gt;</font>
<font color="#a52a2a">2119</font>  <font color="#008b8b">+#include &lt;linux/stddef.h&gt;</font>
<font color="#a52a2a">2120</font>  <font color="#008b8b">+#include &lt;linux/slab.h&gt;</font>
<font color="#a52a2a">2121</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">2122</font>  <font color="#008b8b">+#include &lt;linux/obj_load.h&gt;</font>
<font color="#a52a2a">2123</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">2124</font>  <font color="#008b8b">+/* This list must match *exactly* the list of allowable licenses in</font>
<font color="#a52a2a">2125</font>  <font color="#008b8b">+ * linux/include/linux/module.h.  Checking for leading &quot;GPL&quot; will not</font>
<font color="#a52a2a">2126</font>  <font color="#008b8b">+ * work, somebody will use &quot;GPL sucks, this is proprietary&quot;.</font>
<font color="#a52a2a">2127</font>  <font color="#008b8b">+ */</font>
<font color="#a52a2a">2128</font>  <font color="#008b8b">+static const char *gpl_licenses[] = {</font>
<font color="#a52a2a">2129</font>  <font color="#008b8b">+       &quot;GPL&quot;,</font>
<font color="#a52a2a">2130</font>  <font color="#008b8b">+       &quot;GPL and additional rights&quot;,</font>
<font color="#a52a2a">2131</font>  <font color="#008b8b">+       &quot;Dual BSD/GPL&quot;,</font>
<font color="#a52a2a">2132</font>  <font color="#008b8b">+       &quot;Dual MPL/GPL&quot;,</font>
<font color="#a52a2a">2133</font>  <font color="#008b8b">+};</font>
<font color="#a52a2a">2134</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">2135</font>  <font color="#008b8b">+int obj_gpl_license(struct obj_file *f, const char **license)</font>
<font color="#a52a2a">2136</font>  <font color="#008b8b">+{</font>
<font color="#a52a2a">2137</font>  <font color="#008b8b">+       struct obj_section *sec;</font>
<font color="#a52a2a">2138</font>  <font color="#008b8b">+       if ((sec = obj_find_section(f, &quot;.modinfo&quot;))) {</font>
<font color="#a52a2a">2139</font>  <font color="#008b8b">+               const char *value, *ptr, *endptr;</font>
<font color="#a52a2a">2140</font>  <font color="#008b8b">+               ptr = sec-&gt;contents;</font>
<font color="#a52a2a">2141</font>  <font color="#008b8b">+               endptr = ptr + sec-&gt;header.sh_size;</font>
<font color="#a52a2a">2142</font>  <font color="#008b8b">+               while (ptr &lt; endptr) {</font>
<font color="#a52a2a">2143</font>  <font color="#008b8b">+                       if ((value = strchr(ptr, '=')) &amp;&amp; strncmp(ptr, &quot;license&quot;, value-ptr) == 0) {</font>
<font color="#a52a2a">2144</font>  <font color="#008b8b">+                               int i;</font>
<font color="#a52a2a">2145</font>  <font color="#008b8b">+                               if (license)</font>
<font color="#a52a2a">2146</font>  <font color="#008b8b">+                                       *license = value+1;</font>
<font color="#a52a2a">2147</font>  <font color="#008b8b">+                               for (i = 0; i &lt; sizeof(gpl_licenses)/sizeof(gpl_licenses[0]); ++i) {</font>
<font color="#a52a2a">2148</font>  <font color="#008b8b">+                                       if (strcmp(value+1, gpl_licenses[i]) == 0)</font>
<font color="#a52a2a">2149</font>  <font color="#008b8b">+                                               return(0);</font>
<font color="#a52a2a">2150</font>  <font color="#008b8b">+                               }</font>
<font color="#a52a2a">2151</font>  <font color="#008b8b">+                               return(2);</font>
<font color="#a52a2a">2152</font>  <font color="#008b8b">+                       }</font>
<font color="#a52a2a">2153</font>  <font color="#008b8b">+                       if (strchr(ptr, '\0'))</font>
<font color="#a52a2a">2154</font>  <font color="#008b8b">+                               ptr = strchr(ptr, '\0') + 1;</font>
<font color="#a52a2a">2155</font>  <font color="#008b8b">+                       else</font>
<font color="#a52a2a">2156</font>  <font color="#008b8b">+                               ptr = endptr;</font>
<font color="#a52a2a">2157</font>  <font color="#008b8b">+               }</font>
<font color="#a52a2a">2158</font>  <font color="#008b8b">+       }</font>
<font color="#a52a2a">2159</font>  <font color="#008b8b">+       return(1);</font>
<font color="#a52a2a">2160</font>  <font color="#008b8b">+}</font>
<font color="#a52a2a">2161</font>  <font color="#2e8b57"><b>diff -urbN linux/kernel/obj_load.c linux.new/kernel/obj_load.c</b></font>
<font color="#a52a2a">2162</font>  <font color="#2e8b57"><b>--- linux/kernel/obj_load.c     Thu Jan  1 01:00:00 1970</b></font>
<font color="#a52a2a">2163</font>  <font color="#2e8b57"><b>+++ linux.new/kernel/obj_load.c Wed Dec  5 23:24:53 2001</b></font>
<font color="#a52a2a">2164</font>  <font color="#a52a2a"><b>@@ -0,0 +1,366 @@</b></font>
<font color="#a52a2a">2165</font>  <font color="#008b8b">+/* Elf file reader.</font>
<font color="#a52a2a">2166</font>  <font color="#008b8b">+   Copyright 1996, 1997 Linux International.</font>
<font color="#a52a2a">2167</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">2168</font>  <font color="#008b8b">+   Contributed by Richard Henderson &lt;rth@tamu.edu&gt;</font>
<font color="#a52a2a">2169</font>  <font color="#008b8b">+   obj_free() added by Björn Ekwall &lt;bj0rn@blox.se&gt; March 1999</font>
<font color="#a52a2a">2170</font>  <font color="#008b8b">+   Support for kallsyms Keith Owens &lt;kaos@ocs.com.au&gt; April 2000</font>
<font color="#a52a2a">2171</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">2172</font>  <font color="#008b8b">+   This file is part of the Linux modutils.</font>
<font color="#a52a2a">2173</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">2174</font>  <font color="#008b8b">+   This program is free software; you can redistribute it and/or modify it</font>
<font color="#a52a2a">2175</font>  <font color="#008b8b">+   under the terms of the GNU General Public License as published by the</font>
<font color="#a52a2a">2176</font>  <font color="#008b8b">+   Free Software Foundation; either version 2 of the License, or (at your</font>
<font color="#a52a2a">2177</font>  <font color="#008b8b">+   option) any later version.</font>
<font color="#a52a2a">2178</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">2179</font>  <font color="#008b8b">+   This program is distributed in the hope that it will be useful, but</font>
<font color="#a52a2a">2180</font>  <font color="#008b8b">+   WITHOUT ANY WARRANTY; without even the implied warranty of</font>
<font color="#a52a2a">2181</font>  <font color="#008b8b">+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</font>
<font color="#a52a2a">2182</font>  <font color="#008b8b">+   General Public License for more details.</font>
<font color="#a52a2a">2183</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">2184</font>  <font color="#008b8b">+   You should have received a copy of the GNU General Public License</font>
<font color="#a52a2a">2185</font>  <font color="#008b8b">+   along with this program; if not, write to the Free Software Foundation,</font>
<font color="#a52a2a">2186</font>  <font color="#008b8b">+   Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.</font>
<font color="#a52a2a">2187</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">2188</font>  <font color="#008b8b">+   Modified by Christian König (ChristianK.@t-online.de) to work inside the kernel*/</font>
<font color="#a52a2a">2189</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">2190</font>  <font color="#008b8b">+#ident &quot;$Id: obj_load.c 1.4 Wed, 26 Sep 2001 14:50:45 +1000 kaos $&quot;</font>
<font color="#a52a2a">2191</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">2192</font>  <font color="#008b8b">+#include &lt;linux/kernel.h&gt;</font>
<font color="#a52a2a">2193</font>  <font color="#008b8b">+#include &lt;linux/stddef.h&gt;</font>
<font color="#a52a2a">2194</font>  <font color="#008b8b">+#include &lt;linux/slab.h&gt;</font>
<font color="#a52a2a">2195</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">2196</font>  <font color="#008b8b">+#include &lt;linux/obj_load.h&gt;</font>
<font color="#a52a2a">2197</font>  <font color="#008b8b">+//#include &quot;util.h&quot;</font>
<font color="#a52a2a">2198</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">2199</font>  <font color="#008b8b">+/*======================================================================*/</font>
<font color="#a52a2a">2200</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">2201</font>  <font color="#008b8b">+int memcpy_chk(void *src, unsigned int size, int index, void *dst, int dstsize)</font>
<font color="#a52a2a">2202</font>  <font color="#008b8b">+{</font>
<font color="#a52a2a">2203</font>  <font color="#008b8b">+       if((size-index) &lt; dstsize)</font>
<font color="#a52a2a">2204</font>  <font color="#008b8b">+               return 0;</font>
<font color="#a52a2a">2205</font>  <font color="#008b8b">+       memcpy(dst, src + index, dstsize);</font>
<font color="#a52a2a">2206</font>  <font color="#008b8b">+       return dstsize;</font>
<font color="#a52a2a">2207</font>  <font color="#008b8b">+}</font>
<font color="#a52a2a">2208</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">2209</font>  <font color="#008b8b">+struct obj_file *</font>
<font color="#a52a2a">2210</font>  <font color="#008b8b">+obj_load (void *modmem, unsigned int modsize, Elf32_Half e_type, const char *filename)</font>
<font color="#a52a2a">2211</font>  <font color="#008b8b">+{</font>
<font color="#a52a2a">2212</font>  <font color="#008b8b">+  struct obj_file *f;</font>
<font color="#a52a2a">2213</font>  <font color="#008b8b">+  ElfW(Shdr) *section_headers;</font>
<font color="#a52a2a">2214</font>  <font color="#008b8b">+  int shnum, i;</font>
<font color="#a52a2a">2215</font>  <font color="#008b8b">+  char *shstrtab;</font>
<font color="#a52a2a">2216</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">2217</font>  <font color="#008b8b">+  /* Read the file header.  */</font>
<font color="#a52a2a">2218</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">2219</font>  <font color="#008b8b">+  f = arch_new_file();</font>
<font color="#a52a2a">2220</font>  <font color="#008b8b">+  memset(f, 0, sizeof(*f));</font>
<font color="#a52a2a">2221</font>  <font color="#008b8b">+  f-&gt;symbol_cmp = strcmp;</font>
<font color="#a52a2a">2222</font>  <font color="#008b8b">+  f-&gt;symbol_hash = obj_elf_hash;</font>
<font color="#a52a2a">2223</font>  <font color="#008b8b">+  f-&gt;load_order_search_start = &amp;f-&gt;load_order;</font>
<font color="#a52a2a">2224</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">2225</font>  <font color="#008b8b">+  if (memcpy_chk(modmem, modsize, 0, &amp;f-&gt;header, sizeof(f-&gt;header)) != sizeof(f-&gt;header))</font>
<font color="#a52a2a">2226</font>  <font color="#008b8b">+    {</font>
<font color="#a52a2a">2227</font>  <font color="#008b8b">+      printk(KERN_INFO &quot;cannot read ELF header from %s\n&quot;, filename);</font>
<font color="#a52a2a">2228</font>  <font color="#008b8b">+      obj_free(f);</font>
<font color="#a52a2a">2229</font>  <font color="#008b8b">+      return NULL;</font>
<font color="#a52a2a">2230</font>  <font color="#008b8b">+    }</font>
<font color="#a52a2a">2231</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">2232</font>  <font color="#008b8b">+  if (f-&gt;header.e_ident[EI_MAG0] != ELFMAG0</font>
<font color="#a52a2a">2233</font>  <font color="#008b8b">+      || f-&gt;header.e_ident[EI_MAG1] != ELFMAG1</font>
<font color="#a52a2a">2234</font>  <font color="#008b8b">+      || f-&gt;header.e_ident[EI_MAG2] != ELFMAG2</font>
<font color="#a52a2a">2235</font>  <font color="#008b8b">+      || f-&gt;header.e_ident[EI_MAG3] != ELFMAG3)</font>
<font color="#a52a2a">2236</font>  <font color="#008b8b">+    {</font>
<font color="#a52a2a">2237</font>  <font color="#008b8b">+      printk(KERN_INFO &quot;%s is not an ELF file\n&quot;, filename);</font>
<font color="#a52a2a">2238</font>  <font color="#008b8b">+      obj_free(f);</font>
<font color="#a52a2a">2239</font>  <font color="#008b8b">+      return NULL;</font>
<font color="#a52a2a">2240</font>  <font color="#008b8b">+    }</font>
<font color="#a52a2a">2241</font>  <font color="#008b8b">+  if (f-&gt;header.e_ident[EI_CLASS] != ELF_CLASS</font>
<font color="#a52a2a">2242</font>  <font color="#008b8b">+      || f-&gt;header.e_ident[EI_DATA] != ELF_DATA</font>
<font color="#a52a2a">2243</font>  <font color="#008b8b">+      || f-&gt;header.e_ident[EI_VERSION] != EV_CURRENT</font>
<font color="#a52a2a">2244</font>  <font color="#008b8b">+      || f-&gt;header.e_machine != ELF_ARCH)</font>
<font color="#a52a2a">2245</font>  <font color="#008b8b">+    {</font>
<font color="#a52a2a">2246</font>  <font color="#008b8b">+      printk(KERN_INFO &quot;ELF file %s not for this architecture\n&quot;, filename);</font>
<font color="#a52a2a">2247</font>  <font color="#008b8b">+      obj_free(f);</font>
<font color="#a52a2a">2248</font>  <font color="#008b8b">+      return NULL;</font>
<font color="#a52a2a">2249</font>  <font color="#008b8b">+    }</font>
<font color="#a52a2a">2250</font>  <font color="#008b8b">+  if (f-&gt;header.e_type != e_type &amp;&amp; e_type != ET_NONE)</font>
<font color="#a52a2a">2251</font>  <font color="#008b8b">+    {</font>
<font color="#a52a2a">2252</font>  <font color="#008b8b">+      switch (e_type) {</font>
<font color="#a52a2a">2253</font>  <font color="#008b8b">+      case ET_REL:</font>
<font color="#a52a2a">2254</font>  <font color="#008b8b">+       printk(KERN_INFO &quot;ELF file %s not a relocatable object\n&quot;, filename);</font>
<font color="#a52a2a">2255</font>  <font color="#008b8b">+       break;</font>
<font color="#a52a2a">2256</font>  <font color="#008b8b">+      case ET_EXEC:</font>
<font color="#a52a2a">2257</font>  <font color="#008b8b">+       printk(KERN_INFO &quot;ELF file %s not an executable object\n&quot;, filename);</font>
<font color="#a52a2a">2258</font>  <font color="#008b8b">+       break;</font>
<font color="#a52a2a">2259</font>  <font color="#008b8b">+      default:</font>
<font color="#a52a2a">2260</font>  <font color="#008b8b">+       printk(KERN_INFO &quot;ELF file %s has wrong type, expecting %d got %d\n&quot;,</font>
<font color="#a52a2a">2261</font>  <font color="#008b8b">+               filename, e_type, f-&gt;header.e_type);</font>
<font color="#a52a2a">2262</font>  <font color="#008b8b">+       break;</font>
<font color="#a52a2a">2263</font>  <font color="#008b8b">+      }</font>
<font color="#a52a2a">2264</font>  <font color="#008b8b">+      obj_free(f);</font>
<font color="#a52a2a">2265</font>  <font color="#008b8b">+      return NULL;</font>
<font color="#a52a2a">2266</font>  <font color="#008b8b">+    }</font>
<font color="#a52a2a">2267</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">2268</font>  <font color="#008b8b">+  /* Read the section headers.  */</font>
<font color="#a52a2a">2269</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">2270</font>  <font color="#008b8b">+  if (f-&gt;header.e_shentsize != sizeof(ElfW(Shdr)))</font>
<font color="#a52a2a">2271</font>  <font color="#008b8b">+    {</font>
<font color="#a52a2a">2272</font>  <font color="#008b8b">+      printk(KERN_INFO &quot;section header size mismatch %s: %lu != %lu\n&quot;,</font>
<font color="#a52a2a">2273</font>  <font color="#008b8b">+           filename,</font>
<font color="#a52a2a">2274</font>  <font color="#008b8b">+           (unsigned long)f-&gt;header.e_shentsize,</font>
<font color="#a52a2a">2275</font>  <font color="#008b8b">+           (unsigned long)sizeof(ElfW(Shdr)));</font>
<font color="#a52a2a">2276</font>  <font color="#008b8b">+      obj_free(f);</font>
<font color="#a52a2a">2277</font>  <font color="#008b8b">+      return NULL;</font>
<font color="#a52a2a">2278</font>  <font color="#008b8b">+    }</font>
<font color="#a52a2a">2279</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">2280</font>  <font color="#008b8b">+  shnum = f-&gt;header.e_shnum;</font>
<font color="#a52a2a">2281</font>  <font color="#008b8b">+  f-&gt;sections = kmalloc(sizeof(struct obj_section *) * shnum, GFP_KERNEL);</font>
<font color="#a52a2a">2282</font>  <font color="#008b8b">+  memset(f-&gt;sections, 0, sizeof(struct obj_section *) * shnum);</font>
<font color="#a52a2a">2283</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">2284</font>  <font color="#008b8b">+  section_headers = kmalloc(sizeof(ElfW(Shdr)) * shnum, GFP_KERNEL);</font>
<font color="#a52a2a">2285</font>  <font color="#008b8b">+  if (memcpy_chk(modmem, modsize, f-&gt;header.e_shoff, section_headers, sizeof(ElfW(Shdr))*shnum) != sizeof(ElfW(Shdr))*shnum)</font>
<font color="#a52a2a">2286</font>  <font color="#008b8b">+    {</font>
<font color="#a52a2a">2287</font>  <font color="#008b8b">+      printk(KERN_INFO &quot;reading ELF section headers %s: %m\n&quot;, filename);</font>
<font color="#a52a2a">2288</font>  <font color="#008b8b">+      obj_free(f);</font>
<font color="#a52a2a">2289</font>  <font color="#008b8b">+      return NULL;</font>
<font color="#a52a2a">2290</font>  <font color="#008b8b">+    }</font>
<font color="#a52a2a">2291</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">2292</font>  <font color="#008b8b">+  /* Read the section data.  */</font>
<font color="#a52a2a">2293</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">2294</font>  <font color="#008b8b">+  for (i = 0; i &lt; shnum; ++i)</font>
<font color="#a52a2a">2295</font>  <font color="#008b8b">+    {</font>
<font color="#a52a2a">2296</font>  <font color="#008b8b">+      struct obj_section *sec;</font>
<font color="#a52a2a">2297</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">2298</font>  <font color="#008b8b">+      f-&gt;sections[i] = sec = arch_new_section();</font>
<font color="#a52a2a">2299</font>  <font color="#008b8b">+      memset(sec, 0, sizeof(*sec));</font>
<font color="#a52a2a">2300</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">2301</font>  <font color="#008b8b">+      sec-&gt;header = section_headers[i];</font>
<font color="#a52a2a">2302</font>  <font color="#008b8b">+      sec-&gt;idx = i;</font>
<font color="#a52a2a">2303</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">2304</font>  <font color="#008b8b">+      switch (sec-&gt;header.sh_type)</font>
<font color="#a52a2a">2305</font>  <font color="#008b8b">+       {</font>
<font color="#a52a2a">2306</font>  <font color="#008b8b">+       case SHT_NULL:</font>
<font color="#a52a2a">2307</font>  <font color="#008b8b">+       case SHT_NOTE:</font>
<font color="#a52a2a">2308</font>  <font color="#008b8b">+       case SHT_NOBITS:</font>
<font color="#a52a2a">2309</font>  <font color="#008b8b">+         /* ignore */</font>
<font color="#a52a2a">2310</font>  <font color="#008b8b">+         break;</font>
<font color="#a52a2a">2311</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">2312</font>  <font color="#008b8b">+       case SHT_PROGBITS:</font>
<font color="#a52a2a">2313</font>  <font color="#008b8b">+       case SHT_SYMTAB:</font>
<font color="#a52a2a">2314</font>  <font color="#008b8b">+       case SHT_STRTAB:</font>
<font color="#a52a2a">2315</font>  <font color="#008b8b">+       case SHT_REL:</font>
<font color="#a52a2a">2316</font>  <font color="#008b8b">+       case SHT_RELA:</font>
<font color="#a52a2a">2317</font>  <font color="#008b8b">+         if (sec-&gt;header.sh_size &gt; 0)</font>
<font color="#a52a2a">2318</font>  <font color="#008b8b">+           {</font>
<font color="#a52a2a">2319</font>  <font color="#008b8b">+             sec-&gt;contents = kmalloc(sec-&gt;header.sh_size, GFP_KERNEL);</font>
<font color="#a52a2a">2320</font>  <font color="#008b8b">+             if (memcpy_chk(modmem, modsize, sec-&gt;header.sh_offset, sec-&gt;contents, sec-&gt;header.sh_size) != sec-&gt;header.sh_size)</font>
<font color="#a52a2a">2321</font>  <font color="#008b8b">+               {</font>
<font color="#a52a2a">2322</font>  <font color="#008b8b">+                 printk(KERN_INFO &quot;reading ELF section data %s: %m\n&quot;, filename);</font>
<font color="#a52a2a">2323</font>  <font color="#008b8b">+                 obj_free(f);</font>
<font color="#a52a2a">2324</font>  <font color="#008b8b">+                 return NULL;</font>
<font color="#a52a2a">2325</font>  <font color="#008b8b">+               }</font>
<font color="#a52a2a">2326</font>  <font color="#008b8b">+           }</font>
<font color="#a52a2a">2327</font>  <font color="#008b8b">+         else</font>
<font color="#a52a2a">2328</font>  <font color="#008b8b">+           sec-&gt;contents = NULL;</font>
<font color="#a52a2a">2329</font>  <font color="#008b8b">+         break;</font>
<font color="#a52a2a">2330</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">2331</font>  <font color="#008b8b">+/*#if SHT_RELM == SHT_REL</font>
<font color="#a52a2a">2332</font>  <font color="#008b8b">+       case SHT_RELA:</font>
<font color="#a52a2a">2333</font>  <font color="#008b8b">+         if (sec-&gt;header.sh_size) {</font>
<font color="#a52a2a">2334</font>  <font color="#008b8b">+           printk(KERN_INFO &quot;RELA relocations not supported on this architecture %s&quot;, filename);</font>
<font color="#a52a2a">2335</font>  <font color="#008b8b">+           obj_free(f);</font>
<font color="#a52a2a">2336</font>  <font color="#008b8b">+           return NULL;</font>
<font color="#a52a2a">2337</font>  <font color="#008b8b">+         }</font>
<font color="#a52a2a">2338</font>  <font color="#008b8b">+         break;</font>
<font color="#a52a2a">2339</font>  <font color="#008b8b">+#else</font>
<font color="#a52a2a">2340</font>  <font color="#008b8b">+       case SHT_REL:</font>
<font color="#a52a2a">2341</font>  <font color="#008b8b">+         if (sec-&gt;header.sh_size) {</font>
<font color="#a52a2a">2342</font>  <font color="#008b8b">+           printk(KERN_INFO &quot;REL relocations not supported on this architecture %s&quot;, filename);</font>
<font color="#a52a2a">2343</font>  <font color="#008b8b">+           obj_free(f);</font>
<font color="#a52a2a">2344</font>  <font color="#008b8b">+           return NULL;</font>
<font color="#a52a2a">2345</font>  <font color="#008b8b">+         }</font>
<font color="#a52a2a">2346</font>  <font color="#008b8b">+         break;</font>
<font color="#a52a2a">2347</font>  <font color="#008b8b">+#endif*/</font>
<font color="#a52a2a">2348</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">2349</font>  <font color="#008b8b">+       default:</font>
<font color="#a52a2a">2350</font>  <font color="#008b8b">+/*       if (sec-&gt;header.sh_type &gt;= SHT_LOPROC)</font>
<font color="#a52a2a">2351</font>  <font color="#008b8b">+           {</font>
<font color="#a52a2a">2352</font>  <font color="#008b8b">+             if (arch_load_proc_section(sec, fp) &lt; 0)</font>
<font color="#a52a2a">2353</font>  <font color="#008b8b">+               return NULL;</font>
<font color="#a52a2a">2354</font>  <font color="#008b8b">+             break;</font>
<font color="#a52a2a">2355</font>  <font color="#008b8b">+           }*/</font>
<font color="#a52a2a">2356</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">2357</font>  <font color="#008b8b">+         printk(KERN_INFO &quot;can't handle sections of type %ld %s %d\n&quot;,</font>
<font color="#a52a2a">2358</font>  <font color="#008b8b">+               (long)sec-&gt;header.sh_type, filename,i);</font>
<font color="#a52a2a">2359</font>  <font color="#008b8b">+         obj_free(f);</font>
<font color="#a52a2a">2360</font>  <font color="#008b8b">+         return NULL;</font>
<font color="#a52a2a">2361</font>  <font color="#008b8b">+       }</font>
<font color="#a52a2a">2362</font>  <font color="#008b8b">+    }</font>
<font color="#a52a2a">2363</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">2364</font>  <font color="#008b8b">+  /* Do what sort of interpretation as needed by each section.  */</font>
<font color="#a52a2a">2365</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">2366</font>  <font color="#008b8b">+  shstrtab = f-&gt;sections[f-&gt;header.e_shstrndx]-&gt;contents;</font>
<font color="#a52a2a">2367</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">2368</font>  <font color="#008b8b">+  for (i = 0; i &lt; shnum; ++i)</font>
<font color="#a52a2a">2369</font>  <font color="#008b8b">+    {</font>
<font color="#a52a2a">2370</font>  <font color="#008b8b">+      struct obj_section *sec = f-&gt;sections[i];</font>
<font color="#a52a2a">2371</font>  <font color="#008b8b">+      sec-&gt;name = shstrtab + sec-&gt;header.sh_name;</font>
<font color="#a52a2a">2372</font>  <font color="#008b8b">+    }</font>
<font color="#a52a2a">2373</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">2374</font>  <font color="#008b8b">+  for (i = 0; i &lt; shnum; ++i)</font>
<font color="#a52a2a">2375</font>  <font color="#008b8b">+    {</font>
<font color="#a52a2a">2376</font>  <font color="#008b8b">+      struct obj_section *sec = f-&gt;sections[i];</font>
<font color="#a52a2a">2377</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">2378</font>  <font color="#008b8b">+      /* .modinfo and .modstring should be contents only but gcc has no</font>
<font color="#a52a2a">2379</font>  <font color="#008b8b">+       *  attribute for that.  The kernel may have marked these sections as</font>
<font color="#a52a2a">2380</font>  <font color="#008b8b">+       *  ALLOC, ignore the allocate bit.</font>
<font color="#a52a2a">2381</font>  <font color="#008b8b">+       */</font>
<font color="#a52a2a">2382</font>  <font color="#008b8b">+      if (strcmp(sec-&gt;name, &quot;.modinfo&quot;) == 0 ||</font>
<font color="#a52a2a">2383</font>  <font color="#008b8b">+         strcmp(sec-&gt;name, &quot;.modstring&quot;) == 0)</font>
<font color="#a52a2a">2384</font>  <font color="#008b8b">+       sec-&gt;header.sh_flags &amp;= ~SHF_ALLOC;</font>
<font color="#a52a2a">2385</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">2386</font>  <font color="#008b8b">+      if (sec-&gt;header.sh_flags &amp; SHF_ALLOC)</font>
<font color="#a52a2a">2387</font>  <font color="#008b8b">+       obj_insert_section_load_order(f, sec);</font>
<font color="#a52a2a">2388</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">2389</font>  <font color="#008b8b">+      switch (sec-&gt;header.sh_type)</font>
<font color="#a52a2a">2390</font>  <font color="#008b8b">+       {</font>
<font color="#a52a2a">2391</font>  <font color="#008b8b">+       case SHT_SYMTAB:</font>
<font color="#a52a2a">2392</font>  <font color="#008b8b">+         {</font>
<font color="#a52a2a">2393</font>  <font color="#008b8b">+           unsigned long nsym, j;</font>
<font color="#a52a2a">2394</font>  <font color="#008b8b">+           char *strtab;</font>
<font color="#a52a2a">2395</font>  <font color="#008b8b">+           ElfW(Sym) *sym;</font>
<font color="#a52a2a">2396</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">2397</font>  <font color="#008b8b">+           if (sec-&gt;header.sh_entsize != sizeof(ElfW(Sym)))</font>
<font color="#a52a2a">2398</font>  <font color="#008b8b">+             {</font>
<font color="#a52a2a">2399</font>  <font color="#008b8b">+               printk(KERN_INFO &quot;symbol size mismatch %s: %lu != %lu\n&quot;,</font>
<font color="#a52a2a">2400</font>  <font color="#008b8b">+                     filename,</font>
<font color="#a52a2a">2401</font>  <font color="#008b8b">+                     (unsigned long)sec-&gt;header.sh_entsize,</font>
<font color="#a52a2a">2402</font>  <font color="#008b8b">+                     (unsigned long)sizeof(ElfW(Sym)));</font>
<font color="#a52a2a">2403</font>  <font color="#008b8b">+               obj_free(f);</font>
<font color="#a52a2a">2404</font>  <font color="#008b8b">+               return NULL;</font>
<font color="#a52a2a">2405</font>  <font color="#008b8b">+             }</font>
<font color="#a52a2a">2406</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">2407</font>  <font color="#008b8b">+           nsym = sec-&gt;header.sh_size / sizeof(ElfW(Sym));</font>
<font color="#a52a2a">2408</font>  <font color="#008b8b">+           strtab = f-&gt;sections[sec-&gt;header.sh_link]-&gt;contents;</font>
<font color="#a52a2a">2409</font>  <font color="#008b8b">+           sym = (ElfW(Sym) *) sec-&gt;contents;</font>
<font color="#a52a2a">2410</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">2411</font>  <font color="#008b8b">+           /* Allocate space for a table of local symbols.  */</font>
<font color="#a52a2a">2412</font>  <font color="#008b8b">+           j = f-&gt;local_symtab_size = sec-&gt;header.sh_info;</font>
<font color="#a52a2a">2413</font>  <font color="#008b8b">+           f-&gt;local_symtab = kmalloc(j *= sizeof(struct obj_symbol *), GFP_KERNEL);</font>
<font color="#a52a2a">2414</font>  <font color="#008b8b">+           memset(f-&gt;local_symtab, 0, j);</font>
<font color="#a52a2a">2415</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">2416</font>  <font color="#008b8b">+           /* Insert all symbols into the hash table.  */</font>
<font color="#a52a2a">2417</font>  <font color="#008b8b">+           for (j = 1, ++sym; j &lt; nsym; ++j, ++sym)</font>
<font color="#a52a2a">2418</font>  <font color="#008b8b">+             {</font>
<font color="#a52a2a">2419</font>  <font color="#008b8b">+               const char *name;</font>
<font color="#a52a2a">2420</font>  <font color="#008b8b">+               if (sym-&gt;st_name)</font>
<font color="#a52a2a">2421</font>  <font color="#008b8b">+                 name = strtab+sym-&gt;st_name;</font>
<font color="#a52a2a">2422</font>  <font color="#008b8b">+               else</font>
<font color="#a52a2a">2423</font>  <font color="#008b8b">+                 name = f-&gt;sections[sym-&gt;st_shndx]-&gt;name;</font>
<font color="#a52a2a">2424</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">2425</font>  <font color="#008b8b">+               obj_add_symbol(f, name, j, sym-&gt;st_info, sym-&gt;st_shndx,</font>
<font color="#a52a2a">2426</font>  <font color="#008b8b">+                              sym-&gt;st_value, sym-&gt;st_size);</font>
<font color="#a52a2a">2427</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">2428</font>  <font color="#008b8b">+             }</font>
<font color="#a52a2a">2429</font>  <font color="#008b8b">+         }</font>
<font color="#a52a2a">2430</font>  <font color="#008b8b">+       break;</font>
<font color="#a52a2a">2431</font>  <font color="#008b8b">+       }</font>
<font color="#a52a2a">2432</font>  <font color="#008b8b">+    }</font>
<font color="#a52a2a">2433</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">2434</font>  <font color="#008b8b">+  /* second pass to add relocation data to symbols */</font>
<font color="#a52a2a">2435</font>  <font color="#008b8b">+  for (i = 0; i &lt; shnum; ++i)</font>
<font color="#a52a2a">2436</font>  <font color="#008b8b">+    {</font>
<font color="#a52a2a">2437</font>  <font color="#008b8b">+      struct obj_section *sec = f-&gt;sections[i];</font>
<font color="#a52a2a">2438</font>  <font color="#008b8b">+      switch (sec-&gt;header.sh_type)</font>
<font color="#a52a2a">2439</font>  <font color="#008b8b">+       {</font>
<font color="#a52a2a">2440</font>  <font color="#008b8b">+       case SHT_REL:</font>
<font color="#a52a2a">2441</font>  <font color="#008b8b">+       case SHT_RELA:</font>
<font color="#a52a2a">2442</font>  <font color="#008b8b">+         {</font>
<font color="#a52a2a">2443</font>  <font color="#008b8b">+           unsigned long nrel, j, nsyms;</font>
<font color="#a52a2a">2444</font>  <font color="#008b8b">+           ElfW(Rel) *rel;</font>
<font color="#a52a2a">2445</font>  <font color="#008b8b">+           struct obj_section *symtab;</font>
<font color="#a52a2a">2446</font>  <font color="#008b8b">+           char *strtab;</font>
<font color="#a52a2a">2447</font>  <font color="#008b8b">+           if (sec-&gt;header.sh_entsize != sizeof(ElfW(Rel)))</font>
<font color="#a52a2a">2448</font>  <font color="#008b8b">+             {</font>
<font color="#a52a2a">2449</font>  <font color="#008b8b">+               printk(KERN_INFO &quot;relocation entry size mismatch %s: %lu != %lu\n&quot;,</font>
<font color="#a52a2a">2450</font>  <font color="#008b8b">+                     filename,</font>
<font color="#a52a2a">2451</font>  <font color="#008b8b">+                     (unsigned long)sec-&gt;header.sh_entsize,</font>
<font color="#a52a2a">2452</font>  <font color="#008b8b">+                     (unsigned long)sizeof(ElfW(Rel)));</font>
<font color="#a52a2a">2453</font>  <font color="#008b8b">+               obj_free(f);</font>
<font color="#a52a2a">2454</font>  <font color="#008b8b">+               return NULL;</font>
<font color="#a52a2a">2455</font>  <font color="#008b8b">+             }</font>
<font color="#a52a2a">2456</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">2457</font>  <font color="#008b8b">+           nrel = sec-&gt;header.sh_size / sizeof(ElfW(Rel));</font>
<font color="#a52a2a">2458</font>  <font color="#008b8b">+           rel = (ElfW(Rel) *) sec-&gt;contents;</font>
<font color="#a52a2a">2459</font>  <font color="#008b8b">+           symtab = f-&gt;sections[sec-&gt;header.sh_link];</font>
<font color="#a52a2a">2460</font>  <font color="#008b8b">+           nsyms = symtab-&gt;header.sh_size / symtab-&gt;header.sh_entsize;</font>
<font color="#a52a2a">2461</font>  <font color="#008b8b">+           strtab = f-&gt;sections[symtab-&gt;header.sh_link]-&gt;contents;</font>
<font color="#a52a2a">2462</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">2463</font>  <font color="#008b8b">+           /* Save the relocate type in each symbol entry.  */</font>
<font color="#a52a2a">2464</font>  <font color="#008b8b">+           for (j = 0; j &lt; nrel; ++j, ++rel)</font>
<font color="#a52a2a">2465</font>  <font color="#008b8b">+             {</font>
<font color="#a52a2a">2466</font>  <font color="#008b8b">+               struct obj_symbol *intsym;</font>
<font color="#a52a2a">2467</font>  <font color="#008b8b">+               unsigned long symndx;</font>
<font color="#a52a2a">2468</font>  <font color="#008b8b">+               symndx = ELFW(R_SYM)(rel-&gt;r_info);</font>
<font color="#a52a2a">2469</font>  <font color="#008b8b">+               if (symndx)</font>
<font color="#a52a2a">2470</font>  <font color="#008b8b">+                 {</font>
<font color="#a52a2a">2471</font>  <font color="#008b8b">+                   if (symndx &gt;= nsyms)</font>
<font color="#a52a2a">2472</font>  <font color="#008b8b">+                     {</font>
<font color="#a52a2a">2473</font>  <font color="#008b8b">+                       printk(KERN_INFO &quot;%s: Bad symbol index: %08lx &gt;= %08lx\n&quot;,</font>
<font color="#a52a2a">2474</font>  <font color="#008b8b">+                             filename, symndx, nsyms);</font>
<font color="#a52a2a">2475</font>  <font color="#008b8b">+                       continue;</font>
<font color="#a52a2a">2476</font>  <font color="#008b8b">+                     }</font>
<font color="#a52a2a">2477</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">2478</font>  <font color="#008b8b">+                   obj_find_relsym(intsym, f, f, rel, (ElfW(Sym) *)(symtab-&gt;contents), strtab);</font>
<font color="#a52a2a">2479</font>  <font color="#008b8b">+                   intsym-&gt;r_type = ELFW(R_TYPE)(rel-&gt;r_info);</font>
<font color="#a52a2a">2480</font>  <font color="#008b8b">+                 }</font>
<font color="#a52a2a">2481</font>  <font color="#008b8b">+             }</font>
<font color="#a52a2a">2482</font>  <font color="#008b8b">+         }</font>
<font color="#a52a2a">2483</font>  <font color="#008b8b">+         break;</font>
<font color="#a52a2a">2484</font>  <font color="#008b8b">+       }</font>
<font color="#a52a2a">2485</font>  <font color="#008b8b">+    }</font>
<font color="#a52a2a">2486</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">2487</font>  <font color="#008b8b">+  f-&gt;filename = kmalloc(strlen(filename), GFP_KERNEL);</font>
<font color="#a52a2a">2488</font>  <font color="#008b8b">+  strcpy((char *)f-&gt;filename,filename);</font>
<font color="#a52a2a">2489</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">2490</font>  <font color="#008b8b">+  return f;</font>
<font color="#a52a2a">2491</font>  <font color="#008b8b">+}</font>
<font color="#a52a2a">2492</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">2493</font>  <font color="#008b8b">+void obj_free(struct obj_file *f)</font>
<font color="#a52a2a">2494</font>  <font color="#008b8b">+{</font>
<font color="#a52a2a">2495</font>  <font color="#008b8b">+       struct obj_section *sec;</font>
<font color="#a52a2a">2496</font>  <font color="#008b8b">+       struct obj_symbol *sym;</font>
<font color="#a52a2a">2497</font>  <font color="#008b8b">+       struct obj_symbol *next;</font>
<font color="#a52a2a">2498</font>  <font color="#008b8b">+       int i;</font>
<font color="#a52a2a">2499</font>  <font color="#008b8b">+       int n;</font>
<font color="#a52a2a">2500</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">2501</font>  <font color="#008b8b">+       if (f-&gt;sections) {</font>
<font color="#a52a2a">2502</font>  <font color="#008b8b">+               n = f-&gt;header.e_shnum;</font>
<font color="#a52a2a">2503</font>  <font color="#008b8b">+               for (i = 0; i &lt; n; ++i) {</font>
<font color="#a52a2a">2504</font>  <font color="#008b8b">+                       if ((sec = f-&gt;sections[i]) != NULL) {</font>
<font color="#a52a2a">2505</font>  <font color="#008b8b">+                               if (sec-&gt;contents)</font>
<font color="#a52a2a">2506</font>  <font color="#008b8b">+                                       kfree(sec-&gt;contents);</font>
<font color="#a52a2a">2507</font>  <font color="#008b8b">+                               kfree(sec);</font>
<font color="#a52a2a">2508</font>  <font color="#008b8b">+                       }</font>
<font color="#a52a2a">2509</font>  <font color="#008b8b">+               }</font>
<font color="#a52a2a">2510</font>  <font color="#008b8b">+               kfree(f-&gt;sections);</font>
<font color="#a52a2a">2511</font>  <font color="#008b8b">+       }</font>
<font color="#a52a2a">2512</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">2513</font>  <font color="#008b8b">+       for (i = 0; i &lt; HASH_BUCKETS; ++i) {</font>
<font color="#a52a2a">2514</font>  <font color="#008b8b">+               for (sym = f-&gt;symtab[i]; sym; sym = next) {</font>
<font color="#a52a2a">2515</font>  <font color="#008b8b">+                       next = sym-&gt;next;</font>
<font color="#a52a2a">2516</font>  <font color="#008b8b">+                       kfree(sym);</font>
<font color="#a52a2a">2517</font>  <font color="#008b8b">+               }</font>
<font color="#a52a2a">2518</font>  <font color="#008b8b">+       }</font>
<font color="#a52a2a">2519</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">2520</font>  <font color="#008b8b">+       if (f-&gt;local_symtab)</font>
<font color="#a52a2a">2521</font>  <font color="#008b8b">+               kfree(f-&gt;local_symtab);</font>
<font color="#a52a2a">2522</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">2523</font>  <font color="#008b8b">+       if (f-&gt;filename)</font>
<font color="#a52a2a">2524</font>  <font color="#008b8b">+               kfree((char *)(f-&gt;filename));</font>
<font color="#a52a2a">2525</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">2526</font>  <font color="#008b8b">+       if (f-&gt;persist)</font>
<font color="#a52a2a">2527</font>  <font color="#008b8b">+               kfree((char *)(f-&gt;persist));</font>
<font color="#a52a2a">2528</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">2529</font>  <font color="#008b8b">+       kfree(f);</font>
<font color="#a52a2a">2530</font>  <font color="#008b8b">+}</font>
<font color="#a52a2a">2531</font>  <font color="#2e8b57"><b>diff -urbN linux/kernel/obj_reloc.c linux.new/kernel/obj_reloc.c</b></font>
<font color="#a52a2a">2532</font>  <font color="#2e8b57"><b>--- linux/kernel/obj_reloc.c    Thu Jan  1 01:00:00 1970</b></font>
<font color="#a52a2a">2533</font>  <font color="#2e8b57"><b>+++ linux.new/kernel/obj_reloc.c        Wed Dec  5 23:24:59 2001</b></font>
<font color="#a52a2a">2534</font>  <font color="#a52a2a"><b>@@ -0,0 +1,423 @@</b></font>
<font color="#a52a2a">2535</font>  <font color="#008b8b">+/* Elf relocation routines.</font>
<font color="#a52a2a">2536</font>  <font color="#008b8b">+   Copyright 1996, 1997 Linux International.</font>
<font color="#a52a2a">2537</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">2538</font>  <font color="#008b8b">+   Contributed by Richard Henderson &lt;rth@tamu.edu&gt;</font>
<font color="#a52a2a">2539</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">2540</font>  <font color="#008b8b">+   This file is part of the Linux modutils.</font>
<font color="#a52a2a">2541</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">2542</font>  <font color="#008b8b">+   This program is free software; you can redistribute it and/or modify it</font>
<font color="#a52a2a">2543</font>  <font color="#008b8b">+   under the terms of the GNU General Public License as published by the</font>
<font color="#a52a2a">2544</font>  <font color="#008b8b">+   Free Software Foundation; either version 2 of the License, or (at your</font>
<font color="#a52a2a">2545</font>  <font color="#008b8b">+   option) any later version.</font>
<font color="#a52a2a">2546</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">2547</font>  <font color="#008b8b">+   This program is distributed in the hope that it will be useful, but</font>
<font color="#a52a2a">2548</font>  <font color="#008b8b">+   WITHOUT ANY WARRANTY; without even the implied warranty of</font>
<font color="#a52a2a">2549</font>  <font color="#008b8b">+   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU</font>
<font color="#a52a2a">2550</font>  <font color="#008b8b">+   General Public License for more details.</font>
<font color="#a52a2a">2551</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">2552</font>  <font color="#008b8b">+   You should have received a copy of the GNU General Public License</font>
<font color="#a52a2a">2553</font>  <font color="#008b8b">+   along with this program; if not, write to the Free Software Foundation,</font>
<font color="#a52a2a">2554</font>  <font color="#008b8b">+   Inc., 59 Temple Place - Suite 330, Boston, MA 02111-1307, USA.  */</font>
<font color="#a52a2a">2555</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">2556</font>  <font color="#008b8b">+#ident &quot;$Id: obj_reloc.c 1.4 Wed, 26 Sep 2001 14:50:45 +1000 kaos $&quot;</font>
<font color="#a52a2a">2557</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">2558</font>  <font color="#008b8b">+#include &lt;linux/kernel.h&gt;</font>
<font color="#a52a2a">2559</font>  <font color="#008b8b">+#include &lt;linux/stddef.h&gt;</font>
<font color="#a52a2a">2560</font>  <font color="#008b8b">+#include &lt;linux/slab.h&gt;</font>
<font color="#a52a2a">2561</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">2562</font>  <font color="#008b8b">+#include &lt;linux/obj_load.h&gt;</font>
<font color="#a52a2a">2563</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">2564</font>  <font color="#008b8b">+/*======================================================================*/</font>
<font color="#a52a2a">2565</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">2566</font>  <font color="#008b8b">+int</font>
<font color="#a52a2a">2567</font>  <font color="#008b8b">+obj_string_patch(struct obj_file *f, int secidx, ElfW(Addr) offset,</font>
<font color="#a52a2a">2568</font>  <font color="#008b8b">+                const char *string)</font>
<font color="#a52a2a">2569</font>  <font color="#008b8b">+{</font>
<font color="#a52a2a">2570</font>  <font color="#008b8b">+  struct obj_string_patch_struct *p;</font>
<font color="#a52a2a">2571</font>  <font color="#008b8b">+  struct obj_section *strsec;</font>
<font color="#a52a2a">2572</font>  <font color="#008b8b">+  size_t len = strlen(string)+1;</font>
<font color="#a52a2a">2573</font>  <font color="#008b8b">+  char *loc;</font>
<font color="#a52a2a">2574</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">2575</font>  <font color="#008b8b">+  p = kmalloc(sizeof(*p), GFP_KERNEL);</font>
<font color="#a52a2a">2576</font>  <font color="#008b8b">+  p-&gt;next = f-&gt;string_patches;</font>
<font color="#a52a2a">2577</font>  <font color="#008b8b">+  p-&gt;reloc_secidx = secidx;</font>
<font color="#a52a2a">2578</font>  <font color="#008b8b">+  p-&gt;reloc_offset = offset;</font>
<font color="#a52a2a">2579</font>  <font color="#008b8b">+  f-&gt;string_patches = p;</font>
<font color="#a52a2a">2580</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">2581</font>  <font color="#008b8b">+  strsec = obj_find_section(f, &quot;.kstrtab&quot;);</font>
<font color="#a52a2a">2582</font>  <font color="#008b8b">+  if (strsec == NULL)</font>
<font color="#a52a2a">2583</font>  <font color="#008b8b">+    {</font>
<font color="#a52a2a">2584</font>  <font color="#008b8b">+      strsec = obj_create_alloced_section(f, &quot;.kstrtab&quot;, 1, len, 0);</font>
<font color="#a52a2a">2585</font>  <font color="#008b8b">+      p-&gt;string_offset = 0;</font>
<font color="#a52a2a">2586</font>  <font color="#008b8b">+      loc = strsec-&gt;contents;</font>
<font color="#a52a2a">2587</font>  <font color="#008b8b">+    }</font>
<font color="#a52a2a">2588</font>  <font color="#008b8b">+  else</font>
<font color="#a52a2a">2589</font>  <font color="#008b8b">+    {</font>
<font color="#a52a2a">2590</font>  <font color="#008b8b">+      p-&gt;string_offset = strsec-&gt;header.sh_size;</font>
<font color="#a52a2a">2591</font>  <font color="#008b8b">+      loc = obj_extend_section(strsec, len);</font>
<font color="#a52a2a">2592</font>  <font color="#008b8b">+    }</font>
<font color="#a52a2a">2593</font>  <font color="#008b8b">+  memcpy(loc, string, len);</font>
<font color="#a52a2a">2594</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">2595</font>  <font color="#008b8b">+  return 1;</font>
<font color="#a52a2a">2596</font>  <font color="#008b8b">+}</font>
<font color="#a52a2a">2597</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">2598</font>  <font color="#008b8b">+int</font>
<font color="#a52a2a">2599</font>  <font color="#008b8b">+obj_symbol_patch(struct obj_file *f, int secidx, ElfW(Addr) offset,</font>
<font color="#a52a2a">2600</font>  <font color="#008b8b">+                struct obj_symbol *sym)</font>
<font color="#a52a2a">2601</font>  <font color="#008b8b">+{</font>
<font color="#a52a2a">2602</font>  <font color="#008b8b">+  struct obj_symbol_patch_struct *p;</font>
<font color="#a52a2a">2603</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">2604</font>  <font color="#008b8b">+  p = kmalloc(sizeof(*p), GFP_KERNEL);</font>
<font color="#a52a2a">2605</font>  <font color="#008b8b">+  p-&gt;next = f-&gt;symbol_patches;</font>
<font color="#a52a2a">2606</font>  <font color="#008b8b">+  p-&gt;reloc_secidx = secidx;</font>
<font color="#a52a2a">2607</font>  <font color="#008b8b">+  p-&gt;reloc_offset = offset;</font>
<font color="#a52a2a">2608</font>  <font color="#008b8b">+  p-&gt;sym = sym;</font>
<font color="#a52a2a">2609</font>  <font color="#008b8b">+  f-&gt;symbol_patches = p;</font>
<font color="#a52a2a">2610</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">2611</font>  <font color="#008b8b">+  return 1;</font>
<font color="#a52a2a">2612</font>  <font color="#008b8b">+}</font>
<font color="#a52a2a">2613</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">2614</font>  <font color="#008b8b">+int</font>
<font color="#a52a2a">2615</font>  <font color="#008b8b">+obj_check_undefineds(struct obj_file *f, int quiet)</font>
<font color="#a52a2a">2616</font>  <font color="#008b8b">+{</font>
<font color="#a52a2a">2617</font>  <font color="#008b8b">+  unsigned long i;</font>
<font color="#a52a2a">2618</font>  <font color="#008b8b">+  int ret = 1;</font>
<font color="#a52a2a">2619</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">2620</font>  <font color="#008b8b">+  for (i = 0; i &lt; HASH_BUCKETS; ++i)</font>
<font color="#a52a2a">2621</font>  <font color="#008b8b">+    {</font>
<font color="#a52a2a">2622</font>  <font color="#008b8b">+      struct obj_symbol *sym;</font>
<font color="#a52a2a">2623</font>  <font color="#008b8b">+      for (sym = f-&gt;symtab[i]; sym ; sym = sym-&gt;next)</font>
<font color="#a52a2a">2624</font>  <font color="#008b8b">+       if (sym-&gt;secidx == SHN_UNDEF)</font>
<font color="#a52a2a">2625</font>  <font color="#008b8b">+         {</font>
<font color="#a52a2a">2626</font>  <font color="#008b8b">+           if (ELFW(ST_BIND)(sym-&gt;info) == STB_WEAK)</font>
<font color="#a52a2a">2627</font>  <font color="#008b8b">+             {</font>
<font color="#a52a2a">2628</font>  <font color="#008b8b">+               sym-&gt;secidx = SHN_ABS;</font>
<font color="#a52a2a">2629</font>  <font color="#008b8b">+               sym-&gt;value = 0;</font>
<font color="#a52a2a">2630</font>  <font color="#008b8b">+             }</font>
<font color="#a52a2a">2631</font>  <font color="#008b8b">+           else if (sym-&gt;r_type) /* assumes R_arch_NONE is 0 on all arch */</font>
<font color="#a52a2a">2632</font>  <font color="#008b8b">+             {</font>
<font color="#a52a2a">2633</font>  <font color="#008b8b">+               if (!quiet)</font>
<font color="#a52a2a">2634</font>  <font color="#008b8b">+                       printk(KERN_INFO &quot;unresolved symbol %s&quot;, sym-&gt;name);</font>
<font color="#a52a2a">2635</font>  <font color="#008b8b">+               ret = 0;</font>
<font color="#a52a2a">2636</font>  <font color="#008b8b">+             }</font>
<font color="#a52a2a">2637</font>  <font color="#008b8b">+         }</font>
<font color="#a52a2a">2638</font>  <font color="#008b8b">+    }</font>
<font color="#a52a2a">2639</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">2640</font>  <font color="#008b8b">+  return ret;</font>
<font color="#a52a2a">2641</font>  <font color="#008b8b">+}</font>
<font color="#a52a2a">2642</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">2643</font>  <font color="#008b8b">+void</font>
<font color="#a52a2a">2644</font>  <font color="#008b8b">+obj_clear_undefineds(struct obj_file *f)</font>
<font color="#a52a2a">2645</font>  <font color="#008b8b">+{</font>
<font color="#a52a2a">2646</font>  <font color="#008b8b">+  unsigned long i;</font>
<font color="#a52a2a">2647</font>  <font color="#008b8b">+  struct obj_symbol *sym;</font>
<font color="#a52a2a">2648</font>  <font color="#008b8b">+  for (i = 0; i &lt; HASH_BUCKETS; ++i)</font>
<font color="#a52a2a">2649</font>  <font color="#008b8b">+    {</font>
<font color="#a52a2a">2650</font>  <font color="#008b8b">+      for (sym = f-&gt;symtab[i]; sym ; sym = sym-&gt;next)</font>
<font color="#a52a2a">2651</font>  <font color="#008b8b">+       if (sym-&gt;secidx == SHN_UNDEF)</font>
<font color="#a52a2a">2652</font>  <font color="#008b8b">+         {</font>
<font color="#a52a2a">2653</font>  <font color="#008b8b">+           sym-&gt;secidx = SHN_ABS;</font>
<font color="#a52a2a">2654</font>  <font color="#008b8b">+           sym-&gt;value = 0;</font>
<font color="#a52a2a">2655</font>  <font color="#008b8b">+         }</font>
<font color="#a52a2a">2656</font>  <font color="#008b8b">+    }</font>
<font color="#a52a2a">2657</font>  <font color="#008b8b">+}</font>
<font color="#a52a2a">2658</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">2659</font>  <font color="#008b8b">+static void *realloc(void *ptr, unsigned int size, unsigned int oldsize)</font>
<font color="#a52a2a">2660</font>  <font color="#008b8b">+{</font>
<font color="#a52a2a">2661</font>  <font color="#008b8b">+       void *new;</font>
<font color="#a52a2a">2662</font>  <font color="#008b8b">+       new = kmalloc(size, GFP_KERNEL);</font>
<font color="#a52a2a">2663</font>  <font color="#008b8b">+       memcpy(new, ptr, oldsize);</font>
<font color="#a52a2a">2664</font>  <font color="#008b8b">+       kfree(ptr);</font>
<font color="#a52a2a">2665</font>  <font color="#008b8b">+       return new;</font>
<font color="#a52a2a">2666</font>  <font color="#008b8b">+}</font>
<font color="#a52a2a">2667</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">2668</font>  <font color="#008b8b">+void</font>
<font color="#a52a2a">2669</font>  <font color="#008b8b">+obj_allocate_commons(struct obj_file *f)</font>
<font color="#a52a2a">2670</font>  <font color="#008b8b">+{</font>
<font color="#a52a2a">2671</font>  <font color="#008b8b">+  struct common_entry</font>
<font color="#a52a2a">2672</font>  <font color="#008b8b">+  {</font>
<font color="#a52a2a">2673</font>  <font color="#008b8b">+    struct common_entry *next;</font>
<font color="#a52a2a">2674</font>  <font color="#008b8b">+    struct obj_symbol *sym;</font>
<font color="#a52a2a">2675</font>  <font color="#008b8b">+  } *common_head = NULL;</font>
<font color="#a52a2a">2676</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">2677</font>  <font color="#008b8b">+  unsigned long i;</font>
<font color="#a52a2a">2678</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">2679</font>  <font color="#008b8b">+  for (i = 0; i &lt; HASH_BUCKETS; ++i)</font>
<font color="#a52a2a">2680</font>  <font color="#008b8b">+    {</font>
<font color="#a52a2a">2681</font>  <font color="#008b8b">+      struct obj_symbol *sym;</font>
<font color="#a52a2a">2682</font>  <font color="#008b8b">+      for (sym = f-&gt;symtab[i]; sym ; sym = sym-&gt;next)</font>
<font color="#a52a2a">2683</font>  <font color="#008b8b">+       if (sym-&gt;secidx == SHN_COMMON)</font>
<font color="#a52a2a">2684</font>  <font color="#008b8b">+         {</font>
<font color="#a52a2a">2685</font>  <font color="#008b8b">+           /* Collect all COMMON symbols and sort them by size so as to</font>
<font color="#a52a2a">2686</font>  <font color="#008b8b">+              minimize space wasted by alignment requirements.  */</font>
<font color="#a52a2a">2687</font>  <font color="#008b8b">+           {</font>
<font color="#a52a2a">2688</font>  <font color="#008b8b">+             struct common_entry **p, *n;</font>
<font color="#a52a2a">2689</font>  <font color="#008b8b">+             for (p = &amp;common_head; *p ; p = &amp;(*p)-&gt;next)</font>
<font color="#a52a2a">2690</font>  <font color="#008b8b">+               if (sym-&gt;size &lt;= (*p)-&gt;sym-&gt;size)</font>
<font color="#a52a2a">2691</font>  <font color="#008b8b">+                 break;</font>
<font color="#a52a2a">2692</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">2693</font>  <font color="#008b8b">+             n = alloca(sizeof(*n));</font>
<font color="#a52a2a">2694</font>  <font color="#008b8b">+             n-&gt;next = *p;</font>
<font color="#a52a2a">2695</font>  <font color="#008b8b">+             n-&gt;sym = sym;</font>
<font color="#a52a2a">2696</font>  <font color="#008b8b">+             *p = n;</font>
<font color="#a52a2a">2697</font>  <font color="#008b8b">+           }</font>
<font color="#a52a2a">2698</font>  <font color="#008b8b">+         }</font>
<font color="#a52a2a">2699</font>  <font color="#008b8b">+    }</font>
<font color="#a52a2a">2700</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">2701</font>  <font color="#008b8b">+  for (i = 1; i &lt; f-&gt;local_symtab_size; ++i)</font>
<font color="#a52a2a">2702</font>  <font color="#008b8b">+    {</font>
<font color="#a52a2a">2703</font>  <font color="#008b8b">+      struct obj_symbol *sym = f-&gt;local_symtab[i];</font>
<font color="#a52a2a">2704</font>  <font color="#008b8b">+      if (sym &amp;&amp; sym-&gt;secidx == SHN_COMMON)</font>
<font color="#a52a2a">2705</font>  <font color="#008b8b">+       {</font>
<font color="#a52a2a">2706</font>  <font color="#008b8b">+         struct common_entry **p, *n;</font>
<font color="#a52a2a">2707</font>  <font color="#008b8b">+         for (p = &amp;common_head; *p ; p = &amp;(*p)-&gt;next)</font>
<font color="#a52a2a">2708</font>  <font color="#008b8b">+           if (sym == (*p)-&gt;sym)</font>
<font color="#a52a2a">2709</font>  <font color="#008b8b">+             break;</font>
<font color="#a52a2a">2710</font>  <font color="#008b8b">+           else if (sym-&gt;size &lt; (*p)-&gt;sym-&gt;size)</font>
<font color="#a52a2a">2711</font>  <font color="#008b8b">+             {</font>
<font color="#a52a2a">2712</font>  <font color="#008b8b">+               n = alloca(sizeof(*n));</font>
<font color="#a52a2a">2713</font>  <font color="#008b8b">+               n-&gt;next = *p;</font>
<font color="#a52a2a">2714</font>  <font color="#008b8b">+               n-&gt;sym = sym;</font>
<font color="#a52a2a">2715</font>  <font color="#008b8b">+               *p = n;</font>
<font color="#a52a2a">2716</font>  <font color="#008b8b">+               break;</font>
<font color="#a52a2a">2717</font>  <font color="#008b8b">+             }</font>
<font color="#a52a2a">2718</font>  <font color="#008b8b">+       }</font>
<font color="#a52a2a">2719</font>  <font color="#008b8b">+    }</font>
<font color="#a52a2a">2720</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">2721</font>  <font color="#008b8b">+  if (common_head)</font>
<font color="#a52a2a">2722</font>  <font color="#008b8b">+    {</font>
<font color="#a52a2a">2723</font>  <font color="#008b8b">+      /* Find the bss section.  */</font>
<font color="#a52a2a">2724</font>  <font color="#008b8b">+      for (i = 0; i &lt; f-&gt;header.e_shnum; ++i)</font>
<font color="#a52a2a">2725</font>  <font color="#008b8b">+       if (f-&gt;sections[i]-&gt;header.sh_type == SHT_NOBITS)</font>
<font color="#a52a2a">2726</font>  <font color="#008b8b">+         break;</font>
<font color="#a52a2a">2727</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">2728</font>  <font color="#008b8b">+      /* If for some reason there hadn't been one, create one.  */</font>
<font color="#a52a2a">2729</font>  <font color="#008b8b">+      if (i == f-&gt;header.e_shnum)</font>
<font color="#a52a2a">2730</font>  <font color="#008b8b">+       {</font>
<font color="#a52a2a">2731</font>  <font color="#008b8b">+         struct obj_section *sec;</font>
<font color="#a52a2a">2732</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">2733</font>  <font color="#008b8b">+         f-&gt;sections = realloc(f-&gt;sections, (i+1) * sizeof(sec), i * sizeof(sec));</font>
<font color="#a52a2a">2734</font>  <font color="#008b8b">+         f-&gt;sections[i] = sec = arch_new_section();</font>
<font color="#a52a2a">2735</font>  <font color="#008b8b">+         f-&gt;header.e_shnum = i+1;</font>
<font color="#a52a2a">2736</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">2737</font>  <font color="#008b8b">+         memset(sec, 0, sizeof(*sec));</font>
<font color="#a52a2a">2738</font>  <font color="#008b8b">+         sec-&gt;header.sh_type = SHT_PROGBITS;</font>
<font color="#a52a2a">2739</font>  <font color="#008b8b">+         sec-&gt;header.sh_flags = SHF_WRITE|SHF_ALLOC;</font>
<font color="#a52a2a">2740</font>  <font color="#008b8b">+         sec-&gt;name = &quot;.bss&quot;;</font>
<font color="#a52a2a">2741</font>  <font color="#008b8b">+         sec-&gt;idx = i;</font>
<font color="#a52a2a">2742</font>  <font color="#008b8b">+       }</font>
<font color="#a52a2a">2743</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">2744</font>  <font color="#008b8b">+      /* Allocate the COMMONS.  */</font>
<font color="#a52a2a">2745</font>  <font color="#008b8b">+      {</font>
<font color="#a52a2a">2746</font>  <font color="#008b8b">+       ElfW(Addr) bss_size = f-&gt;sections[i]-&gt;header.sh_size;</font>
<font color="#a52a2a">2747</font>  <font color="#008b8b">+       ElfW(Addr) max_align = f-&gt;sections[i]-&gt;header.sh_addralign;</font>
<font color="#a52a2a">2748</font>  <font color="#008b8b">+       struct common_entry *c;</font>
<font color="#a52a2a">2749</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">2750</font>  <font color="#008b8b">+       for (c = common_head; c ; c = c-&gt;next)</font>
<font color="#a52a2a">2751</font>  <font color="#008b8b">+         {</font>
<font color="#a52a2a">2752</font>  <font color="#008b8b">+           ElfW(Addr) align = c-&gt;sym-&gt;value;</font>
<font color="#a52a2a">2753</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">2754</font>  <font color="#008b8b">+           if (align &gt; max_align)</font>
<font color="#a52a2a">2755</font>  <font color="#008b8b">+             max_align = align;</font>
<font color="#a52a2a">2756</font>  <font color="#008b8b">+           if (bss_size &amp; (align - 1))</font>
<font color="#a52a2a">2757</font>  <font color="#008b8b">+             bss_size = (bss_size | (align - 1)) + 1;</font>
<font color="#a52a2a">2758</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">2759</font>  <font color="#008b8b">+           c-&gt;sym-&gt;secidx = i;</font>
<font color="#a52a2a">2760</font>  <font color="#008b8b">+           c-&gt;sym-&gt;value = bss_size;</font>
<font color="#a52a2a">2761</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">2762</font>  <font color="#008b8b">+           bss_size += c-&gt;sym-&gt;size;</font>
<font color="#a52a2a">2763</font>  <font color="#008b8b">+         }</font>
<font color="#a52a2a">2764</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">2765</font>  <font color="#008b8b">+       f-&gt;sections[i]-&gt;header.sh_size = bss_size;</font>
<font color="#a52a2a">2766</font>  <font color="#008b8b">+       f-&gt;sections[i]-&gt;header.sh_addralign = max_align;</font>
<font color="#a52a2a">2767</font>  <font color="#008b8b">+      }</font>
<font color="#a52a2a">2768</font>  <font color="#008b8b">+    }</font>
<font color="#a52a2a">2769</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">2770</font>  <font color="#008b8b">+  /* For the sake of patch relocation and parameter initialization,</font>
<font color="#a52a2a">2771</font>  <font color="#008b8b">+     allocate zeroed data for NOBITS sections now.  Note that after</font>
<font color="#a52a2a">2772</font>  <font color="#008b8b">+     this we cannot assume NOBITS are really empty.  */</font>
<font color="#a52a2a">2773</font>  <font color="#008b8b">+  for (i = 0; i &lt; f-&gt;header.e_shnum; ++i)</font>
<font color="#a52a2a">2774</font>  <font color="#008b8b">+    {</font>
<font color="#a52a2a">2775</font>  <font color="#008b8b">+      struct obj_section *s = f-&gt;sections[i];</font>
<font color="#a52a2a">2776</font>  <font color="#008b8b">+      if (s-&gt;header.sh_type == SHT_NOBITS)</font>
<font color="#a52a2a">2777</font>  <font color="#008b8b">+       {</font>
<font color="#a52a2a">2778</font>  <font color="#008b8b">+         if (s-&gt;header.sh_size)</font>
<font color="#a52a2a">2779</font>  <font color="#008b8b">+           s-&gt;contents = memset(kmalloc(s-&gt;header.sh_size, GFP_KERNEL),</font>
<font color="#a52a2a">2780</font>  <font color="#008b8b">+                                0, s-&gt;header.sh_size);</font>
<font color="#a52a2a">2781</font>  <font color="#008b8b">+         else</font>
<font color="#a52a2a">2782</font>  <font color="#008b8b">+           s-&gt;contents = NULL;</font>
<font color="#a52a2a">2783</font>  <font color="#008b8b">+         s-&gt;header.sh_type = SHT_PROGBITS;</font>
<font color="#a52a2a">2784</font>  <font color="#008b8b">+       }</font>
<font color="#a52a2a">2785</font>  <font color="#008b8b">+    }</font>
<font color="#a52a2a">2786</font>  <font color="#008b8b">+}</font>
<font color="#a52a2a">2787</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">2788</font>  <font color="#008b8b">+unsigned long</font>
<font color="#a52a2a">2789</font>  <font color="#008b8b">+obj_load_size (struct obj_file *f)</font>
<font color="#a52a2a">2790</font>  <font color="#008b8b">+{</font>
<font color="#a52a2a">2791</font>  <font color="#008b8b">+  unsigned long dot = 0;</font>
<font color="#a52a2a">2792</font>  <font color="#008b8b">+  struct obj_section *sec;</font>
<font color="#a52a2a">2793</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">2794</font>  <font color="#008b8b">+  /* Finalize the positions of the sections relative to one another.  */</font>
<font color="#a52a2a">2795</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">2796</font>  <font color="#008b8b">+  for (sec = f-&gt;load_order; sec ; sec = sec-&gt;load_next)</font>
<font color="#a52a2a">2797</font>  <font color="#008b8b">+    {</font>
<font color="#a52a2a">2798</font>  <font color="#008b8b">+      ElfW(Addr) align;</font>
<font color="#a52a2a">2799</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">2800</font>  <font color="#008b8b">+      align = sec-&gt;header.sh_addralign;</font>
<font color="#a52a2a">2801</font>  <font color="#008b8b">+      if (align &amp;&amp; (dot &amp; (align - 1)))</font>
<font color="#a52a2a">2802</font>  <font color="#008b8b">+       dot = (dot | (align - 1)) + 1;</font>
<font color="#a52a2a">2803</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">2804</font>  <font color="#008b8b">+      sec-&gt;header.sh_addr = dot;</font>
<font color="#a52a2a">2805</font>  <font color="#008b8b">+      dot += sec-&gt;header.sh_size;</font>
<font color="#a52a2a">2806</font>  <font color="#008b8b">+    }</font>
<font color="#a52a2a">2807</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">2808</font>  <font color="#008b8b">+  return dot;</font>
<font color="#a52a2a">2809</font>  <font color="#008b8b">+}</font>
<font color="#a52a2a">2810</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">2811</font>  <font color="#008b8b">+int</font>
<font color="#a52a2a">2812</font>  <font color="#008b8b">+obj_relocate (struct obj_file *f, ElfW(Addr) base)</font>
<font color="#a52a2a">2813</font>  <font color="#008b8b">+{</font>
<font color="#a52a2a">2814</font>  <font color="#008b8b">+  int i, n = f-&gt;header.e_shnum;</font>
<font color="#a52a2a">2815</font>  <font color="#008b8b">+  int ret = 1;</font>
<font color="#a52a2a">2816</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">2817</font>  <font color="#008b8b">+  /* Finalize the addresses of the sections.  */</font>
<font color="#a52a2a">2818</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">2819</font>  <font color="#008b8b">+  arch_finalize_section_address(f, base);</font>
<font color="#a52a2a">2820</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">2821</font>  <font color="#008b8b">+  /* And iterate over all of the relocations.  */</font>
<font color="#a52a2a">2822</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">2823</font>  <font color="#008b8b">+  for (i = 0; i &lt; n; ++i)</font>
<font color="#a52a2a">2824</font>  <font color="#008b8b">+    {</font>
<font color="#a52a2a">2825</font>  <font color="#008b8b">+      struct obj_section *relsec, *symsec, *targsec, *strsec;</font>
<font color="#a52a2a">2826</font>  <font color="#008b8b">+      ElfW(Rel) *rel, *relend;</font>
<font color="#a52a2a">2827</font>  <font color="#008b8b">+      ElfW(Sym) *symtab;</font>
<font color="#a52a2a">2828</font>  <font color="#008b8b">+      const char *strtab;</font>
<font color="#a52a2a">2829</font>  <font color="#008b8b">+      unsigned long nsyms;</font>
<font color="#a52a2a">2830</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">2831</font>  <font color="#008b8b">+      relsec = f-&gt;sections[i];</font>
<font color="#a52a2a">2832</font>  <font color="#008b8b">+      if (relsec-&gt;header.sh_type != SHT_REL)</font>
<font color="#a52a2a">2833</font>  <font color="#008b8b">+       continue;</font>
<font color="#a52a2a">2834</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">2835</font>  <font color="#008b8b">+      symsec = f-&gt;sections[relsec-&gt;header.sh_link];</font>
<font color="#a52a2a">2836</font>  <font color="#008b8b">+      targsec = f-&gt;sections[relsec-&gt;header.sh_info];</font>
<font color="#a52a2a">2837</font>  <font color="#008b8b">+      strsec = f-&gt;sections[symsec-&gt;header.sh_link];</font>
<font color="#a52a2a">2838</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">2839</font>  <font color="#008b8b">+      if (!(targsec-&gt;header.sh_flags &amp; SHF_ALLOC))</font>
<font color="#a52a2a">2840</font>  <font color="#008b8b">+       continue;</font>
<font color="#a52a2a">2841</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">2842</font>  <font color="#008b8b">+      rel = (ElfW(Rel) *)relsec-&gt;contents;</font>
<font color="#a52a2a">2843</font>  <font color="#008b8b">+      relend = rel + (relsec-&gt;header.sh_size / sizeof(ElfW(Rel)));</font>
<font color="#a52a2a">2844</font>  <font color="#008b8b">+      symtab = (ElfW(Sym) *)symsec-&gt;contents;</font>
<font color="#a52a2a">2845</font>  <font color="#008b8b">+      nsyms = symsec-&gt;header.sh_size / symsec-&gt;header.sh_entsize;</font>
<font color="#a52a2a">2846</font>  <font color="#008b8b">+      strtab = (const char *)strsec-&gt;contents;</font>
<font color="#a52a2a">2847</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">2848</font>  <font color="#008b8b">+      for (; rel &lt; relend; ++rel)</font>
<font color="#a52a2a">2849</font>  <font color="#008b8b">+       {</font>
<font color="#a52a2a">2850</font>  <font color="#008b8b">+         ElfW(Addr) value = 0;</font>
<font color="#a52a2a">2851</font>  <font color="#008b8b">+         struct obj_symbol *intsym = NULL;</font>
<font color="#a52a2a">2852</font>  <font color="#008b8b">+         unsigned long symndx;</font>
<font color="#a52a2a">2853</font>  <font color="#008b8b">+         const char *errmsg;</font>
<font color="#a52a2a">2854</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">2855</font>  <font color="#008b8b">+         /* Attempt to find a value to use for this relocation.  */</font>
<font color="#a52a2a">2856</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">2857</font>  <font color="#008b8b">+         symndx = ELFW(R_SYM)(rel-&gt;r_info);</font>
<font color="#a52a2a">2858</font>  <font color="#008b8b">+         if (symndx)</font>
<font color="#a52a2a">2859</font>  <font color="#008b8b">+           {</font>
<font color="#a52a2a">2860</font>  <font color="#008b8b">+             /* Note we've already checked for undefined symbols.  */</font>
<font color="#a52a2a">2861</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">2862</font>  <font color="#008b8b">+             if (symndx &gt;= nsyms)</font>
<font color="#a52a2a">2863</font>  <font color="#008b8b">+               {</font>
<font color="#a52a2a">2864</font>  <font color="#008b8b">+                 printk(KERN_INFO &quot;Bad symbol index: %08lx &gt;= %08lx&quot;,</font>
<font color="#a52a2a">2865</font>  <font color="#008b8b">+                       symndx, nsyms);</font>
<font color="#a52a2a">2866</font>  <font color="#008b8b">+                 continue;</font>
<font color="#a52a2a">2867</font>  <font color="#008b8b">+               }</font>
<font color="#a52a2a">2868</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">2869</font>  <font color="#008b8b">+             obj_find_relsym(intsym, f, f, rel, symtab, strtab);</font>
<font color="#a52a2a">2870</font>  <font color="#008b8b">+             value = obj_symbol_final_value(f, intsym);</font>
<font color="#a52a2a">2871</font>  <font color="#008b8b">+           }</font>
<font color="#a52a2a">2872</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">2873</font>  <font color="#008b8b">+#if SHT_RELM == SHT_RELA</font>
<font color="#a52a2a">2874</font>  <font color="#008b8b">+         value += rel-&gt;r_addend;</font>
<font color="#a52a2a">2875</font>  <font color="#008b8b">+#endif</font>
<font color="#a52a2a">2876</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">2877</font>  <font color="#008b8b">+         /* Do it! */</font>
<font color="#a52a2a">2878</font>  <font color="#008b8b">+         switch (arch_apply_relocation(f,targsec,symsec,intsym,rel,value))</font>
<font color="#a52a2a">2879</font>  <font color="#008b8b">+           {</font>
<font color="#a52a2a">2880</font>  <font color="#008b8b">+           case obj_reloc_ok:</font>
<font color="#a52a2a">2881</font>  <font color="#008b8b">+             break;</font>
<font color="#a52a2a">2882</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">2883</font>  <font color="#008b8b">+           case obj_reloc_overflow:</font>
<font color="#a52a2a">2884</font>  <font color="#008b8b">+             errmsg = &quot;Relocation overflow&quot;;</font>
<font color="#a52a2a">2885</font>  <font color="#008b8b">+             goto bad_reloc;</font>
<font color="#a52a2a">2886</font>  <font color="#008b8b">+           case obj_reloc_dangerous:</font>
<font color="#a52a2a">2887</font>  <font color="#008b8b">+             errmsg = &quot;Dangerous relocation&quot;;</font>
<font color="#a52a2a">2888</font>  <font color="#008b8b">+             goto bad_reloc;</font>
<font color="#a52a2a">2889</font>  <font color="#008b8b">+           case obj_reloc_unhandled:</font>
<font color="#a52a2a">2890</font>  <font color="#008b8b">+             errmsg = &quot;Unhandled relocation&quot;;</font>
<font color="#a52a2a">2891</font>  <font color="#008b8b">+             goto bad_reloc;</font>
<font color="#a52a2a">2892</font>  <font color="#008b8b">+           case obj_reloc_constant_gp:</font>
<font color="#a52a2a">2893</font>  <font color="#008b8b">+             errmsg = &quot;Modules compiled with -mconstant-gp cannot be loaded&quot;;</font>
<font color="#a52a2a">2894</font>  <font color="#008b8b">+             goto bad_reloc;</font>
<font color="#a52a2a">2895</font>  <font color="#008b8b">+           bad_reloc:</font>
<font color="#a52a2a">2896</font>  <font color="#008b8b">+             printk(KERN_INFO &quot;%s of type %ld for %s&quot;, errmsg,</font>
<font color="#a52a2a">2897</font>  <font color="#008b8b">+                   (long)ELFW(R_TYPE)(rel-&gt;r_info), intsym-&gt;name);</font>
<font color="#a52a2a">2898</font>  <font color="#008b8b">+             ret = 0;</font>
<font color="#a52a2a">2899</font>  <font color="#008b8b">+             break;</font>
<font color="#a52a2a">2900</font>  <font color="#008b8b">+           }</font>
<font color="#a52a2a">2901</font>  <font color="#008b8b">+       }</font>
<font color="#a52a2a">2902</font>  <font color="#008b8b">+    }</font>
<font color="#a52a2a">2903</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">2904</font>  <font color="#008b8b">+  /* Finally, take care of the patches.  */</font>
<font color="#a52a2a">2905</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">2906</font>  <font color="#008b8b">+  if (f-&gt;string_patches)</font>
<font color="#a52a2a">2907</font>  <font color="#008b8b">+    {</font>
<font color="#a52a2a">2908</font>  <font color="#008b8b">+      struct obj_string_patch_struct *p;</font>
<font color="#a52a2a">2909</font>  <font color="#008b8b">+      struct obj_section *strsec;</font>
<font color="#a52a2a">2910</font>  <font color="#008b8b">+      ElfW(Addr) strsec_base;</font>
<font color="#a52a2a">2911</font>  <font color="#008b8b">+      strsec = obj_find_section(f, &quot;.kstrtab&quot;);</font>
<font color="#a52a2a">2912</font>  <font color="#008b8b">+      strsec_base = strsec-&gt;header.sh_addr;</font>
<font color="#a52a2a">2913</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">2914</font>  <font color="#008b8b">+      for (p = f-&gt;string_patches; p ; p = p-&gt;next)</font>
<font color="#a52a2a">2915</font>  <font color="#008b8b">+       {</font>
<font color="#a52a2a">2916</font>  <font color="#008b8b">+         struct obj_section *targsec = f-&gt;sections[p-&gt;reloc_secidx];</font>
<font color="#a52a2a">2917</font>  <font color="#008b8b">+         *(ElfW(Addr) *)(targsec-&gt;contents + p-&gt;reloc_offset)</font>
<font color="#a52a2a">2918</font>  <font color="#008b8b">+           = strsec_base + p-&gt;string_offset;</font>
<font color="#a52a2a">2919</font>  <font color="#008b8b">+       }</font>
<font color="#a52a2a">2920</font>  <font color="#008b8b">+    }</font>
<font color="#a52a2a">2921</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">2922</font>  <font color="#008b8b">+  if (f-&gt;symbol_patches)</font>
<font color="#a52a2a">2923</font>  <font color="#008b8b">+    {</font>
<font color="#a52a2a">2924</font>  <font color="#008b8b">+      struct obj_symbol_patch_struct *p;</font>
<font color="#a52a2a">2925</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">2926</font>  <font color="#008b8b">+      for (p = f-&gt;symbol_patches; p; p = p-&gt;next)</font>
<font color="#a52a2a">2927</font>  <font color="#008b8b">+       {</font>
<font color="#a52a2a">2928</font>  <font color="#008b8b">+         struct obj_section *targsec = f-&gt;sections[p-&gt;reloc_secidx];</font>
<font color="#a52a2a">2929</font>  <font color="#008b8b">+         *(ElfW(Addr) *)(targsec-&gt;contents + p-&gt;reloc_offset)</font>
<font color="#a52a2a">2930</font>  <font color="#008b8b">+           = obj_symbol_final_value(f, p-&gt;sym);</font>
<font color="#a52a2a">2931</font>  <font color="#008b8b">+       }</font>
<font color="#a52a2a">2932</font>  <font color="#008b8b">+    }</font>
<font color="#a52a2a">2933</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">2934</font>  <font color="#008b8b">+  return ret;</font>
<font color="#a52a2a">2935</font>  <font color="#008b8b">+}</font>
<font color="#a52a2a">2936</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">2937</font>  <font color="#008b8b">+int</font>
<font color="#a52a2a">2938</font>  <font color="#008b8b">+obj_create_image (struct obj_file *f, char *image)</font>
<font color="#a52a2a">2939</font>  <font color="#008b8b">+{</font>
<font color="#a52a2a">2940</font>  <font color="#008b8b">+  struct obj_section *sec;</font>
<font color="#a52a2a">2941</font>  <font color="#008b8b">+  ElfW(Addr) base = f-&gt;baseaddr;</font>
<font color="#a52a2a">2942</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">2943</font>  <font color="#008b8b">+  for (sec = f-&gt;load_order; sec ; sec = sec-&gt;load_next)</font>
<font color="#a52a2a">2944</font>  <font color="#008b8b">+    {</font>
<font color="#a52a2a">2945</font>  <font color="#008b8b">+      char *secimg;</font>
<font color="#a52a2a">2946</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">2947</font>  <font color="#008b8b">+      if (sec-&gt;contents == 0)</font>
<font color="#a52a2a">2948</font>  <font color="#008b8b">+       continue;</font>
<font color="#a52a2a">2949</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">2950</font>  <font color="#008b8b">+      secimg = image + (sec-&gt;header.sh_addr - base);</font>
<font color="#a52a2a">2951</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">2952</font>  <font color="#008b8b">+      /* Note that we allocated data for NOBITS sections earlier.  */</font>
<font color="#a52a2a">2953</font>  <font color="#008b8b">+      memcpy(secimg, sec-&gt;contents, sec-&gt;header.sh_size);</font>
<font color="#a52a2a">2954</font>  <font color="#008b8b">+    }</font>
<font color="#a52a2a">2955</font>  <font color="#008b8b">+</font>
<font color="#a52a2a">2956</font>  <font color="#008b8b">+  return 1;</font>
<font color="#a52a2a">2957</font>  <font color="#008b8b">+}</font>
</PRE>
							</td>
						</tr>
					</table>
				</td>
			</tr>
		</table>
	</body>
</HTML>
